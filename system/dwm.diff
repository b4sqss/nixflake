diff -crNb dwm-6.2/.git/COMMIT_EDITMSG dwm/.git/COMMIT_EDITMSG
*** dwm-6.2/.git/COMMIT_EDITMSG	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/COMMIT_EDITMSG	2021-10-31 17:28:42.181186130 -0300
***************
*** 0 ****
--- 1 ----
+ returned to mpd
diff -crNb dwm-6.2/.git/HEAD dwm/.git/HEAD
*** dwm-6.2/.git/HEAD	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/HEAD	2021-10-31 17:28:42.181186130 -0300
***************
*** 0 ****
--- 1 ----
+ ref: refs/heads/main
diff -crNb dwm-6.2/.git/config dwm/.git/config
*** dwm-6.2/.git/config	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/config	2021-10-31 17:28:42.182186138 -0300
***************
*** 0 ****
--- 1,11 ----
+ [core]
+ 	repositoryformatversion = 0
+ 	filemode = true
+ 	bare = false
+ 	logallrefupdates = true
+ [remote "origin"]
+ 	url = https://gitlab.com/b4sqss/dwm.git
+ 	fetch = +refs/heads/*:refs/remotes/origin/*
+ [branch "main"]
+ 	remote = origin
+ 	merge = refs/heads/main
diff -crNb dwm-6.2/.git/description dwm/.git/description
*** dwm-6.2/.git/description	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/description	2021-10-31 17:28:42.182186138 -0300
***************
*** 0 ****
--- 1 ----
+ Unnamed repository; edit this file 'description' to name the repository.
diff -crNb dwm-6.2/.git/hooks/applypatch-msg.sample dwm/.git/hooks/applypatch-msg.sample
*** dwm-6.2/.git/hooks/applypatch-msg.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/applypatch-msg.sample	2021-10-31 17:28:42.194186228 -0300
***************
*** 0 ****
--- 1,15 ----
+ #!/bin/sh
+ #
+ # An example hook script to check the commit log message taken by
+ # applypatch from an e-mail message.
+ #
+ # The hook should exit with non-zero status after issuing an
+ # appropriate message if it wants to stop the commit.  The hook is
+ # allowed to edit the commit message file.
+ #
+ # To enable this hook, rename this file to "applypatch-msg".
+ 
+ . git-sh-setup
+ commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+ test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+ :
diff -crNb dwm-6.2/.git/hooks/commit-msg.sample dwm/.git/hooks/commit-msg.sample
*** dwm-6.2/.git/hooks/commit-msg.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/commit-msg.sample	2021-10-31 17:28:42.200186273 -0300
***************
*** 0 ****
--- 1,24 ----
+ #!/bin/sh
+ #
+ # An example hook script to check the commit log message.
+ # Called by "git commit" with one argument, the name of the file
+ # that has the commit message.  The hook should exit with non-zero
+ # status after issuing an appropriate message if it wants to stop the
+ # commit.  The hook is allowed to edit the commit message file.
+ #
+ # To enable this hook, rename this file to "commit-msg".
+ 
+ # Uncomment the below to add a Signed-off-by line to the message.
+ # Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+ # hook is more suited to it.
+ #
+ # SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+ # grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+ 
+ # This example catches duplicate Signed-off-by lines.
+ 
+ test "" = "$(grep '^Signed-off-by: ' "$1" |
+ 	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+ 	echo >&2 Duplicate Signed-off-by lines.
+ 	exit 1
+ }
diff -crNb dwm-6.2/.git/hooks/fsmonitor-watchman.sample dwm/.git/hooks/fsmonitor-watchman.sample
*** dwm-6.2/.git/hooks/fsmonitor-watchman.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/fsmonitor-watchman.sample	2021-10-31 17:28:42.210186348 -0300
***************
*** 0 ****
--- 1,173 ----
+ #!/usr/bin/perl
+ 
+ use strict;
+ use warnings;
+ use IPC::Open2;
+ 
+ # An example hook script to integrate Watchman
+ # (https://facebook.github.io/watchman/) with git to speed up detecting
+ # new and modified files.
+ #
+ # The hook is passed a version (currently 2) and last update token
+ # formatted as a string and outputs to stdout a new update token and
+ # all files that have been modified since the update token. Paths must
+ # be relative to the root of the working tree and separated by a single NUL.
+ #
+ # To enable this hook, rename this file to "query-watchman" and set
+ # 'git config core.fsmonitor .git/hooks/query-watchman'
+ #
+ my ($version, $last_update_token) = @ARGV;
+ 
+ # Uncomment for debugging
+ # print STDERR "$0 $version $last_update_token\n";
+ 
+ # Check the hook interface version
+ if ($version ne 2) {
+ 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+ 	    "Falling back to scanning...\n";
+ }
+ 
+ my $git_work_tree = get_working_dir();
+ 
+ my $retry = 1;
+ 
+ my $json_pkg;
+ eval {
+ 	require JSON::XS;
+ 	$json_pkg = "JSON::XS";
+ 	1;
+ } or do {
+ 	require JSON::PP;
+ 	$json_pkg = "JSON::PP";
+ };
+ 
+ launch_watchman();
+ 
+ sub launch_watchman {
+ 	my $o = watchman_query();
+ 	if (is_work_tree_watched($o)) {
+ 		output_result($o->{clock}, @{$o->{files}});
+ 	}
+ }
+ 
+ sub output_result {
+ 	my ($clockid, @files) = @_;
+ 
+ 	# Uncomment for debugging watchman output
+ 	# open (my $fh, ">", ".git/watchman-output.out");
+ 	# binmode $fh, ":utf8";
+ 	# print $fh "$clockid\n@files\n";
+ 	# close $fh;
+ 
+ 	binmode STDOUT, ":utf8";
+ 	print $clockid;
+ 	print "\0";
+ 	local $, = "\0";
+ 	print @files;
+ }
+ 
+ sub watchman_clock {
+ 	my $response = qx/watchman clock "$git_work_tree"/;
+ 	die "Failed to get clock id on '$git_work_tree'.\n" .
+ 		"Falling back to scanning...\n" if $? != 0;
+ 
+ 	return $json_pkg->new->utf8->decode($response);
+ }
+ 
+ sub watchman_query {
+ 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+ 	or die "open2() failed: $!\n" .
+ 	"Falling back to scanning...\n";
+ 
+ 	# In the query expression below we're asking for names of files that
+ 	# changed since $last_update_token but not from the .git folder.
+ 	#
+ 	# To accomplish this, we're using the "since" generator to use the
+ 	# recency index to select candidate nodes and "fields" to limit the
+ 	# output to file names only. Then we're using the "expression" term to
+ 	# further constrain the results.
+ 	if (substr($last_update_token, 0, 1) eq "c") {
+ 		$last_update_token = "\"$last_update_token\"";
+ 	}
+ 	my $query = <<"	END";
+ 		["query", "$git_work_tree", {
+ 			"since": $last_update_token,
+ 			"fields": ["name"],
+ 			"expression": ["not", ["dirname", ".git"]]
+ 		}]
+ 	END
+ 
+ 	# Uncomment for debugging the watchman query
+ 	# open (my $fh, ">", ".git/watchman-query.json");
+ 	# print $fh $query;
+ 	# close $fh;
+ 
+ 	print CHLD_IN $query;
+ 	close CHLD_IN;
+ 	my $response = do {local $/; <CHLD_OUT>};
+ 
+ 	# Uncomment for debugging the watch response
+ 	# open ($fh, ">", ".git/watchman-response.json");
+ 	# print $fh $response;
+ 	# close $fh;
+ 
+ 	die "Watchman: command returned no output.\n" .
+ 	"Falling back to scanning...\n" if $response eq "";
+ 	die "Watchman: command returned invalid output: $response\n" .
+ 	"Falling back to scanning...\n" unless $response =~ /^\{/;
+ 
+ 	return $json_pkg->new->utf8->decode($response);
+ }
+ 
+ sub is_work_tree_watched {
+ 	my ($output) = @_;
+ 	my $error = $output->{error};
+ 	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+ 		$retry--;
+ 		my $response = qx/watchman watch "$git_work_tree"/;
+ 		die "Failed to make watchman watch '$git_work_tree'.\n" .
+ 		    "Falling back to scanning...\n" if $? != 0;
+ 		$output = $json_pkg->new->utf8->decode($response);
+ 		$error = $output->{error};
+ 		die "Watchman: $error.\n" .
+ 		"Falling back to scanning...\n" if $error;
+ 
+ 		# Uncomment for debugging watchman output
+ 		# open (my $fh, ">", ".git/watchman-output.out");
+ 		# close $fh;
+ 
+ 		# Watchman will always return all files on the first query so
+ 		# return the fast "everything is dirty" flag to git and do the
+ 		# Watchman query just to get it over with now so we won't pay
+ 		# the cost in git to look up each individual file.
+ 		my $o = watchman_clock();
+ 		$error = $output->{error};
+ 
+ 		die "Watchman: $error.\n" .
+ 		"Falling back to scanning...\n" if $error;
+ 
+ 		output_result($o->{clock}, ("/"));
+ 		$last_update_token = $o->{clock};
+ 
+ 		eval { launch_watchman() };
+ 		return 0;
+ 	}
+ 
+ 	die "Watchman: $error.\n" .
+ 	"Falling back to scanning...\n" if $error;
+ 
+ 	return 1;
+ }
+ 
+ sub get_working_dir {
+ 	my $working_dir;
+ 	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+ 		$working_dir = Win32::GetCwd();
+ 		$working_dir =~ tr/\\/\//;
+ 	} else {
+ 		require Cwd;
+ 		$working_dir = Cwd::cwd();
+ 	}
+ 
+ 	return $working_dir;
+ }
diff -crNb dwm-6.2/.git/hooks/post-update.sample dwm/.git/hooks/post-update.sample
*** dwm-6.2/.git/hooks/post-update.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/post-update.sample	2021-10-31 17:28:42.210186348 -0300
***************
*** 0 ****
--- 1,8 ----
+ #!/bin/sh
+ #
+ # An example hook script to prepare a packed repository for use over
+ # dumb transports.
+ #
+ # To enable this hook, rename this file to "post-update".
+ 
+ exec git update-server-info
diff -crNb dwm-6.2/.git/hooks/pre-applypatch.sample dwm/.git/hooks/pre-applypatch.sample
*** dwm-6.2/.git/hooks/pre-applypatch.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/pre-applypatch.sample	2021-10-31 17:28:42.210186348 -0300
***************
*** 0 ****
--- 1,14 ----
+ #!/bin/sh
+ #
+ # An example hook script to verify what is about to be committed
+ # by applypatch from an e-mail message.
+ #
+ # The hook should exit with non-zero status after issuing an
+ # appropriate message if it wants to stop the commit.
+ #
+ # To enable this hook, rename this file to "pre-applypatch".
+ 
+ . git-sh-setup
+ precommit="$(git rev-parse --git-path hooks/pre-commit)"
+ test -x "$precommit" && exec "$precommit" ${1+"$@"}
+ :
diff -crNb dwm-6.2/.git/hooks/pre-commit.sample dwm/.git/hooks/pre-commit.sample
*** dwm-6.2/.git/hooks/pre-commit.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/pre-commit.sample	2021-10-31 17:28:42.211186355 -0300
***************
*** 0 ****
--- 1,49 ----
+ #!/bin/sh
+ #
+ # An example hook script to verify what is about to be committed.
+ # Called by "git commit" with no arguments.  The hook should
+ # exit with non-zero status after issuing an appropriate message if
+ # it wants to stop the commit.
+ #
+ # To enable this hook, rename this file to "pre-commit".
+ 
+ if git rev-parse --verify HEAD >/dev/null 2>&1
+ then
+ 	against=HEAD
+ else
+ 	# Initial commit: diff against an empty tree object
+ 	against=$(git hash-object -t tree /dev/null)
+ fi
+ 
+ # If you want to allow non-ASCII filenames set this variable to true.
+ allownonascii=$(git config --type=bool hooks.allownonascii)
+ 
+ # Redirect output to stderr.
+ exec 1>&2
+ 
+ # Cross platform projects tend to avoid non-ASCII filenames; prevent
+ # them from being added to the repository. We exploit the fact that the
+ # printable range starts at the space character and ends with tilde.
+ if [ "$allownonascii" != "true" ] &&
+ 	# Note that the use of brackets around a tr range is ok here, (it's
+ 	# even required, for portability to Solaris 10's /usr/bin/tr), since
+ 	# the square bracket bytes happen to fall in the designated range.
+ 	test $(git diff --cached --name-only --diff-filter=A -z $against |
+ 	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+ then
+ 	cat <<\EOF
+ Error: Attempt to add a non-ASCII file name.
+ 
+ This can cause problems if you want to work with people on other platforms.
+ 
+ To be portable it is advisable to rename the file.
+ 
+ If you know what you are doing you can disable this check using:
+ 
+   git config hooks.allownonascii true
+ EOF
+ 	exit 1
+ fi
+ 
+ # If there are whitespace errors, print the offending file names and fail.
+ exec git diff-index --check --cached $against --
diff -crNb dwm-6.2/.git/hooks/pre-merge-commit.sample dwm/.git/hooks/pre-merge-commit.sample
*** dwm-6.2/.git/hooks/pre-merge-commit.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/pre-merge-commit.sample	2021-10-31 17:28:42.211186355 -0300
***************
*** 0 ****
--- 1,13 ----
+ #!/bin/sh
+ #
+ # An example hook script to verify what is about to be committed.
+ # Called by "git merge" with no arguments.  The hook should
+ # exit with non-zero status after issuing an appropriate message to
+ # stderr if it wants to stop the merge commit.
+ #
+ # To enable this hook, rename this file to "pre-merge-commit".
+ 
+ . git-sh-setup
+ test -x "$GIT_DIR/hooks/pre-commit" &&
+         exec "$GIT_DIR/hooks/pre-commit"
+ :
diff -crNb dwm-6.2/.git/hooks/pre-push.sample dwm/.git/hooks/pre-push.sample
*** dwm-6.2/.git/hooks/pre-push.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/pre-push.sample	2021-10-31 17:28:42.211186355 -0300
***************
*** 0 ****
--- 1,53 ----
+ #!/bin/sh
+ 
+ # An example hook script to verify what is about to be pushed.  Called by "git
+ # push" after it has checked the remote status, but before anything has been
+ # pushed.  If this script exits with a non-zero status nothing will be pushed.
+ #
+ # This hook is called with the following parameters:
+ #
+ # $1 -- Name of the remote to which the push is being done
+ # $2 -- URL to which the push is being done
+ #
+ # If pushing without using a named remote those arguments will be equal.
+ #
+ # Information about the commits which are being pushed is supplied as lines to
+ # the standard input in the form:
+ #
+ #   <local ref> <local oid> <remote ref> <remote oid>
+ #
+ # This sample shows how to prevent push of commits where the log message starts
+ # with "WIP" (work in progress).
+ 
+ remote="$1"
+ url="$2"
+ 
+ zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+ 
+ while read local_ref local_oid remote_ref remote_oid
+ do
+ 	if test "$local_oid" = "$zero"
+ 	then
+ 		# Handle delete
+ 		:
+ 	else
+ 		if test "$remote_oid" = "$zero"
+ 		then
+ 			# New branch, examine all commits
+ 			range="$local_oid"
+ 		else
+ 			# Update to existing branch, examine new commits
+ 			range="$remote_oid..$local_oid"
+ 		fi
+ 
+ 		# Check for WIP commit
+ 		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+ 		if test -n "$commit"
+ 		then
+ 			echo >&2 "Found WIP commit in $local_ref, not pushing"
+ 			exit 1
+ 		fi
+ 	fi
+ done
+ 
+ exit 0
diff -crNb dwm-6.2/.git/hooks/pre-rebase.sample dwm/.git/hooks/pre-rebase.sample
*** dwm-6.2/.git/hooks/pre-rebase.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/pre-rebase.sample	2021-10-31 17:28:42.211186355 -0300
***************
*** 0 ****
--- 1,169 ----
+ #!/bin/sh
+ #
+ # Copyright (c) 2006, 2008 Junio C Hamano
+ #
+ # The "pre-rebase" hook is run just before "git rebase" starts doing
+ # its job, and can prevent the command from running by exiting with
+ # non-zero status.
+ #
+ # The hook is called with the following parameters:
+ #
+ # $1 -- the upstream the series was forked from.
+ # $2 -- the branch being rebased (or empty when rebasing the current branch).
+ #
+ # This sample shows how to prevent topic branches that are already
+ # merged to 'next' branch from getting rebased, because allowing it
+ # would result in rebasing already published history.
+ 
+ publish=next
+ basebranch="$1"
+ if test "$#" = 2
+ then
+ 	topic="refs/heads/$2"
+ else
+ 	topic=`git symbolic-ref HEAD` ||
+ 	exit 0 ;# we do not interrupt rebasing detached HEAD
+ fi
+ 
+ case "$topic" in
+ refs/heads/??/*)
+ 	;;
+ *)
+ 	exit 0 ;# we do not interrupt others.
+ 	;;
+ esac
+ 
+ # Now we are dealing with a topic branch being rebased
+ # on top of master.  Is it OK to rebase it?
+ 
+ # Does the topic really exist?
+ git show-ref -q "$topic" || {
+ 	echo >&2 "No such branch $topic"
+ 	exit 1
+ }
+ 
+ # Is topic fully merged to master?
+ not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+ if test -z "$not_in_master"
+ then
+ 	echo >&2 "$topic is fully merged to master; better remove it."
+ 	exit 1 ;# we could allow it, but there is no point.
+ fi
+ 
+ # Is topic ever merged to next?  If so you should not be rebasing it.
+ only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+ only_next_2=`git rev-list ^master           ${publish} | sort`
+ if test "$only_next_1" = "$only_next_2"
+ then
+ 	not_in_topic=`git rev-list "^$topic" master`
+ 	if test -z "$not_in_topic"
+ 	then
+ 		echo >&2 "$topic is already up to date with master"
+ 		exit 1 ;# we could allow it, but there is no point.
+ 	else
+ 		exit 0
+ 	fi
+ else
+ 	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+ 	/usr/bin/perl -e '
+ 		my $topic = $ARGV[0];
+ 		my $msg = "* $topic has commits already merged to public branch:\n";
+ 		my (%not_in_next) = map {
+ 			/^([0-9a-f]+) /;
+ 			($1 => 1);
+ 		} split(/\n/, $ARGV[1]);
+ 		for my $elem (map {
+ 				/^([0-9a-f]+) (.*)$/;
+ 				[$1 => $2];
+ 			} split(/\n/, $ARGV[2])) {
+ 			if (!exists $not_in_next{$elem->[0]}) {
+ 				if ($msg) {
+ 					print STDERR $msg;
+ 					undef $msg;
+ 				}
+ 				print STDERR " $elem->[1]\n";
+ 			}
+ 		}
+ 	' "$topic" "$not_in_next" "$not_in_master"
+ 	exit 1
+ fi
+ 
+ <<\DOC_END
+ 
+ This sample hook safeguards topic branches that have been
+ published from being rewound.
+ 
+ The workflow assumed here is:
+ 
+  * Once a topic branch forks from "master", "master" is never
+    merged into it again (either directly or indirectly).
+ 
+  * Once a topic branch is fully cooked and merged into "master",
+    it is deleted.  If you need to build on top of it to correct
+    earlier mistakes, a new topic branch is created by forking at
+    the tip of the "master".  This is not strictly necessary, but
+    it makes it easier to keep your history simple.
+ 
+  * Whenever you need to test or publish your changes to topic
+    branches, merge them into "next" branch.
+ 
+ The script, being an example, hardcodes the publish branch name
+ to be "next", but it is trivial to make it configurable via
+ $GIT_DIR/config mechanism.
+ 
+ With this workflow, you would want to know:
+ 
+ (1) ... if a topic branch has ever been merged to "next".  Young
+     topic branches can have stupid mistakes you would rather
+     clean up before publishing, and things that have not been
+     merged into other branches can be easily rebased without
+     affecting other people.  But once it is published, you would
+     not want to rewind it.
+ 
+ (2) ... if a topic branch has been fully merged to "master".
+     Then you can delete it.  More importantly, you should not
+     build on top of it -- other people may already want to
+     change things related to the topic as patches against your
+     "master", so if you need further changes, it is better to
+     fork the topic (perhaps with the same name) afresh from the
+     tip of "master".
+ 
+ Let's look at this example:
+ 
+ 		   o---o---o---o---o---o---o---o---o---o "next"
+ 		  /       /           /           /
+ 		 /   a---a---b A     /           /
+ 		/   /               /           /
+ 	       /   /   c---c---c---c B         /
+ 	      /   /   /             \         /
+ 	     /   /   /   b---b C     \       /
+ 	    /   /   /   /             \     /
+     ---o---o---o---o---o---o---o---o---o---o---o "master"
+ 
+ 
+ A, B and C are topic branches.
+ 
+  * A has one fix since it was merged up to "next".
+ 
+  * B has finished.  It has been fully merged up to "master" and "next",
+    and is ready to be deleted.
+ 
+  * C has not merged to "next" at all.
+ 
+ We would want to allow C to be rebased, refuse A, and encourage
+ B to be deleted.
+ 
+ To compute (1):
+ 
+ 	git rev-list ^master ^topic next
+ 	git rev-list ^master        next
+ 
+ 	if these match, topic has not merged in next at all.
+ 
+ To compute (2):
+ 
+ 	git rev-list master..topic
+ 
+ 	if this is empty, it is fully merged to "master".
+ 
+ DOC_END
diff -crNb dwm-6.2/.git/hooks/pre-receive.sample dwm/.git/hooks/pre-receive.sample
*** dwm-6.2/.git/hooks/pre-receive.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/pre-receive.sample	2021-10-31 17:28:42.212186363 -0300
***************
*** 0 ****
--- 1,24 ----
+ #!/bin/sh
+ #
+ # An example hook script to make use of push options.
+ # The example simply echoes all push options that start with 'echoback='
+ # and rejects all pushes when the "reject" push option is used.
+ #
+ # To enable this hook, rename this file to "pre-receive".
+ 
+ if test -n "$GIT_PUSH_OPTION_COUNT"
+ then
+ 	i=0
+ 	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+ 	do
+ 		eval "value=\$GIT_PUSH_OPTION_$i"
+ 		case "$value" in
+ 		echoback=*)
+ 			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+ 			;;
+ 		reject)
+ 			exit 1
+ 		esac
+ 		i=$((i + 1))
+ 	done
+ fi
diff -crNb dwm-6.2/.git/hooks/prepare-commit-msg.sample dwm/.git/hooks/prepare-commit-msg.sample
*** dwm-6.2/.git/hooks/prepare-commit-msg.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/prepare-commit-msg.sample	2021-10-31 17:28:42.212186363 -0300
***************
*** 0 ****
--- 1,42 ----
+ #!/bin/sh
+ #
+ # An example hook script to prepare the commit log message.
+ # Called by "git commit" with the name of the file that has the
+ # commit message, followed by the description of the commit
+ # message's source.  The hook's purpose is to edit the commit
+ # message file.  If the hook fails with a non-zero status,
+ # the commit is aborted.
+ #
+ # To enable this hook, rename this file to "prepare-commit-msg".
+ 
+ # This hook includes three examples. The first one removes the
+ # "# Please enter the commit message..." help message.
+ #
+ # The second includes the output of "git diff --name-status -r"
+ # into the message, just before the "git status" output.  It is
+ # commented because it doesn't cope with --amend or with squashed
+ # commits.
+ #
+ # The third example adds a Signed-off-by line to the message, that can
+ # still be edited.  This is rarely a good idea.
+ 
+ COMMIT_MSG_FILE=$1
+ COMMIT_SOURCE=$2
+ SHA1=$3
+ 
+ /usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+ 
+ # case "$COMMIT_SOURCE,$SHA1" in
+ #  ,|template,)
+ #    /usr/bin/perl -i.bak -pe '
+ #       print "\n" . `git diff --cached --name-status -r`
+ # 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+ #  *) ;;
+ # esac
+ 
+ # SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+ # git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+ # if test -z "$COMMIT_SOURCE"
+ # then
+ #   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+ # fi
diff -crNb dwm-6.2/.git/hooks/push-to-checkout.sample dwm/.git/hooks/push-to-checkout.sample
*** dwm-6.2/.git/hooks/push-to-checkout.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/push-to-checkout.sample	2021-10-31 17:28:42.212186363 -0300
***************
*** 0 ****
--- 1,78 ----
+ #!/bin/sh
+ 
+ # An example hook script to update a checked-out tree on a git push.
+ #
+ # This hook is invoked by git-receive-pack(1) when it reacts to git
+ # push and updates reference(s) in its repository, and when the push
+ # tries to update the branch that is currently checked out and the
+ # receive.denyCurrentBranch configuration variable is set to
+ # updateInstead.
+ #
+ # By default, such a push is refused if the working tree and the index
+ # of the remote repository has any difference from the currently
+ # checked out commit; when both the working tree and the index match
+ # the current commit, they are updated to match the newly pushed tip
+ # of the branch. This hook is to be used to override the default
+ # behaviour; however the code below reimplements the default behaviour
+ # as a starting point for convenient modification.
+ #
+ # The hook receives the commit with which the tip of the current
+ # branch is going to be updated:
+ commit=$1
+ 
+ # It can exit with a non-zero status to refuse the push (when it does
+ # so, it must not modify the index or the working tree).
+ die () {
+ 	echo >&2 "$*"
+ 	exit 1
+ }
+ 
+ # Or it can make any necessary changes to the working tree and to the
+ # index to bring them to the desired state when the tip of the current
+ # branch is updated to the new commit, and exit with a zero status.
+ #
+ # For example, the hook can simply run git read-tree -u -m HEAD "$1"
+ # in order to emulate git fetch that is run in the reverse direction
+ # with git push, as the two-tree form of git read-tree -u -m is
+ # essentially the same as git switch or git checkout that switches
+ # branches while keeping the local changes in the working tree that do
+ # not interfere with the difference between the branches.
+ 
+ # The below is a more-or-less exact translation to shell of the C code
+ # for the default behaviour for git's push-to-checkout hook defined in
+ # the push_to_deploy() function in builtin/receive-pack.c.
+ #
+ # Note that the hook will be executed from the repository directory,
+ # not from the working tree, so if you want to perform operations on
+ # the working tree, you will have to adapt your code accordingly, e.g.
+ # by adding "cd .." or using relative paths.
+ 
+ if ! git update-index -q --ignore-submodules --refresh
+ then
+ 	die "Up-to-date check failed"
+ fi
+ 
+ if ! git diff-files --quiet --ignore-submodules --
+ then
+ 	die "Working directory has unstaged changes"
+ fi
+ 
+ # This is a rough translation of:
+ #
+ #   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+ if git cat-file -e HEAD 2>/dev/null
+ then
+ 	head=HEAD
+ else
+ 	head=$(git hash-object -t tree --stdin </dev/null)
+ fi
+ 
+ if ! git diff-index --quiet --cached --ignore-submodules $head --
+ then
+ 	die "Working directory has staged changes"
+ fi
+ 
+ if ! git read-tree -u -m "$commit"
+ then
+ 	die "Could not update working tree to new HEAD"
+ fi
diff -crNb dwm-6.2/.git/hooks/update.sample dwm/.git/hooks/update.sample
*** dwm-6.2/.git/hooks/update.sample	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/hooks/update.sample	2021-10-31 17:28:42.213186370 -0300
***************
*** 0 ****
--- 1,128 ----
+ #!/bin/sh
+ #
+ # An example hook script to block unannotated tags from entering.
+ # Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+ #
+ # To enable this hook, rename this file to "update".
+ #
+ # Config
+ # ------
+ # hooks.allowunannotated
+ #   This boolean sets whether unannotated tags will be allowed into the
+ #   repository.  By default they won't be.
+ # hooks.allowdeletetag
+ #   This boolean sets whether deleting tags will be allowed in the
+ #   repository.  By default they won't be.
+ # hooks.allowmodifytag
+ #   This boolean sets whether a tag may be modified after creation. By default
+ #   it won't be.
+ # hooks.allowdeletebranch
+ #   This boolean sets whether deleting branches will be allowed in the
+ #   repository.  By default they won't be.
+ # hooks.denycreatebranch
+ #   This boolean sets whether remotely creating branches will be denied
+ #   in the repository.  By default this is allowed.
+ #
+ 
+ # --- Command line
+ refname="$1"
+ oldrev="$2"
+ newrev="$3"
+ 
+ # --- Safety check
+ if [ -z "$GIT_DIR" ]; then
+ 	echo "Don't run this script from the command line." >&2
+ 	echo " (if you want, you could supply GIT_DIR then run" >&2
+ 	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+ 	exit 1
+ fi
+ 
+ if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+ 	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+ 	exit 1
+ fi
+ 
+ # --- Config
+ allowunannotated=$(git config --type=bool hooks.allowunannotated)
+ allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+ denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+ allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+ allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+ 
+ # check for no description
+ projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+ case "$projectdesc" in
+ "Unnamed repository"* | "")
+ 	echo "*** Project description file hasn't been set" >&2
+ 	exit 1
+ 	;;
+ esac
+ 
+ # --- Check types
+ # if $newrev is 0000...0000, it's a commit to delete a ref.
+ zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+ if [ "$newrev" = "$zero" ]; then
+ 	newrev_type=delete
+ else
+ 	newrev_type=$(git cat-file -t $newrev)
+ fi
+ 
+ case "$refname","$newrev_type" in
+ 	refs/tags/*,commit)
+ 		# un-annotated tag
+ 		short_refname=${refname##refs/tags/}
+ 		if [ "$allowunannotated" != "true" ]; then
+ 			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+ 			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/tags/*,delete)
+ 		# delete tag
+ 		if [ "$allowdeletetag" != "true" ]; then
+ 			echo "*** Deleting a tag is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/tags/*,tag)
+ 		# annotated tag
+ 		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+ 		then
+ 			echo "*** Tag '$refname' already exists." >&2
+ 			echo "*** Modifying a tag is not allowed in this repository." >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/heads/*,commit)
+ 		# branch
+ 		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+ 			echo "*** Creating a branch is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/heads/*,delete)
+ 		# delete branch
+ 		if [ "$allowdeletebranch" != "true" ]; then
+ 			echo "*** Deleting a branch is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/remotes/*,commit)
+ 		# tracking branch
+ 		;;
+ 	refs/remotes/*,delete)
+ 		# delete tracking branch
+ 		if [ "$allowdeletebranch" != "true" ]; then
+ 			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	*)
+ 		# Anything else (is there anything else?)
+ 		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+ 		exit 1
+ 		;;
+ esac
+ 
+ # --- Finished
+ exit 0
Binary files dwm-6.2/.git/index and dwm/.git/index differ
diff -crNb dwm-6.2/.git/info/exclude dwm/.git/info/exclude
*** dwm-6.2/.git/info/exclude	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/info/exclude	2021-10-31 17:28:42.213186370 -0300
***************
*** 0 ****
--- 1,6 ----
+ # git ls-files --others --exclude-from=.git/info/exclude
+ # Lines that start with '#' are comments.
+ # For a project mostly in C, the following would be a good set of
+ # exclude patterns (uncomment them if you want to use them):
+ # *.[oa]
+ # *~
diff -crNb dwm-6.2/.git/logs/HEAD dwm/.git/logs/HEAD
*** dwm-6.2/.git/logs/HEAD	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/logs/HEAD	2021-10-31 17:28:42.214186378 -0300
***************
*** 0 ****
--- 1,4 ----
+ 0000000000000000000000000000000000000000 354a6bc6fc0945536cbaaed103a8b8f3282145bc b4sqss <basqs@tutanota.com> 1628087432 -0300	clone: from https://gitlab.com/b4sqss/dwm.git
+ 354a6bc6fc0945536cbaaed103a8b8f3282145bc 4a9a66510bb90c009842435cae1b7c6652f14c2f b4sqss <basqs@tutanota.com> 1628087653 -0300	commit: changes
+ 4a9a66510bb90c009842435cae1b7c6652f14c2f fb34d5820ad8e8402efb51a14a66802d6fa42436 b4sqss <basqs@tutanota.com> 1628088486 -0300	commit: changes
+ fb34d5820ad8e8402efb51a14a66802d6fa42436 8d206a94d9dd57ff209accfb07e2ef8563f341a8 b4sqss <basqs@tutanota.com> 1629559669 -0300	commit: returned to mpd
diff -crNb dwm-6.2/.git/logs/refs/heads/main dwm/.git/logs/refs/heads/main
*** dwm-6.2/.git/logs/refs/heads/main	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/logs/refs/heads/main	2021-10-31 17:28:42.215186385 -0300
***************
*** 0 ****
--- 1,4 ----
+ 0000000000000000000000000000000000000000 354a6bc6fc0945536cbaaed103a8b8f3282145bc b4sqss <basqs@tutanota.com> 1628087432 -0300	clone: from https://gitlab.com/b4sqss/dwm.git
+ 354a6bc6fc0945536cbaaed103a8b8f3282145bc 4a9a66510bb90c009842435cae1b7c6652f14c2f b4sqss <basqs@tutanota.com> 1628087653 -0300	commit: changes
+ 4a9a66510bb90c009842435cae1b7c6652f14c2f fb34d5820ad8e8402efb51a14a66802d6fa42436 b4sqss <basqs@tutanota.com> 1628088486 -0300	commit: changes
+ fb34d5820ad8e8402efb51a14a66802d6fa42436 8d206a94d9dd57ff209accfb07e2ef8563f341a8 b4sqss <basqs@tutanota.com> 1629559669 -0300	commit: returned to mpd
diff -crNb dwm-6.2/.git/logs/refs/remotes/origin/HEAD dwm/.git/logs/refs/remotes/origin/HEAD
*** dwm-6.2/.git/logs/refs/remotes/origin/HEAD	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/logs/refs/remotes/origin/HEAD	2021-10-31 17:28:42.216186393 -0300
***************
*** 0 ****
--- 1 ----
+ 0000000000000000000000000000000000000000 354a6bc6fc0945536cbaaed103a8b8f3282145bc b4sqss <basqs@tutanota.com> 1628087432 -0300	clone: from https://gitlab.com/b4sqss/dwm.git
diff -crNb dwm-6.2/.git/logs/refs/remotes/origin/main dwm/.git/logs/refs/remotes/origin/main
*** dwm-6.2/.git/logs/refs/remotes/origin/main	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/logs/refs/remotes/origin/main	2021-10-31 17:28:42.216186393 -0300
***************
*** 0 ****
--- 1,3 ----
+ 354a6bc6fc0945536cbaaed103a8b8f3282145bc 4a9a66510bb90c009842435cae1b7c6652f14c2f b4sqss <basqs@tutanota.com> 1628087661 -0300	update by push
+ 4a9a66510bb90c009842435cae1b7c6652f14c2f fb34d5820ad8e8402efb51a14a66802d6fa42436 b4sqss <basqs@tutanota.com> 1628088509 -0300	update by push
+ fb34d5820ad8e8402efb51a14a66802d6fa42436 8d206a94d9dd57ff209accfb07e2ef8563f341a8 b4sqss <basqs@tutanota.com> 1629559686 -0300	update by push
diff -crNb dwm-6.2/.git/objects/00/29177fe352dd82565c87f35d126aa7c9e8810d dwm/.git/objects/00/29177fe352dd82565c87f35d126aa7c9e8810d
*** dwm-6.2/.git/objects/00/29177fe352dd82565c87f35d126aa7c9e8810d	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/00/29177fe352dd82565c87f35d126aa7c9e8810d	2021-10-31 17:28:42.218186408 -0300
***************
*** 0 ****
--- 1,4 ----
+ xÍUÛnÓ@åÕùŠ©QS;¤qRú‚ÚT*PR)H		!kk¯“¥ÎÚò®!úïÌ¬¯¡×"ÉI<³{æÌøìñYœœÁÎ³§»¼œrÇo^œA$bQ’A¤‹LL¦˜!—ŠCÈ5±@Ïë<2ˆóÃ¾Ò¡HÓƒV(3¡Åš =x¹ñ`jS4B´HH:¾™Ï}ßíXË¨R+H¤ÒLY½%¹V)ç¡ŸÍvFHÍ³ˆq~v,+ÇÀŒÍ}Ifó³…æjãJ3-hÒ­Ÿ#†Äö©`.•˜ C@ ºxöÅ„`˜¤LO?¿?üğÚ{øéË^ãMCŠ	ìÖáJ¦¢Díìƒ?xRÜ¸}\KÛSå1SÊÃ†½MåŞ
+ ©+/›û¦ûòFÃÓLöaèMÂÊ¸Î±­“ÇÇÄÿ¢¤”ª€ÉŠ½ù5·ûĞ-y»°1†ÑÍûÛı¯/†ÕJÑLûÓ|Æ¤ã”e`»õt\èÁh8‚Wûrƒ8¦Ñpg×ÅF.pèm´´¡WĞ†¾A­ÜÚÚ(±P5jù îSúj£ä}GmÔı®ªj£ÑF]sUm<æñ’Ë¼K¹|~ú}~µÌçUÆy^¶<«²Ÿ–'‰ˆ…af|­¥ƒª)¿*®’àœkm ó,¢u¬Mé,Ğ“
+ >ĞÃ?qßüĞñ®³~È4£pHáÆğšs[,_×?F~rÒŞî„®KæN—˜»0Ãvå5ßY&»Y¾sxhÓ¯¤íd•“˜Ú–E¯/a‘ïÑ·ù*ÛxïK<Ì¥·‘7oàÈ‚YJÛÊ<›ñ~aB…—v»T½×„ˆäü9d·ŞKCwKp«"÷„Ø„.|a¼áË‘LgdÊtE¨GÄ"¡ŸØômHšõ%p1¥Œ³e
+ [˜¢²[·‹€šÇOƒ¿ö\šm×C7ãùİ—nr¥î[¹»yı•º¯Ìë²Ë7š¾İ7…ğÌ=4İWäÚºOş¿î+Z+ë¾Ú¸î+I†"êü£Ss±
\ No newline at end of file
Binary files dwm-6.2/.git/objects/03/04554d65d733dfd7780499ee3483cd49edbaec and dwm/.git/objects/03/04554d65d733dfd7780499ee3483cd49edbaec differ
Binary files dwm-6.2/.git/objects/04/5730127fb8b7f0fc6d019d5506082670612b8b and dwm/.git/objects/04/5730127fb8b7f0fc6d019d5506082670612b8b differ
Binary files dwm-6.2/.git/objects/07/56bd6b068ce4f8129feeb9f77c0baae2ae56fd and dwm/.git/objects/07/56bd6b068ce4f8129feeb9f77c0baae2ae56fd differ
Binary files dwm-6.2/.git/objects/07/cf0dc9f8605c1673172a9002c58beeec878917 and dwm/.git/objects/07/cf0dc9f8605c1673172a9002c58beeec878917 differ
Binary files dwm-6.2/.git/objects/13/a795a972494988c529d220f76aaea7e56268c3 and dwm/.git/objects/13/a795a972494988c529d220f76aaea7e56268c3 differ
diff -crNb dwm-6.2/.git/objects/15/a221bab342e96c1a897e66cf78ae305cea20be dwm/.git/objects/15/a221bab342e96c1a897e66cf78ae305cea20be
*** dwm-6.2/.git/objects/15/a221bab342e96c1a897e66cf78ae305cea20be	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/15/a221bab342e96c1a897e66cf78ae305cea20be	2021-10-31 17:28:42.241186581 -0300
***************
*** 0 ****
--- 1,2 ----
+ xÍ“MoÂ0†wm~…Õ‰‘ Ö´í2q˜„¸L;£4MÖˆT‰ËÄ¦ı÷…iå0Îä¿?vRWÂd2¾Éğ*%,^çË×9(m$(çA¸fçõ{ÀmFiƒ„J"×&d0ÈÉ­¶Â´•„YÀJ»¬~êJ»ä¸Uaïøó¤Y–·¨MV§„g‚¨¹‡©tX¯”—’vå†cÍÈIúV œ’‚
+ SB­€º?9„;Ì `c’î-Mcú½ĞL‡pÈ9n/±õ–o‹E4¿cÂ“¢6¸ªÛ·4Ö¯bUAJÄ[£UòmlÂFÅøMIë|äh¤WÀQ6^[T4íU‘›Æ=££¢ˆİNà|ÑQV(¸J•qY‡r8ëÀâú‡rsğ—‡x ¸<Ä6ÈêŠ9o³<€ÄÉ'¶ÿ@¬ƒõùÅ4
\ No newline at end of file
Binary files dwm-6.2/.git/objects/1c/cfddf72686e8bb9b95e4430b5a708109a62ec6 and dwm/.git/objects/1c/cfddf72686e8bb9b95e4430b5a708109a62ec6 differ
diff -crNb dwm-6.2/.git/objects/23/da6771b63a185e11e3a2ffc4b38af5773b0cc7 dwm/.git/objects/23/da6771b63a185e11e3a2ffc4b38af5773b0cc7
*** dwm-6.2/.git/objects/23/da6771b63a185e11e3a2ffc4b38af5773b0cc7	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/23/da6771b63a185e11e3a2ffc4b38af5773b0cc7	2021-10-31 17:28:42.243186596 -0300
***************
*** 0 ****
--- 1,3 ----
+ xMÌ»j1Ğ´¯6Íj	Ú`H›4Á…aqcòZid(RĞÃÆş÷ÈW7sîåÎ>Î¸|ZŞî‰pÚ¾nvûZö„6&Ôñãœøà
+ ª`Ğ³¦	Å>KF¸ç }5„ë\Gé^şQÜôfØI9ÖÂ^º@Çj§àb.A½SŒl|Â‚-ö*¿Á\íf¾P´}»…À5>
+ lÍÅI¥Ğwßåù|ÛyîÄª%‰JMwoÓÔŞ+À´…\á¹RT
\ No newline at end of file
Binary files dwm-6.2/.git/objects/23/f9814ac97f7ac3afd2ea79caca3a0e9cbde50f and dwm/.git/objects/23/f9814ac97f7ac3afd2ea79caca3a0e9cbde50f differ
Binary files dwm-6.2/.git/objects/25/09db1260cdfb1e424bebd0908505acd21abac2 and dwm/.git/objects/25/09db1260cdfb1e424bebd0908505acd21abac2 differ
Binary files dwm-6.2/.git/objects/25/16e6e893a8784b66c7bf066bc87eac2705dcb9 and dwm/.git/objects/25/16e6e893a8784b66c7bf066bc87eac2705dcb9 differ
diff -crNb dwm-6.2/.git/objects/2a/485de1730ffca107be29cfff598a9854ccc7fb dwm/.git/objects/2a/485de1730ffca107be29cfff598a9854ccc7fb
*** dwm-6.2/.git/objects/2a/485de1730ffca107be29cfff598a9854ccc7fb	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/2a/485de1730ffca107be29cfff598a9854ccc7fb	2021-10-31 17:28:42.257186701 -0300
***************
*** 0 ****
--- 1,3 ----
+ xQÁNÂ@õÚ~ÅX¢4İ@8@P"$MH= ’¦l§vuÙm¶[R¢ü»ÓĞôä^6ó2óŞ›7[©·0šŒ.XVˆ°góh5‡LH„Làº8ñ–[HT
+ RpT%BŠ6² ÏÜÈ¨Î„ÂÔc)TUÇqÏu:BqY¥w¥M…²AşğÔvzAÀ*+d{s­J<Oô]•5äÅßk‘û§ë8±î’:¶ ªİ”&²â%OTæ{¬0š³òP²4
+ %3´Ş±–(Nö´‚wŞÕ{Eß5q¯ô.ïaĞƒFÂ1h+£ Z/—SªJ‹mCHéDĞÌSËÑí üÉsêqõD¡À×YRƒx‚ÿ±*g­×çŒI¸Eİ0Z„QøòÚ}3æ½æ ?½MÃM=oê	z­7•ŠÌı›×˜„
\ No newline at end of file
diff -crNb dwm-6.2/.git/objects/2f/93b870a91bb5c2bcebeb55f8731a5ede764690 dwm/.git/objects/2f/93b870a91bb5c2bcebeb55f8731a5ede764690
*** dwm-6.2/.git/objects/2f/93b870a91bb5c2bcebeb55f8731a5ede764690	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/2f/93b870a91bb5c2bcebeb55f8731a5ede764690	2021-10-31 17:28:42.257186701 -0300
***************
*** 0 ****
--- 1,2 ----
+ x…TQOÛ0Ş+ş'ÈCótHÀ´jL°6L•ZèšiâaRå:NkÅ±#Ûñãw&mBayˆ¬Ëwß}÷İÅK©—pzñõó§ˆ9‡ÉxİÆ¤BrHµ¦‹«µª‚qe9$ÜQ!-9+­£®´€-Y&¹µ°äZ	§	gwñø~@ˆPL–	GN•ŠU˜g„Ì£_p	¥’ï¦pù—1ZqålIãfÓ²¢lê¸9ïD…ÍÚ¤4ØM;¸ÖÖ)ÚME•q£¸\.9µBß,55ÉB¨D0ŠÛnò&§B©i² «6RqgÎ“*óE5NØĞ¼nJµ@÷rœTûƒå5•²Nø±+Ëñ¼àˆ,M§É²xëpiy‡ğAË²kå£H!TÊA³+„x=œöà2Ôş`·àõp0ºöI½V¡Ş¥…¬a×@Í
+ ßÛUjy¶ÏBB†äË}4xW0Dg³›ÉõÏØ¯Îõé!5æ°¢&OxŠ•¼+Ò¨ÚÓ„œM/Mií·kz½É¨®r½ë«¢›Œ&ã±jpÛJ19iƒiá{µI"¬Ûæ™k3¯÷'šÇã»[ÿ˜åY"ÅÁïıİ_ˆPô"˜7wÃ”füå~˜G×£iTÛ„Öoí{5w^×IÕ"pŠµc¬²ÿuä{ÇµMj“tzP%Js{`)^?Û„gX=	”ÏàûADˆáê	™*—ßuï.¼Õª%Æ×¾w^oÅ¿Gã¹ïõfóèf|ï÷—BmMÛ›ÚñÈu®ør~ïúµÈ»›Û>ãôú¶.ÿÿé›ú!:øü‹Š‹³³’kRÕ¾Ô[Ú*R+BCš¼­Ó¸–ÈiĞU•ãg
\ No newline at end of file
Binary files dwm-6.2/.git/objects/34/63a1d2d806c28e231b89c665b2ba6432e30d4c and dwm/.git/objects/34/63a1d2d806c28e231b89c665b2ba6432e30d4c differ
Binary files dwm-6.2/.git/objects/3a/f4b2c43e3b1ab5bc6f073d822dc741b278d8a0 and dwm/.git/objects/3a/f4b2c43e3b1ab5bc6f073d822dc741b278d8a0 differ
Binary files dwm-6.2/.git/objects/40/01acd98f109e9ea4a9108f201982b58f7e96b9 and dwm/.git/objects/40/01acd98f109e9ea4a9108f201982b58f7e96b9 differ
diff -crNb dwm-6.2/.git/objects/40/fec5292768ad629fad760222a3750e25b14cd0 dwm/.git/objects/40/fec5292768ad629fad760222a3750e25b14cd0
*** dwm-6.2/.git/objects/40/fec5292768ad629fad760222a3750e25b14cd0	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/40/fec5292768ad629fad760222a3750e25b14cd0	2021-10-31 17:28:42.278186858 -0300
***************
*** 0 ****
--- 1,3 ----
+ xMÈ±
+ Â0Pç÷—ºh†]é ˆK¿ M^M $%yDüwªg<CÌv‡ıªUè™q»^º{ßa‘1æ›§g	/0É!Ë©2‹	±j¨–Ö!Ù8;Æ©ŠYû3ı®Ñº%Dí"›SXo
+ UL1’Ëæ¿—İÒ‹ğUXæ’°ü‘Şô[:Ó
\ No newline at end of file
Binary files dwm-6.2/.git/objects/47/8a4cd134018aed9f38564bfe77bccc96953e26 and dwm/.git/objects/47/8a4cd134018aed9f38564bfe77bccc96953e26 differ
Binary files dwm-6.2/.git/objects/47/e6fdac9b637e885a1fe1c3e7c9107d3f2b64d8 and dwm/.git/objects/47/e6fdac9b637e885a1fe1c3e7c9107d3f2b64d8 differ
Binary files dwm-6.2/.git/objects/48/3eedfdac61d2d22fa2bfdcf55b49c63ab92a21 and dwm/.git/objects/48/3eedfdac61d2d22fa2bfdcf55b49c63ab92a21 differ
Binary files dwm-6.2/.git/objects/48/5280491510ae3b1336308340911f46c324c04d and dwm/.git/objects/48/5280491510ae3b1336308340911f46c324c04d differ
Binary files dwm-6.2/.git/objects/4a/9a66510bb90c009842435cae1b7c6652f14c2f and dwm/.git/objects/4a/9a66510bb90c009842435cae1b7c6652f14c2f differ
diff -crNb dwm-6.2/.git/objects/4b/360bedd62db90f68a3a5f1d97d2ebb03d3e80b dwm/.git/objects/4b/360bedd62db90f68a3a5f1d97d2ebb03d3e80b
*** dwm-6.2/.git/objects/4b/360bedd62db90f68a3a5f1d97d2ebb03d3e80b	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/4b/360bedd62db90f68a3a5f1d97d2ebb03d3e80b	2021-10-31 17:28:42.282186888 -0300
***************
*** 0 ****
--- 1,4 ----
+ x¥•MOQ†O)òQ5jp1D;#‰„¨)4…š1Š0ÒLé@	´%Ó! W&câOpïŸhb¢Á…—ºtçÂÏ{?Êe:İèIzÏ¹Ï}Ï™™{.—ÒN½d¹îä½Êæº	Ò– {t<Ó”èMÏqœa††hşÀ$ÿî.Üêág§ùÑS¿ÈÕ×Íp$ÿ6­TNsEhÌL$Š¹Ó\ıÔ¡æX™6ıpwo«l•Ç§i¬A4ŸÍN[×æ<¹n9iÛµËM»iÇMßÂ{Ğy1%^>¢ÄÁpbt°·ï= øµv~&5¼êlRqñMÌ×úS}¹e^•yKjİÌS¨Ía/»é×QÛƒdìNƒ'ãäL»;p£9†"I½Æì8L¾ä¤IÒ^gHÈzhä¤\Í{bß4I§"j¢4“ã{ÅŞ1ƒnSMtàèMœşsÔ×uEï˜å:è:ğ§ø}æ¨¢÷Ìh¯áö:Ù…lƒ‹Á¡â|aqv¦P\œ›{œ[*.ÍÌrEßÍ­2•vƒ­Z¸!Rk^Õ÷ùT·7í{AÅ‰º¤OqüçHÚiÅ±Şi~Yqœ”³·^jıMÅQ55Ç~Â¢u²‹÷êçXëŠCÎàØOX´Îs‰Eóı‘ƒşÿtıÛ€lQ¾)q·Çwé=šŠp}^–#\÷™ìÆ‹jè•Ø‡ôşg‡şAHvÙ=²KÙAÈÛ!{½^­ú5–Ôê¡oó=5Ñ½õmÖ!Û¯7ÿ5‹à®‰şåe˜Á¶¥kÑ;~”W°·™–BÔU4¥Ğs„ú¹¤ôWŞ\ÕzÔEŸƒ¨ù¯ùç¢¦Ë?Óôó/˜cı|í3Šá2­©&ú…^ÓyÚã~Ğ±ÖÀ3'FÕ®ñ˜yV!ÿ­"]kÔû¯Á
+ qıû
+ È–—Ğ?äê|İ¿¸g#%¯^ô·òÌcòqwD{Çˆ2
+ >ÃÄ0U®EpWÅå[ê_R¥¥”A4ÿ/Îìò^
\ No newline at end of file
Binary files dwm-6.2/.git/objects/4c/4324958e7aa0c2c81943c5b087b4ed751fc2f5 and dwm/.git/objects/4c/4324958e7aa0c2c81943c5b087b4ed751fc2f5 differ
Binary files dwm-6.2/.git/objects/4f/fd506ada4d89f218b1f493fde54381ae6bcc35 and dwm/.git/objects/4f/fd506ada4d89f218b1f493fde54381ae6bcc35 differ
diff -crNb dwm-6.2/.git/objects/5c/2e252ea50579fa8b761f7390128d596514a1d8 dwm/.git/objects/5c/2e252ea50579fa8b761f7390128d596514a1d8
*** dwm-6.2/.git/objects/5c/2e252ea50579fa8b761f7390128d596514a1d8	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/5c/2e252ea50579fa8b761f7390128d596514a1d8	2021-10-31 17:28:42.284186903 -0300
***************
*** 0 ****
--- 1,4 ----
+ xUAKÃ@…½fÅcEHBIjlñ"„ĞKñ$Av³“daÙ-›ME¤ÿİVK/ÃÌ7ïÍ<iœDU=Ü”9öD¨_Ÿ·»ı6„Îy´îğåu?«`tKv$(
+ B›±@^²[m[3)ÂfJ»bxºFFË™] /Šr
+ Úg¬uvhá‘3ã„úÇ>=:­2öÍå&“D6¾WÍš±DwH{
+ ³tVÎ›ª,3DGò)¼MùEòˆ—˜•‚ƒ“1·Ål7É‹x¶&Oaò»·ºã)ş9yğÚ†.åwÅªÃá‹ßLËæÜÜÿ5«&<±Åok
\ No newline at end of file
Binary files dwm-6.2/.git/objects/64/da5cb6aba41ae184ada5a631a190696987fed0 and dwm/.git/objects/64/da5cb6aba41ae184ada5a631a190696987fed0 differ
Binary files dwm-6.2/.git/objects/68/78c6178617c304b2810aa4db6de6093a2d8a93 and dwm/.git/objects/68/78c6178617c304b2810aa4db6de6093a2d8a93 differ
Binary files dwm-6.2/.git/objects/70/724ebd4fc3831abd73acf18c92ca2bc29f56b9 and dwm/.git/objects/70/724ebd4fc3831abd73acf18c92ca2bc29f56b9 differ
diff -crNb dwm-6.2/.git/objects/71/a0c9d9a3bd3ddb4bc9ac4559cddc810f6736f8 dwm/.git/objects/71/a0c9d9a3bd3ddb4bc9ac4559cddc810f6736f8
*** dwm-6.2/.git/objects/71/a0c9d9a3bd3ddb4bc9ac4559cddc810f6736f8	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/71/a0c9d9a3bd3ddb4bc9ac4559cddc810f6736f8	2021-10-31 17:28:42.306187069 -0300
***************
*** 0 ****
--- 1,4 ----
+ xO»NÃ0e¿âT5‰ Y*]P¤¨KÅŒû&±dlË¬õßqDKiÅ€_Ÿ{^î„ê`u¿ºª
+ Ø!Bóò¼Ùî6ĞsĞ+TéÉğatĞJ‚S”¡k¹°%¹á’
+ Ïu`å¸şXÇ¸º€&[¹I£=‡½ä‘<c'yZ–•w\”cJUÒ: ck  gÙ‡â,'Ÿ$1è¼‘ĞiÃ¥ë³tÁÒ[ĞÍ¤<¯ÉşBì-Ù¾ãÉÁ:ã©İZ:Ô„$¼‡ì:Óf3|´‹ÎwÄè$´FféqË[>|§xu$
+ n_›&>c#rªl£H‡»µosµ¿ZÿçË?¡{òRü”(
\ No newline at end of file
Binary files dwm-6.2/.git/objects/72/1600269b32ebfcc73cf3b0bbcd1992dd1e35c0 and dwm/.git/objects/72/1600269b32ebfcc73cf3b0bbcd1992dd1e35c0 differ
Binary files dwm-6.2/.git/objects/74/54a8d899ad7c4f8579d6ea2254a0ca603f46bb and dwm/.git/objects/74/54a8d899ad7c4f8579d6ea2254a0ca603f46bb differ
Binary files dwm-6.2/.git/objects/79/aa1f4e8ddfd7fb79859361113c0779c574a89f and dwm/.git/objects/79/aa1f4e8ddfd7fb79859361113c0779c574a89f differ
Binary files dwm-6.2/.git/objects/7c/23c98dc23238a898bb737d3e79391334d61276 and dwm/.git/objects/7c/23c98dc23238a898bb737d3e79391334d61276 differ
Binary files dwm-6.2/.git/objects/7f/1f26cd02401beaa5f408bcb5afa9f27ada1ef0 and dwm/.git/objects/7f/1f26cd02401beaa5f408bcb5afa9f27ada1ef0 differ
Binary files dwm-6.2/.git/objects/82/a9a55119728331c9d1631c3a52945fc48c816f and dwm/.git/objects/82/a9a55119728331c9d1631c3a52945fc48c816f differ
Binary files dwm-6.2/.git/objects/85/366bf8679f191475d360fbbfbb9d7ab9ecf0de and dwm/.git/objects/85/366bf8679f191475d360fbbfbb9d7ab9ecf0de differ
Binary files dwm-6.2/.git/objects/86/fe9880a356eddb8a62626866a62cd54af8fe41 and dwm/.git/objects/86/fe9880a356eddb8a62626866a62cd54af8fe41 differ
Binary files dwm-6.2/.git/objects/8b/50ae6f2bdb0407e9753654922ce1ec701da5b7 and dwm/.git/objects/8b/50ae6f2bdb0407e9753654922ce1ec701da5b7 differ
Binary files dwm-6.2/.git/objects/8d/206a94d9dd57ff209accfb07e2ef8563f341a8 and dwm/.git/objects/8d/206a94d9dd57ff209accfb07e2ef8563f341a8 differ
diff -crNb dwm-6.2/.git/objects/8e/1f222a5178cca002120d7478e6c8f510987f98 dwm/.git/objects/8e/1f222a5178cca002120d7478e6c8f510987f98
*** dwm-6.2/.git/objects/8e/1f222a5178cca002120d7478e6c8f510987f98	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/8e/1f222a5178cca002120d7478e6c8f510987f98	2021-10-31 17:28:42.336187294 -0300
***************
*** 0 ****
--- 1,9 ----
+ xTYOÛ@î«ı+† Ç†>”¦¢R
+ UCÅB–q³ífmy×@8ş{g67 –—l2;3;ß1Id‘@gïİûWím"ÂàëQÿdØ‡\H„¼¨ -ÊI%~Ä*)RT!C©Øn»›B¥²ÎµÉ2ÌƒÑGwlA»6B£†Ëáœjs¡0ó¢H
+ UßD‘ï:k=„2¶‡“JHGqÛ®cp\z«!‘jï\Ç©©fßD8ëÀ¥½ä•:UîqbÍßu£¯9Ã‡t|àZ§BSW
+ N~ôû«g±¤¬¨sîÍj¹ÚĞ	ÃĞ§Ôwå¢ÓÕ§áçg0içD·#…¸OÈf
+ )¬‰â¢Ò|Ã
+ hSÕ)£ä«X2ãÚ,óŸÜLtjˆzädÖªÖ˜Íè$Ì0ÉE÷’	Ñâ‰Y>ìÏé<ÓW—|s~x	=8:DÇçœÉ¡‡Ï£!ÙêôÇpŞåpxÀĞÓ²-*›¿ÇÓäè¬ÿíû¼àÍ²€U°³Ù¨€g+rÏJ»PŸ¸$ôMÑ‚îLx:8·eÕnAèÃ!ÜQ+ç:®”×˜VÁÖÊ[,÷ÂkN!P^	¦€¥µÂyâ¡Œìç·¾çå²ˆéäRµÆİ·{.‹¦!‡õ÷ıçö¥B|¡ÃL&EòŒí¦_äŠÛBÍWÌ®aRç»İ}k6	ÏÏÌÌ,"QYöé|"
+ %©Ù6Q—Ö\2úîÓn®ƒ8-E`FXc4uÀ½±Ši7‘x³“ğS¼×SÉDÅcôl7»Õ$.½¼¢m¯;Î¹¿‡º#?R‘k
+ f˜
+ €•Lÿ¡dĞ´bòŒ°¬•-lAœhÏêºˆ7éc¡¦ÊDîş|æ
\ No newline at end of file
Binary files dwm-6.2/.git/objects/8f/f5477dbdc436a418291c7eaa022bff6030b51d and dwm/.git/objects/8f/f5477dbdc436a418291c7eaa022bff6030b51d differ
Binary files dwm-6.2/.git/objects/92/c252e47f61e576ccd9dbb07aa09cb90a943603 and dwm/.git/objects/92/c252e47f61e576ccd9dbb07aa09cb90a943603 differ
Binary files dwm-6.2/.git/objects/93/a875ae770bfe374d5eb080bc10dff557a3c295 and dwm/.git/objects/93/a875ae770bfe374d5eb080bc10dff557a3c295 differ
Binary files dwm-6.2/.git/objects/9d/14adb315743856c738e80e20157e2db3600a70 and dwm/.git/objects/9d/14adb315743856c738e80e20157e2db3600a70 differ
Binary files dwm-6.2/.git/objects/9e/280031d6c9d7f58914eb4e9d7a7d0bdbcd1fda and dwm/.git/objects/9e/280031d6c9d7f58914eb4e9d7a7d0bdbcd1fda differ
Binary files dwm-6.2/.git/objects/9f/aedadb9abada57d3c467c437edc449ad124a7e and dwm/.git/objects/9f/aedadb9abada57d3c467c437edc449ad124a7e differ
Binary files dwm-6.2/.git/objects/ae/da0e6281a5a321290f79d0472ff3b1f3120139 and dwm/.git/objects/ae/da0e6281a5a321290f79d0472ff3b1f3120139 differ
Binary files dwm-6.2/.git/objects/b0/f256473acb756feb47524f09d12dabd575c562 and dwm/.git/objects/b0/f256473acb756feb47524f09d12dabd575c562 differ
Binary files dwm-6.2/.git/objects/b1/c8c07853b9f74b1fce9653d0de16b7c24cd76e and dwm/.git/objects/b1/c8c07853b9f74b1fce9653d0de16b7c24cd76e differ
Binary files dwm-6.2/.git/objects/b3/5eba1cc2dbad2bde4816adaf1e8e776da9ed34 and dwm/.git/objects/b3/5eba1cc2dbad2bde4816adaf1e8e776da9ed34 differ
Binary files dwm-6.2/.git/objects/b4/ad3e293b389c10d3ec08aed65be3b78c66c578 and dwm/.git/objects/b4/ad3e293b389c10d3ec08aed65be3b78c66c578 differ
diff -crNb dwm-6.2/.git/objects/b5/e2d28e184c0a4942c3dfd7ed80d01a804ddcda dwm/.git/objects/b5/e2d28e184c0a4942c3dfd7ed80d01a804ddcda
*** dwm-6.2/.git/objects/b5/e2d28e184c0a4942c3dfd7ed80d01a804ddcda	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/b5/e2d28e184c0a4942c3dfd7ed80d01a804ddcda	2021-10-31 17:28:42.353187421 -0300
***************
*** 0 ****
--- 1,4 ----
+ x”ÍOQÀ§¤* Mš ÉÀà×k·Š1MËGY“F7Ûv›b?¶Ù]õ"	§†pôäßB¢şãƒ½›àÌî›ö¹].Lòvf~ofŞî¼÷¶ÜtÊšşbá9|^-G	`IÀkxLQì|`æa&À8ø•6ˆG¯HUÃÑ¹yò{+³)ıÄèı8#^èè'…óÓİiãğÙ¬fŒÃÒlªj<šÒü±|O›û°™ëT2^×Ë4l·m73®Õ®:­Œİö]§Ó5­ÖN`myyQ›_{»õ@Ó³"'t-—Íeõ\ö)-·ƒ'@âÓ;HìM'f&ÆSÇø¡ÄïÊ¹÷¤W¦´‘í©”DCŠz3
+ Î‡&$ã;‡<Tiª‘„1Å˜I8Š•„á×½Ì×™–<nå$\Qª†æT·”ï
+ z„ì°VÇOêv_¼€/]ÀAn¯¨€(-gé¡3s­´¾T(™ëÅâÆê¦¹YX*­šĞñ*V»å»Óök`šoUf¥Ş0kÁ¡wä M]û{ÊM¢¿Šƒù}‚(Ô¯IÌ_D‰ÖÉ4Œ§š¿¥ğ
+ ×$§:4ú"¼nË·Ê <ßu-×nZÂ·÷|UË·@”=„ëCáºĞATœV{¢íø¶À{ñ$hÆQ¶]7k®Õ²ûË]ÖĞ0‘îDôää‘‘ğy	½0–mÒ38¨·yªü–Í8–ğjZ‡OzZrÚâÑöUÎGÅªòªyÙ|s©f‡*¼şC¢Íë³ÎK–ÄJŸÿM<Íy¬ßÈ|gı“ˆæ<Æ´?Äş;{èŸÉ€è{qÿå4l£·û²¡¼O´”ËùÌãÖ¦Úiù¢ûRÓÿŒF4ŸîjtïÁùAä("ËõÉM´bó%¬÷#C#šÿ/¶9
\ No newline at end of file
Binary files dwm-6.2/.git/objects/b6/665daff2959ae9a9bd73a26149f952b112a78d and dwm/.git/objects/b6/665daff2959ae9a9bd73a26149f952b112a78d differ
Binary files dwm-6.2/.git/objects/b7/46ade203c66065bd716fdb227c9af8b086d12c and dwm/.git/objects/b7/46ade203c66065bd716fdb227c9af8b086d12c differ
Binary files dwm-6.2/.git/objects/b7/587d2c31e70a455c5fe943eb67f952beb5c0ef and dwm/.git/objects/b7/587d2c31e70a455c5fe943eb67f952beb5c0ef differ
Binary files dwm-6.2/.git/objects/b8/8a9cb4bb17879f2713ffb20e02c9497b2e1919 and dwm/.git/objects/b8/8a9cb4bb17879f2713ffb20e02c9497b2e1919 differ
Binary files dwm-6.2/.git/objects/bc/f8b0ac8a3aa01d46e9cca119ed37a9117090f9 and dwm/.git/objects/bc/f8b0ac8a3aa01d46e9cca119ed37a9117090f9 differ
diff -crNb dwm-6.2/.git/objects/c3/efae33ff37bd8b02abb08b05ca66f0e8a2b786 dwm/.git/objects/c3/efae33ff37bd8b02abb08b05ca66f0e8a2b786
*** dwm-6.2/.git/objects/c3/efae33ff37bd8b02abb08b05ca66f0e8a2b786	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/c3/efae33ff37bd8b02abb08b05ca66f0e8a2b786	2021-10-31 17:28:42.366187519 -0300
***************
*** 0 ****
--- 1,2 ----
+ xMÍjÃ0„{µbêB±q¾Åm/%‡‚É¡¡çbK«X HEZÓ?òî•MKs›ıvvfGëG´m{µ©p Bÿô¸ÛvĞÆ´şí3˜ãÄœ‚5’\$(âÁØØ Úˆã¤á.²2¾™.›-äåM³™ÙØfÊ…ŞE†œ†€J¨iñ—TŸ¸ß"[¯îDÒ¸ÇjÜ¿ô}Ù‰Ìh×‘ƒ^é8ëÑ|‘×EÒeRÃz9ØÕpËeY"…fïCpEşw¹Å3ÅÙ20îúD*"…h
+ kd¾ÔexK}Ïé¥_’œ8‹Ú%l
\ No newline at end of file
Binary files dwm-6.2/.git/objects/c4/cc86a239c47c5d09d8d746d98b1fd7c6afd86b and dwm/.git/objects/c4/cc86a239c47c5d09d8d746d98b1fd7c6afd86b differ
Binary files dwm-6.2/.git/objects/c5/c2e1b1930384dc0689e0f525712947d22eb1ab and dwm/.git/objects/c5/c2e1b1930384dc0689e0f525712947d22eb1ab differ
diff -crNb dwm-6.2/.git/objects/ca/13e79c4b9a8083db2614a0a589bb7b42f7f2bf dwm/.git/objects/ca/13e79c4b9a8083db2614a0a589bb7b42f7f2bf
*** dwm-6.2/.git/objects/ca/13e79c4b9a8083db2614a0a589bb7b42f7f2bf	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/ca/13e79c4b9a8083db2614a0a589bb7b42f7f2bf	2021-10-31 17:28:42.379187617 -0300
***************
*** 0 ****
--- 1,4 ----
+ x¥”KoÓ@Ç'¶Ú`P‘åàC@A€e‡¨%IiãH†¢„
+ –“8$j(vEé‡¨TêGáTAğI¸€¸W*3öNjûÿj»³¿y¬5»›j»W•sªªÂ»c5‹+Kp²b
+ p<±ó™‡9˜…B¥<8ÒõİŸR]ßK^É¢OÜÏ¤´áw
+ ÓßôA2ãÙÆàë!`}ÿ®ïúäáò`¨ïOyğ~¸%i¸òüW{•Lª®_Ÿ÷j»S~Ùİ/Raã³ãön«c/Êë¶³Õve­îKÙŞ®Ùvİ‘«[†İ—ÖPZ^^”³¥‡O®Éšªä;Sµœz·§ıQ±uˆmK±…Ù™Ô6â22¤·ô¯˜–>ÄËi9ş*-Ó)Ba¢&á÷q˜/Úa€ş…)AMQ¼®Mx03Á$`òsg½È¨:ÓuÎ!9ø~¯'È.á&¢.Dp5‚/Fğ¥^ŠàF‡ºåÚte”(Æ²:ZƒY2ÖŠÃ\[]}¼R1+…¢±bB»W³Úx—€ï¼¶ú]0MÇµj›f­¹i6¬V·İ:1êíÑ±¯,9QÄçp0¿MÇ‘ÆÁüAÅŸÅÁ¼L5ÿÔÇ§SæøÁ©s'ÀéL™Ë‚S}#)Î›kUAÁøs“­¾İ¶×ŞvAÁîZ T”~®)(µ^§cw1¤Ûsm_áM¯yGÙvÓlô-ìòÿJÆôöÆon‰ï«¿òcÙ¦yõ*#¨Gâi<3íÃ/ê¢àWÉ‡Â?>Q nà‚jşk¾†¹T3‡#(ŞŸêÅûóœG'Ùô>ƒú!ü[È>Îã™î'ÛCót‰}!Ø_wYJäßA;(î?³gh„ŸDÅçDçG¹œÏœ¶ßäÅşÅ|× ?çŸB{üìÈÿK}N‹€D¹¡·–ŸßßEúÆxş¾ÃØ
\ No newline at end of file
diff -crNb dwm-6.2/.git/objects/d1/7a3c09066b4266326649f2a82942e5b33fb4d7 dwm/.git/objects/d1/7a3c09066b4266326649f2a82942e5b33fb4d7
*** dwm-6.2/.git/objects/d1/7a3c09066b4266326649f2a82942e5b33fb4d7	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/d1/7a3c09066b4266326649f2a82942e5b33fb4d7	2021-10-31 17:28:42.379187617 -0300
***************
*** 0 ****
--- 1,2 ----
+ xÕ•ßkUÇÏfÓ6jº¬5âBUVH¤µ:»³"âdÓd”Å–¦¥ê0»™e×ìnâÜ›²ñEŠVK@Ğ‡şJß|(}êƒOBìc¡¢ôI!ïÌ=›ëdWÁ7Ìœ3Ÿû=÷ÇÜ3wêõz±òìszo±¶4‘ÉX†^¢ı'¡D×ìÇÕ8¬ÒQš¦ŞöŞÎƒ ×)O´â]ş¹ÀŞ<¶ê&çNpàm0;ÅÜİõv:³SŞö¯·Ñ~ewkÒİ½ó
+ pÜ‰·ó¸´{WnêŸö¾ß¼éâîşp&YtòG¯½{;ËÑow½íïâ½Ágñ@«Ş©™xd}(á—¿Å¼.¾ùÍÿpÊD%µ¥JN T©êÒœ*)è¶Òí†*E}¿¾¥CEsooş³R‹’–/X~õÂÉ¢[v*[¬”+e·R~o˜fâ;Qæİs”éç3Ç§L}Â…½|Ø´}?ŸË8q6Wx?»œû²8q5W`2Ÿ›â&h=hØşM›¨ŞQ‹“twï`Qvd¥‚sIŒ°,Šf„e)®­¿µ Î2¬Ç:`ââ\L8³d}$"ˆ¹­J‹İÁq7<ñ‰÷S†?±†Q–c	Ê³ŞOüş™½ÈìÜşÆŞÃ;cø¥1ü#æ˜§ÌO<q•«0\UNƒ¢~\ŞKÚDerjñÍETÊı¨OşríÌéùšfiieñ¼~ştmÑ§Põ6¢vO7iC5‚^“8£KA‡š]í·6»A|Ÿ¿ªÆšßh­ùÍ İÙïV÷y¢l²ÃßË×Ÿ{‰G#8ªC*ä@6<ã½‹¾È–Ö¯$8æ÷q,ú‹†£Ÿû-¾fxºŸw,~ÌÒï~°øçÇ·/ã~m8úŸ¶ø‹£/Ñÿbxz½òË<EØülÀíõæO¯÷QKo;kq{½U«{½¯YÜ^oÑÌóÁ%fïø°NµÕÕA¥£Ä·$ŠÂNàè°¯ÉYt@N])r¢u<@îrA;õn7ì±¤·®C‡Ïã§âd²Ã–ßŒ‚n(ÓøÏ¾È™Xrú¤¨2ƒ5ÍûH­Äğ¨o¼ï*_¶•ÍvËäã›@('^Áˆq§Oæ/Rãy¬•şI¾Ğg:ÿšÉOŸi2>ra._Vğ`™äŸµB™–øªae4Zö»È?Qš$OüËÜ ±hàgì"³ÒÚ·¸,-/°aå"L¯ÿuf£ö/o4Yö¹’/û7jl–ÑÇfü¼ñø†s#òïa–Ş;Ft“bû4qÃ{zı8óFåWÍü[ÃÌ$Hçÿs¿“)
\ No newline at end of file
Binary files dwm-6.2/.git/objects/d6/a9575e2c405884edabe8835a6cfb17963053f0 and dwm/.git/objects/d6/a9575e2c405884edabe8835a6cfb17963053f0 differ
Binary files dwm-6.2/.git/objects/d8/02037355f6a05a2c565883c92c9aa65dc35f5f and dwm/.git/objects/d8/02037355f6a05a2c565883c92c9aa65dc35f5f differ
Binary files dwm-6.2/.git/objects/d9/745602292e5cec80efb149b3307dac9fa391b5 and dwm/.git/objects/d9/745602292e5cec80efb149b3307dac9fa391b5 differ
Binary files dwm-6.2/.git/objects/dd/f7a15a891dbf92860e49a720dd9c1fbf8673c4 and dwm/.git/objects/dd/f7a15a891dbf92860e49a720dd9c1fbf8673c4 differ
diff -crNb dwm-6.2/.git/objects/e0/0b4786e659116b042f64a467fd50e410cb723e dwm/.git/objects/e0/0b4786e659116b042f64a467fd50e410cb723e
*** dwm-6.2/.git/objects/e0/0b4786e659116b042f64a467fd50e410cb723e	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/objects/e0/0b4786e659116b042f64a467fd50e410cb723e	2021-10-31 17:28:42.396187744 -0300
***************
*** 0 ****
--- 1 ----
+ x…OK1Å½n>ÅsEöë¶BR«¤Baé¥xR‘m6é¶IH²ˆJ¿»ÉÖ¢Åƒ·™y3ïıfİ©5&W““Qc¨÷óåj.:®¨ÒïFlZ‡Z6èeÒ24ÌÕ¢³%ò9’v}Ã0³®ªloFFÈM˜ıã²õNteB•´´­rbzùJÕvë£Òßİ6ù$Ñ~M_“èaQÍ‘s_’Hp¤§)×¸VšÉÔ¯ˆMœeüUôV™Æƒ†äÜ&Ó¸@°ô>‘a®7ËÇªòíDÁ†o˜³éºç¬ø`Š‡:Ã.pîB¦¦²Ìg˜a|5(ÿgäş<@ş	bh¬3†¶fÏ“<Ëäğ—~¿x=y';9˜xÚ İÁ˜~?·#_ˆ®l
\ No newline at end of file
Binary files dwm-6.2/.git/objects/e0/adb9f1558a4dd17cd02329d6014483117ecc05 and dwm/.git/objects/e0/adb9f1558a4dd17cd02329d6014483117ecc05 differ
Binary files dwm-6.2/.git/objects/e6/f93dd30ccff81d8edc0108d68f210cdfe501f5 and dwm/.git/objects/e6/f93dd30ccff81d8edc0108d68f210cdfe501f5 differ
Binary files dwm-6.2/.git/objects/fa/671260a1d8b85e881fd32b69d6f5f185146007 and dwm/.git/objects/fa/671260a1d8b85e881fd32b69d6f5f185146007 differ
Binary files dwm-6.2/.git/objects/fb/34d5820ad8e8402efb51a14a66802d6fa42436 and dwm/.git/objects/fb/34d5820ad8e8402efb51a14a66802d6fa42436 differ
Binary files dwm-6.2/.git/objects/fb/55df922587f98b051c46af653ba1e8f9bb1c74 and dwm/.git/objects/fb/55df922587f98b051c46af653ba1e8f9bb1c74 differ
Binary files dwm-6.2/.git/objects/pack/pack-b8909d2f0bfa09b7ef824656f5f9ac2f7e0cf174.idx and dwm/.git/objects/pack/pack-b8909d2f0bfa09b7ef824656f5f9ac2f7e0cf174.idx differ
Binary files dwm-6.2/.git/objects/pack/pack-b8909d2f0bfa09b7ef824656f5f9ac2f7e0cf174.pack and dwm/.git/objects/pack/pack-b8909d2f0bfa09b7ef824656f5f9ac2f7e0cf174.pack differ
diff -crNb dwm-6.2/.git/packed-refs dwm/.git/packed-refs
*** dwm-6.2/.git/packed-refs	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/packed-refs	2021-10-31 17:28:42.185186160 -0300
***************
*** 0 ****
--- 1,2 ----
+ # pack-refs with: peeled fully-peeled sorted 
+ 354a6bc6fc0945536cbaaed103a8b8f3282145bc refs/remotes/origin/main
diff -crNb dwm-6.2/.git/refs/heads/main dwm/.git/refs/heads/main
*** dwm-6.2/.git/refs/heads/main	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/refs/heads/main	2021-10-31 17:28:42.428187985 -0300
***************
*** 0 ****
--- 1 ----
+ 8d206a94d9dd57ff209accfb07e2ef8563f341a8
diff -crNb dwm-6.2/.git/refs/remotes/origin/HEAD dwm/.git/refs/remotes/origin/HEAD
*** dwm-6.2/.git/refs/remotes/origin/HEAD	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/refs/remotes/origin/HEAD	2021-10-31 17:28:42.429187992 -0300
***************
*** 0 ****
--- 1 ----
+ ref: refs/remotes/origin/main
diff -crNb dwm-6.2/.git/refs/remotes/origin/main dwm/.git/refs/remotes/origin/main
*** dwm-6.2/.git/refs/remotes/origin/main	1969-12-31 21:00:00.000000000 -0300
--- dwm/.git/refs/remotes/origin/main	2021-10-31 17:28:42.429187992 -0300
***************
*** 0 ****
--- 1 ----
+ 8d206a94d9dd57ff209accfb07e2ef8563f341a8
diff -crNb dwm-6.2/config.def.h dwm/config.def.h
*** dwm-6.2/config.def.h	2019-02-02 10:55:28.000000000 -0200
--- dwm/config.def.h	2021-10-31 17:28:42.086185416 -0300
***************
*** 1,21 ****
! /* See LICENSE file for copyright and license details. */
! 
! /* appearance */
  static const unsigned int borderpx  = 1;        /* border pixel of windows */
  static const unsigned int snap      = 32;       /* snap pixel */
  static const int showbar            = 1;        /* 0 means no bar */
  static const int topbar             = 1;        /* 0 means bottom bar */
! static const char *fonts[]          = { "monospace:size=10" };
! static const char dmenufont[]       = "monospace:size=10";
! static const char col_gray1[]       = "#222222";
! static const char col_gray2[]       = "#444444";
! static const char col_gray3[]       = "#bbbbbb";
! static const char col_gray4[]       = "#eeeeee";
! static const char col_cyan[]        = "#005577";
  static const char *colors[][3]      = {
  	/*               fg         bg         border   */
! 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
! 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
  };
  
  /* tagging */
--- 1,35 ----
! /* APPEARANCE */
  static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int gappx     = 10;       /* gaps between windows */
  static const unsigned int snap      = 32;       /* snap pixel */
  static const int showbar            = 1;        /* 0 means no bar */
  static const int topbar             = 1;        /* 0 means bottom bar */
! static const char *fonts[]          = { "firacode:pixelsize=12", "fontawesome:size=10"};
! static const char dmenufont[]       = "Terminus:size=10";
! static const char col_gray1[]       = "#1d2021";
! static const char col_gray2[]       = "#323232";
! static const char col_gray3[]       = "#ebdbb2";
! static const char col_gray4[]       = "#689d6a";
! static const char col_cyan[]        = "#1d2021";
  static const char *colors[][3]      = {
  	/*               fg         bg         border   */
! 	[SchemeNorm] = { col_gray3, col_gray1, col_gray1 },
! 	[SchemeSel]  = { col_gray3, col_gray2, col_gray3  },
! 	[SchemeTitle]  = { col_gray3, col_gray1,  col_gray1  },
! };
! 
! typedef struct {
!    const char *name;
!    const void *cmd;
! } Sp;
! const char *spcmd1[] = {"urxvt", "-name", "spterm", "-geometry", "120x34", NULL };
! const char *spcmd2[] = {"urxvt", "-name", "spfm", "-geometry", "144x41", "-e", "tmux", "new-session",  "-s", "spfm", "-n", "nnn", "nnn", NULL };
! const char *spcmd3[] = {"urxvt", "-name", "spmus", "-geometry", "144x41", "-e", "ncmpcpp", NULL };
! static Sp scratchpads[] = {
!    /* name          cmd  */
!    {"spterm",      spcmd1},
!    {"spranger",    spcmd2},
!    {"spmus",   spcmd3},
  };
  
  /* tagging */
***************
*** 28,34 ****
  	 */
  	/* class      instance    title       tags mask     isfloating   monitor */
  	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
! 	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
  };
  
  /* layout(s) */
--- 42,55 ----
  	 */
  	/* class      instance    title       tags mask     isfloating   monitor */
    { "Gimp",     NULL,         NULL,       0,              1,           -1 },
!   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
!   { "Xcalc",    NULL,         NULL,       0,              1,           -1 },
!   { "xcalc",    NULL,         NULL,       0,              1,           -1 },
!   { "Krita",    NULL,         NULL,       0,              1,           -1 },
!   { "krita",    NULL,         NULL,       0,              1,           -1 },
!   { NULL,       "spterm",     NULL,       SPTAG(0),       1,           -1 },
!   { NULL,       "spfm",       NULL,       SPTAG(1),       1,           -1 },
!   { NULL,       "spmus",      NULL,       SPTAG(2),       1,           -1 },
  };
  
  /* layout(s) */
***************
*** 38,89 ****
  
  static const Layout layouts[] = {
  	/* symbol     arrange function */
! 	{ "[]=",      tile },    /* first entry is default */
! 	{ "><>",      NULL },    /* no layout function means floating behavior */
! 	{ "[M]",      monocle },
  };
  
  /* key definitions */
! #define MODKEY Mod1Mask
  #define TAGKEYS(KEY,TAG) \
  	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
  	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
  	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
! 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
  
  /* helper for spawning shell commands in the pre dwm-5.0 fashion */
  #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
  
  /* commands */
  static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
! static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
  static const char *termcmd[]  = { "st", NULL };
  
  static Key keys[] = {
  	/* modifier                     key        function        argument */
  	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
! 	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
  	{ MODKEY,                       XK_b,      togglebar,      {0} },
  	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
  	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
! 	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
! 	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
  	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
  	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
! 	{ MODKEY,                       XK_Return, zoom,           {0} },
  	{ MODKEY,                       XK_Tab,    view,           {0} },
  	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
! 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
! 	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
! 	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
  	{ MODKEY,                       XK_space,  setlayout,      {0} },
! 	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
  	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
  	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
  	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
  	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
  	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
  	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
  	TAGKEYS(                        XK_1,                      0)
  	TAGKEYS(                        XK_2,                      1)
  	TAGKEYS(                        XK_3,                      2)
--- 59,133 ----
  
  static const Layout layouts[] = {
  	/* symbol     arrange function */
! 	{ "",      tile },    /* first entry is default */
! 	{ "><",      NULL },    /* no layout function means floating behavior */
! 	{ "<>",      monocle },
! 	{ "<M>",      centeredmaster },
! 	{ ">M<",      centeredfloatingmaster },
  };
  
  /* key definitions */
! #define MODKEY Mod4Mask
  #define TAGKEYS(KEY,TAG) \
  	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
  	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
  	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
! 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 0 << TAG} },
  
  /* helper for spawning shell commands in the pre dwm-5.0 fashion */
  #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
  
  /* commands */
  static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
! static const char *dmenucmd[] = { "dmenu_run", NULL };
  static const char *termcmd[]  = { "st", NULL };
  
+ #include "movestack.c"
  static Key keys[] = {
    /* modifier                     key        function        argument */
    { MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
!   /* { MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
!   { MODKEY,                       XK_z,      spawn,          {.v = screenshootcmd } },
!   { MODKEY,                       XK_o,      spawn,          {.v = browsercmd } },
!   { MODKEY,                       XK_w,      spawn,          {.v = minbrowsercmd } },
!   { MODKEY,                       XK_s,      spawn,          {.v = bookmarkscmd } },
!   { MODKEY,                       XK_a,      spawn,          {.v = emacscmd } },
!   { MODKEY|ShiftMask,             XK_d,      spawn,          {.v = mpdcmd } },
!   { MODKEY,                       XK_q,      spawn,          {.v = lockcmd } },*/
    { MODKEY,                       XK_b,      togglebar,      {0} },
    { MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
    { MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
!   { MODKEY|ShiftMask,             XK_i,      incnmaster,     {.i = +1 } },
!   { MODKEY|ShiftMask,             XK_d,      incnmaster,     {.i = -1 } },
    { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
    { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
!   { MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
!   { MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
!   { MODKEY|ControlMask,           XK_h,      setcfact,       {.f = +0.25} },
!   { MODKEY|ControlMask,           XK_l,      setcfact,       {.f = -0.25} },
!   { MODKEY|ControlMask,           XK_o,      setcfact,       {.f =  0.00} },
!   { MODKEY,                       XK_BackSpace, zoom,        {0} },
    { MODKEY,                       XK_Tab,    view,           {0} },
    { MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
!   { MODKEY|ShiftMask,             XK_t,      setlayout,      {.v = &layouts[0]} },
!   { MODKEY|ShiftMask,             XK_f,      setlayout,      {.v = &layouts[1]} },
!   { MODKEY|ShiftMask,             XK_g,      setlayout,      {.v = &layouts[2]} },
!   { MODKEY|ShiftMask,             XK_s,      setlayout,      {.v = &layouts[3]} },
!   { MODKEY|ShiftMask,             XK_a,      setlayout,      {.v = &layouts[4]} },
    { MODKEY,                       XK_space,  setlayout,      {0} },
!   { MODKEY,                       XK_t,      togglefloating, {0} },
    { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
    { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
    { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
    { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
    { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
    { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+   { MODKEY,                       XK_y,      togglescratch,  {.ui = 0 } },
+   { MODKEY,                       XK_u,      togglescratch,  {.ui = 1 } },
+   { MODKEY,                       XK_x,      togglescratch,  {.ui = 2 } },
+   { MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
+   { MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
    TAGKEYS(                        XK_1,                      0)
    TAGKEYS(                        XK_2,                      1)
    TAGKEYS(                        XK_3,                      2)
***************
*** 103,109 ****
  	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
  	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
  	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
- 	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
  	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
  	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
  	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
--- 147,152 ----
diff -crNb dwm-6.2/config.def.h.nord dwm/config.def.h.nord
*** dwm-6.2/config.def.h.nord	1969-12-31 21:00:00.000000000 -0300
--- dwm/config.def.h.nord	2021-10-31 17:28:42.086185416 -0300
***************
*** 0 ****
--- 1,158 ----
+ /* APPEARANCE */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int gappx     = 10;       /* gaps between windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 0;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "Sarasa Mono J:pixelsize=12", "fontawesome:size=10"};
+ static const char dmenufont[]       = "Terminus:size=10";
+ static const char col_gray1[]       = "#2e3440";
+ static const char col_gray2[]       = "#434c5e";
+ static const char col_gray3[]       = "#d8dee9";
+ static const char col_gray4[]       = "#8fbcbb";
+ static const char col_cyan[]        = "#2e3440";
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray1 },
+ 	[SchemeSel]  = { col_gray3, col_gray2, col_gray3  },
+ 	[SchemeTitle]  = { col_gray3, col_gray1,  col_gray1  },
+ };
+ 
+ typedef struct {
+    const char *name;
+    const void *cmd;
+ } Sp;
+ const char *spcmd1[] = {"urxvt", "-name", "spterm", "-geometry", "120x34", NULL };
+ const char *spcmd2[] = {"urxvt", "-name", "spfm", "-geometry", "144x41", "-e", "tmux", "new-session",  "-s", "spfm", "-n", "nnn", "nnn","-d", NULL };
+ const char *spcmd3[] = {"urxvt", "-name", "spmus", "-geometry", "144x41", "-e", "ncmpcpp", NULL };
+ static Sp scratchpads[] = {
+    /* name          cmd  */
+    {"spterm",      spcmd1},
+    {"spranger",    spcmd2},
+    {"spmus",   spcmd3},
+ };
+ 
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "Krita",    NULL,         NULL,       0,              1,           -1 },
+   { "krita",    NULL,         NULL,       0,              1,           -1 },
+   { NULL,       "spterm",     NULL,       SPTAG(0),       1,           -1 },
+   { NULL,       "spfm",       NULL,       SPTAG(1),       1,           -1 },
+   { NULL,       "spmus",      NULL,       SPTAG(2),       1,           -1 },
+ };
+ 
+ /* layout(s) */
+ static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "",      tile },    /* first entry is default */
+ 	{ "><",      NULL },    /* no layout function means floating behavior */
+ 	{ "<>",      monocle },
+ 	{ "<M>",      centeredmaster },
+ 	{ ">M<",      centeredfloatingmaster },
+ };
+ 
+ /* key definitions */
+ #define MODKEY Mod4Mask
+ #define TAGKEYS(KEY,TAG) \
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 0 << TAG} },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
+ #include "movestack.c"
+ static Key keys[] = {
+   /* modifier                     key        function        argument */
+   { MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+   /* { MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
+   { MODKEY,                       XK_z,      spawn,          {.v = screenshootcmd } },
+   { MODKEY,                       XK_o,      spawn,          {.v = browsercmd } },
+   { MODKEY,                       XK_w,      spawn,          {.v = minbrowsercmd } },
+   { MODKEY,                       XK_s,      spawn,          {.v = bookmarkscmd } },
+   { MODKEY,                       XK_a,      spawn,          {.v = emacscmd } },
+   { MODKEY|ShiftMask,             XK_d,      spawn,          {.v = mpdcmd } },
+   { MODKEY,                       XK_q,      spawn,          {.v = lockcmd } },*/
+   { MODKEY,                       XK_b,      togglebar,      {0} },
+   { MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+   { MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_i,      incnmaster,     {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_d,      incnmaster,     {.i = -1 } },
+   { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+   { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+   { MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
+   { MODKEY|ControlMask,           XK_h,      setcfact,       {.f = +0.25} },
+   { MODKEY|ControlMask,           XK_l,      setcfact,       {.f = -0.25} },
+   { MODKEY|ControlMask,           XK_o,      setcfact,       {.f =  0.00} },
+   { MODKEY,                       XK_BackSpace, zoom,        {0} },
+   { MODKEY,                       XK_Tab,    view,           {0} },
+   { MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+   { MODKEY|ShiftMask,             XK_t,      setlayout,      {.v = &layouts[0]} },
+   { MODKEY|ShiftMask,             XK_f,      setlayout,      {.v = &layouts[1]} },
+   { MODKEY|ShiftMask,             XK_g,      setlayout,      {.v = &layouts[2]} },
+   { MODKEY|ShiftMask,             XK_s,      setlayout,      {.v = &layouts[3]} },
+   { MODKEY|ShiftMask,             XK_a,      setlayout,      {.v = &layouts[4]} },
+   { MODKEY,                       XK_space,  setlayout,      {0} },
+   { MODKEY,                       XK_t,      togglefloating, {0} },
+   { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+   { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+   { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+   { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+   { MODKEY,                       XK_y,      togglescratch,  {.ui = 0 } },
+   { MODKEY,                       XK_u,      togglescratch,  {.ui = 1 } },
+   { MODKEY,                       XK_x,      togglescratch,  {.ui = 2 } },
+   { MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
+   { MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
+   TAGKEYS(                        XK_1,                      0)
+   TAGKEYS(                        XK_2,                      1)
+   TAGKEYS(                        XK_3,                      2)
+   TAGKEYS(                        XK_4,                      3)
+   TAGKEYS(                        XK_5,                      4)
+   TAGKEYS(                        XK_6,                      5)
+   TAGKEYS(                        XK_7,                      6)
+   TAGKEYS(                        XK_8,                      7)
+   TAGKEYS(                        XK_9,                      8)
+   { MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+ };
+ 
+ /* button definitions */
+ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+ static Button buttons[] = {
+   /* click                event mask      button          function        argument */
+   { ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+   { ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+   { ClkWinTitle,          0,              Button2,        zoom,           {0} },
+   { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+   { ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+   { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+   { ClkTagBar,            0,              Button1,        view,           {0} },
+   { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+   { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+   { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+ };
+ 
diff -crNb dwm-6.2/config.def.h.orig dwm/config.def.h.orig
*** dwm-6.2/config.def.h.orig	1969-12-31 21:00:00.000000000 -0300
--- dwm/config.def.h.orig	2021-10-31 17:28:42.094185476 -0300
***************
*** 0 ****
--- 1,155 ----
+ /* APPEARANCE */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int gappx     = 10;       /* gaps between windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "Siji:pixelsize=14", "firacode:size=10"};
+ static const char dmenufont[]       = "Terminus:size=10";
+ static const char col_gray1[]       = "#1d2021";
+ static const char col_gray2[]       = "#1d2021";
+ static const char col_gray3[]       = "#ebdbb2";
+ static const char col_gray4[]       = "#689d6a";
+ static const char col_cyan[]        = "#1d2021";
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+ 	[SchemeSel]  = { col_gray4, col_gray1, col_gray3  },
+ 	[SchemeTitle]  = { col_gray4, col_cyan,  col_cyan  },
+ };
+ 
+ typedef struct {
+    const char *name;
+    const void *cmd;
+ } Sp;
+ const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+ const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "tmux", "new-session",  "-s", "spfm", "-n", "nnn", "nnn", NULL };
+ const char *spcmd3[] = {"st", "-n", "spmus", "-g", "144x41", "-e", "ncmpcpp", NULL };
+ static Sp scratchpads[] = {
+    /* name          cmd  */
+    {"spterm",      spcmd1},
+    {"spranger",    spcmd2},
+    {"spmus",   spcmd3},
+ };
+ 
+ /* tagging */
+ static const char *tags[] = { "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" };
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "Krita",    NULL,         NULL,       0,              1,           -1 },
+   { "krita",    NULL,         NULL,       0,              1,           -1 },
+   { NULL,       "spterm",     NULL,       SPTAG(0),       1,           -1 },
+   { NULL,       "spfm",       NULL,       SPTAG(1),       1,           -1 },
+   { NULL,       "spmus",      NULL,       SPTAG(2),       1,           -1 },
+ };
+ 
+ /* layout(s) */
+ static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "î„± ",      tile },    /* first entry is default */
+ 	{ "[ ] ",      NULL },    /* no layout function means floating behavior */
+ 	{ "î„° ",      monocle },
+ 	{ "î„² ",      centeredmaster },
+ 	{ "î„² ",      centeredfloatingmaster },
+ };
+ 
+ /* key definitions */
+ #define MODKEY Mod4Mask
+ #define TAGKEYS(KEY,TAG) \
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ 
+ #include "movestack.c"
+ static Key keys[] = {
+   /* modifier                     key        function        argument */
+   { MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+   /* { MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
+   { MODKEY,                       XK_z,      spawn,          {.v = screenshootcmd } },
+   { MODKEY,                       XK_o,      spawn,          {.v = browsercmd } },
+   { MODKEY,                       XK_w,      spawn,          {.v = minbrowsercmd } },
+   { MODKEY,                       XK_s,      spawn,          {.v = bookmarkscmd } },
+   { MODKEY,                       XK_a,      spawn,          {.v = emacscmd } },
+   { MODKEY|ShiftMask,             XK_d,      spawn,          {.v = mpdcmd } },
+   { MODKEY,                       XK_q,      spawn,          {.v = lockcmd } },*/
+   { MODKEY,                       XK_b,      togglebar,      {0} },
+   { MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+   { MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_i,      incnmaster,     {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_d,      incnmaster,     {.i = -1 } },
+   { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+   { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+   { MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
+   { MODKEY,                       XK_BackSpace, zoom,        {0} },
+   { MODKEY,                       XK_Tab,    view,           {0} },
+   { MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+   { MODKEY|ShiftMask,             XK_t,      setlayout,      {.v = &layouts[0]} },
+   { MODKEY|ShiftMask,             XK_f,      setlayout,      {.v = &layouts[1]} },
+   { MODKEY|ShiftMask,             XK_g,      setlayout,      {.v = &layouts[2]} },
+   { MODKEY|ShiftMask,             XK_s,      setlayout,      {.v = &layouts[3]} },
+   { MODKEY|ShiftMask,             XK_a,      setlayout,      {.v = &layouts[4]} },
+   { MODKEY,                       XK_space,  setlayout,      {0} },
+   { MODKEY,                       XK_t,      togglefloating, {0} },
+   { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+   { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+   { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+   { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+   { MODKEY,                       XK_y,      togglescratch,  {.ui = 0 } },
+   { MODKEY,                       XK_u,      togglescratch,  {.ui = 1 } },
+   { MODKEY,                       XK_x,      togglescratch,  {.ui = 2 } },
+   { MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
+   { MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
+   TAGKEYS(                        XK_1,                      0)
+   TAGKEYS(                        XK_2,                      1)
+   TAGKEYS(                        XK_3,                      2)
+   TAGKEYS(                        XK_4,                      3)
+   TAGKEYS(                        XK_5,                      4)
+   TAGKEYS(                        XK_6,                      5)
+   TAGKEYS(                        XK_7,                      6)
+   TAGKEYS(                        XK_8,                      7)
+   TAGKEYS(                        XK_9,                      8)
+   { MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+ };
+ 
+ /* button definitions */
+ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+ static Button buttons[] = {
+   /* click                event mask      button          function        argument */
+   { ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+   { ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+   { ClkWinTitle,          0,              Button2,        zoom,           {0} },
+   { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+   { ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+   { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+   { ClkTagBar,            0,              Button1,        view,           {0} },
+   { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+   { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+   { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+ };
+ 
diff -crNb dwm-6.2/config.def.h.rej dwm/config.def.h.rej
*** dwm-6.2/config.def.h.rej	1969-12-31 21:00:00.000000000 -0300
--- dwm/config.def.h.rej	2021-10-31 17:28:42.094185476 -0300
***************
*** 0 ****
--- 1,12 ----
+ --- config.def.h	2019-02-02 15:55:28.000000000 +0300
+ +++ config.def.h	2020-02-18 03:33:58.212113667 +0300
+ @@ -70,6 +70,9 @@
+  	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+  	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+  	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ +	{ MODKEY|ShiftMask,             XK_h,      setcfact,       {.f = +0.25} },
+ +	{ MODKEY|ShiftMask,             XK_l,      setcfact,       {.f = -0.25} },
+ +	{ MODKEY|ShiftMask,             XK_o,      setcfact,       {.f =  0.00} },
+  	{ MODKEY,                       XK_Return, zoom,           {0} },
+  	{ MODKEY,                       XK_Tab,    view,           {0} },
+  	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
diff -crNb dwm-6.2/config.def.h.tokyodark dwm/config.def.h.tokyodark
*** dwm-6.2/config.def.h.tokyodark	1969-12-31 21:00:00.000000000 -0300
--- dwm/config.def.h.tokyodark	2021-10-31 17:28:42.104185552 -0300
***************
*** 0 ****
--- 1,157 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* appearance */
+ static const unsigned int borderpx  = 2;        /* border pixel of windows */
+ static const unsigned int gappx     = 10;       /* gaps between windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "terminus:size=10", "fontawesome:size=10" };
+ static const char dmenufont[]       = "terminus:size=10";
+ static const char col_gray1[]       = "#0d0d0d";
+ static const char col_gray2[]       = "#0d0d0d";
+ static const char col_gray3[]       = "#a8a8cd";
+ static const char col_gray4[]       = "#38a89d";
+ static const char col_cyan[]        = "#0d0d0d";
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+ 	[SchemeSel]  = { col_gray4, col_gray1, col_gray3  },
+ 	[SchemeTitle]  = { col_gray4, col_cyan,  col_cyan  },
+ };
+ 
+ typedef struct {
+    const char *name;
+    const void *cmd;
+ } Sp;
+ const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+ const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "tmux", "new-session",  "-s", "spfm", "-n", "nnn", "nnn", NULL };
+ /*const char *spcmd2[] = {"urxvt", "-name", "spfm", "-geometry", "144x41", "-e", "lf", NULL };*/
+ const char *spcmd3[] = {"keepassxc", NULL };
+ static Sp scratchpads[] = {
+    /* name          cmd  */
+    {"spterm",      spcmd1},
+    {"spranger",    spcmd2},
+    {"keepassxc",   spcmd3},
+ };
+ 
+ /* tagging */
+ static const char *tags[] = { "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" };
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "Krita",    NULL,         NULL,       0,              1,           -1 },
+   { "krita",    NULL,         NULL,       0,              1,           -1 },
+   { NULL,       "spterm",     NULL,       SPTAG(0),       1,           -1 },
+   { NULL,       "spfm",       NULL,       SPTAG(1),       1,           -1 },
+   { NULL,       "keepassxc",  NULL,       SPTAG(2),       1,           -1 },
+ };
+ 
+ /* layout(s) */
+ static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "[]=",      tile },    /* first entry is default */
+ 	{ "><>",      NULL },    /* no layout function means floating behavior */
+ 	{ "[M]",      monocle },
+ 	{ "|M|",      centeredmaster },
+ 	{ ">M>",      centeredfloatingmaster },
+ };
+ 
+ /* key definitions */
+ #define MODKEY Mod4Mask
+ #define TAGKEYS(KEY,TAG) \
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", NULL };
+ static const char *termcmd[]  = { "xterm", NULL };
+   
+ #include "movestack.c"
+ static Key keys[] = {
+   /* modifier                     key        function        argument */
+   { MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+   /* { MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
+   { MODKEY,                       XK_z,      spawn,          {.v = screenshootcmd } },
+   { MODKEY,                       XK_o,      spawn,          {.v = browsercmd } },
+   { MODKEY,                       XK_w,      spawn,          {.v = minbrowsercmd } },
+   { MODKEY,                       XK_s,      spawn,          {.v = bookmarkscmd } },
+   { MODKEY,                       XK_a,      spawn,          {.v = emacscmd } },
+   { MODKEY|ShiftMask,             XK_d,      spawn,          {.v = mpdcmd } },
+   { MODKEY,                       XK_q,      spawn,          {.v = lockcmd } },*/
+   { MODKEY,                       XK_b,      togglebar,      {0} },
+   { MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+   { MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_i,      incnmaster,     {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_d,      incnmaster,     {.i = -1 } },
+   { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+   { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+   { MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
+   { MODKEY,                       XK_BackSpace, zoom,        {0} },
+   { MODKEY,                       XK_Tab,    view,           {0} },
+   { MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+   { MODKEY|ShiftMask,             XK_t,      setlayout,      {.v = &layouts[0]} },
+   { MODKEY|ShiftMask,             XK_f,      setlayout,      {.v = &layouts[1]} },
+   { MODKEY|ShiftMask,             XK_g,      setlayout,      {.v = &layouts[2]} },
+   { MODKEY|ShiftMask,             XK_s,      setlayout,      {.v = &layouts[3]} },
+   { MODKEY|ShiftMask,             XK_a,      setlayout,      {.v = &layouts[4]} },
+   { MODKEY,                       XK_space,  setlayout,      {0} },
+   { MODKEY,                       XK_t,      togglefloating, {0} },
+   { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+   { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+   { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+   { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+   { MODKEY,                       XK_y,      togglescratch,  {.ui = 0 } },
+   { MODKEY,                       XK_u,      togglescratch,  {.ui = 1 } },
+   { MODKEY,                       XK_x,      togglescratch,  {.ui = 2 } },
+   { MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
+   { MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
+   TAGKEYS(                        XK_1,                      0)
+   TAGKEYS(                        XK_2,                      1)
+   TAGKEYS(                        XK_3,                      2)
+   TAGKEYS(                        XK_4,                      3)
+   TAGKEYS(                        XK_5,                      4)
+   TAGKEYS(                        XK_6,                      5)
+   TAGKEYS(                        XK_7,                      6)
+   TAGKEYS(                        XK_8,                      7)
+   TAGKEYS(                        XK_9,                      8)
+   { MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+ };
+ 
+ /* button definitions */
+ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+ static Button buttons[] = {
+   /* click                event mask      button          function        argument */
+   { ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+   { ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+   { ClkWinTitle,          0,              Button2,        zoom,           {0} },
+   { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+   { ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+   { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+   { ClkTagBar,            0,              Button1,        view,           {0} },
+   { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+   { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+   { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+ };
diff -crNb dwm-6.2/config.h dwm/config.h
*** dwm-6.2/config.h	1969-12-31 21:00:00.000000000 -0300
--- dwm/config.h	2021-12-08 18:52:33.092183113 -0300
***************
*** 0 ****
--- 1,153 ----
+ /* APPEARANCE */
+ static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ static const unsigned int gappx     = 10;       /* gaps between windows */
+ static const unsigned int snap      = 32;       /* snap pixel */
+ static const int showbar            = 1;        /* 0 means no bar */
+ static const int topbar             = 1;        /* 0 means bottom bar */
+ static const char *fonts[]          = { "jetbrains mono:pixelsize=12", "fontawesome:size=10"};
+ static const char dmenufont[]       = "jetbrains mono:size=10";
+ static const char col_gray1[]       = "#1d1f21";
+ static const char col_gray2[]       = "#f0c674";
+ static const char col_gray3[]       = "#1d1f21";
+ static const char col_gray4[]       = "#969896";
+ static const char col_cyan[]        = "#f0c674";
+ static const char *colors[][3]      = {
+ 	/*               fg         bg         border   */
+ 	[SchemeNorm] = { col_gray4, col_gray1, col_gray1 },
+ 	[SchemeSel]  = { col_gray3, col_gray2, col_cyan  },
+ 	[SchemeTitle]  = { col_gray4, col_gray1,  col_gray1  },
+ };
+ 
+ typedef struct {
+    const char *name;
+    const void *cmd;
+ } Sp;
+ const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+ const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "tmux", "new-session",  "-s", "spfm", "-n", "nnn", "nnn","-d", NULL };
+ const char *spcmd3[] = {"st", "-n", "spmus", "-g", "96x27", "-e", "cmus", NULL };
+ static Sp scratchpads[] = {
+    /* name          cmd  */
+    {"spterm",      spcmd1},
+    {"spranger",    spcmd2},
+    {"spmus",   spcmd3},
+ };
+ 
+ /* tagging */
+ static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ 
+ static const Rule rules[] = {
+ 	/* xprop(1):
+ 	 *	WM_CLASS(STRING) = instance, class
+ 	 *	WM_NAME(STRING) = title
+ 	 */
+ 	/* class      instance    title       tags mask     isfloating   monitor */
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Gimp",     NULL,         NULL,       0,              1,           -1 },
+   { "Xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "xcalc",    NULL,         NULL,       0,              1,           -1 },
+   { "Krita",    NULL,         NULL,       0,              1,           -1 },
+   { "krita",    NULL,         NULL,       0,              1,           -1 },
+   { NULL,       "spterm",     NULL,       SPTAG(0),       1,           -1 },
+   { NULL,       "spfm",       NULL,       SPTAG(1),       1,           -1 },
+   { NULL,       "spmus",      NULL,       SPTAG(2),       1,           -1 },
+ };
+ 
+ /* layout(s) */
+ static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
+ static const int nmaster     = 1;    /* number of clients in master area */
+ static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
+ 
+ static const Layout layouts[] = {
+ 	/* symbol     arrange function */
+ 	{ "ï¬¿",      tile },    /* first entry is default */
+ 	{ "ï §",      NULL },    /* no layout function means floating behavior */
+ 	{ "[]",      monocle },
+ 	{ "<M>",      centeredmaster },
+ 	{ ">M<",      centeredfloatingmaster },
+ };
+ 
+ /* key definitions */
+ #define MODKEY Mod4Mask
+ #define TAGKEYS(KEY,TAG) \
+ 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
+ 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 0 << TAG} },
+ 
+ /* helper for spawning shell commands in the pre dwm-5.0 fashion */
+ #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
+ 
+ /* commands */
+ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
+ static const char *dmenucmd[] = { "dmenu_run", NULL };
+ static const char *termcmd[]  = { "st", NULL };
+ static const char *emacscmd[]  = { "emacsclient", "-cn", NULL };
+ 
+ #include "movestack.c"
+ static Key keys[] = {
+   /* modifier                     key        function        argument */
+   { MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+   { MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
+   { MODKEY,                       XK_a,      spawn,          {.v = emacscmd } },
+   { MODKEY,                       XK_b,      togglebar,      {0} },
+   { MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
+   { MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_i,      incnmaster,     {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_d,      incnmaster,     {.i = -1 } },
+   { MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+   { MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+   { MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
+   { MODKEY|ControlMask,           XK_h,      setcfact,       {.f = +0.25} },
+   { MODKEY|ControlMask,           XK_l,      setcfact,       {.f = -0.25} },
+   { MODKEY|ControlMask,           XK_o,      setcfact,       {.f =  0.00} },
+   { MODKEY,                       XK_BackSpace, zoom,        {0} },
+   { MODKEY,                       XK_Tab,    view,           {0} },
+   { MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+   { MODKEY|ShiftMask,             XK_t,      setlayout,      {.v = &layouts[0]} },
+   { MODKEY|ShiftMask,             XK_f,      setlayout,      {.v = &layouts[1]} },
+   { MODKEY|ShiftMask,             XK_g,      setlayout,      {.v = &layouts[2]} },
+   { MODKEY|ShiftMask,             XK_s,      setlayout,      {.v = &layouts[3]} },
+   { MODKEY|ShiftMask,             XK_a,      setlayout,      {.v = &layouts[4]} },
+   { MODKEY,                       XK_space,  setlayout,      {0} },
+   { MODKEY,                       XK_t,      togglefloating, {0} },
+   { MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+   { MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+   { MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
+   { MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+   { MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+   { MODKEY,                       XK_y,      togglescratch,  {.ui = 0 } },
+   { MODKEY,                       XK_u,      togglescratch,  {.ui = 1 } },
+   { MODKEY,                       XK_x,      togglescratch,  {.ui = 2 } },
+   { MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
+   { MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
+   { MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
+   TAGKEYS(                        XK_1,                      0)
+   TAGKEYS(                        XK_2,                      1)
+   TAGKEYS(                        XK_3,                      2)
+   TAGKEYS(                        XK_4,                      3)
+   TAGKEYS(                        XK_5,                      4)
+   TAGKEYS(                        XK_6,                      5)
+   TAGKEYS(                        XK_7,                      6)
+   TAGKEYS(                        XK_8,                      7)
+   TAGKEYS(                        XK_9,                      8)
+   { MODKEY|ShiftMask,             XK_q,      quit,           {0} },
+ };
+ 
+ /* button definitions */
+ /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+ static Button buttons[] = {
+   /* click                event mask      button          function        argument */
+   { ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
+   { ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
+   { ClkWinTitle,          0,              Button2,        zoom,           {0} },
+   { ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+   { ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+   { ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+   { ClkTagBar,            0,              Button1,        view,           {0} },
+   { ClkTagBar,            0,              Button3,        toggleview,     {0} },
+   { ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+   { ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+ };
+ 
diff -crNb dwm-6.2/config.mk dwm/config.mk
*** dwm-6.2/config.mk	2019-02-02 10:55:28.000000000 -0200
--- dwm/config.mk	2021-10-31 17:28:42.107185574 -0300
***************
*** 7,14 ****
  PREFIX = /usr/local
  MANPREFIX = ${PREFIX}/share/man
  
! X11INC = /usr/X11R6/include
! X11LIB = /usr/X11R6/lib
  
  # Xinerama, comment if you don't want it
  XINERAMALIBS  = -lXinerama
--- 7,14 ----
  PREFIX = /usr/local
  MANPREFIX = ${PREFIX}/share/man
  
! X11INC = /usr/include/X11
! X11LIB = /usr/lib/X11
  
  # Xinerama, comment if you don't want it
  XINERAMALIBS  = -lXinerama
Binary files dwm-6.2/drw.o and dwm/drw.o differ
Binary files dwm-6.2/dwm and dwm/dwm differ
diff -crNb dwm-6.2/dwm.1 dwm/dwm.1
*** dwm-6.2/dwm.1	2019-02-02 10:55:28.000000000 -0200
--- dwm/dwm.1	2021-10-31 17:28:42.127185724 -0300
***************
*** 30,35 ****
--- 30,43 ----
  indicated with an empty square in the top left corner.
  .P
  dwm draws a small border around windows to indicate the focus state.
+ .P
+ On start, dwm can start additional programs that may be specified in two special
+ shell scripts (see the FILES section below), autostart_blocking.sh and
+ autostart.sh.  The former is executed first and dwm will wait for its
+ termination before starting.  The latter is executed in the background before
+ dwm enters its handler loop.
+ .P
+ Either of these files may be omitted.
  .SH OPTIONS
  .TP
  .B \-v
***************
*** 152,157 ****
--- 160,180 ----
  .TP
  .B Mod1\-Button3
  Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+ .SH FILES
+ The files containing programs to be started along with dwm are searched for in
+ the following directories:
+ .IP "1. $XDG_DATA_HOME/dwm"
+ .IP "2. $HOME/.local/share/dwm"
+ .IP "3. $HOME/.dwm"
+ .P
+ The first existing directory is scanned for any of the autostart files below.
+ .TP 15
+ autostart.sh
+ This file is started as a shell background process before dwm enters its handler
+ loop.
+ .TP 15
+ autostart_blocking.sh
+ This file is started before any autostart.sh; dwm waits for its termination.
  .SH CUSTOMIZATION
  dwm is customized by creating a custom config.h and (re)compiling the source
  code. This keeps it fast, secure and simple.
diff -crNb dwm-6.2/dwm.c dwm/dwm.c
*** dwm-6.2/dwm.c	2019-02-02 10:55:28.000000000 -0200
--- dwm/dwm.c	2021-10-31 17:28:42.143185845 -0300
***************
*** 29,34 ****
--- 29,35 ----
  #include <string.h>
  #include <unistd.h>
  #include <sys/types.h>
+ #include <sys/stat.h>
  #include <sys/wait.h>
  #include <X11/cursorfont.h>
  #include <X11/keysym.h>
***************
*** 54,65 ****
  #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
  #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
  #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
! #define TAGMASK                 ((1 << LENGTH(tags)) - 1)
  #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
  
  /* enums */
  enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
! enum { SchemeNorm, SchemeSel }; /* color schemes */
  enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
         NetWMFullscreen, NetActiveWindow, NetWMWindowType,
         NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
--- 55,69 ----
  #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
  #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
  #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
! #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
! #define TAGMASK     			((1 << NUMTAGS) - 1)
! #define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
! #define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
  #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
  
  /* enums */
  enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
! enum { SchemeNorm, SchemeSel, SchemeTitle }; /* color schemes */
  enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
         NetWMFullscreen, NetActiveWindow, NetWMWindowType,
         NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
***************
*** 87,92 ****
--- 91,97 ----
  struct Client {
  	char name[256];
  	float mina, maxa;
+ 	float cfact;
  	int x, y, w, h;
  	int oldx, oldy, oldw, oldh;
  	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
***************
*** 111,116 ****
--- 116,122 ----
  	void (*arrange)(Monitor *);
  } Layout;
  
+ typedef struct Pertag Pertag;
  struct Monitor {
  	char ltsymbol[16];
  	float mfact;
***************
*** 119,124 ****
--- 125,131 ----
  	int by;               /* bar geometry */
  	int mx, my, mw, mh;   /* screen size */
  	int wx, wy, ww, wh;   /* window area  */
+ 	int gappx;            /* gaps between windows */
  	unsigned int seltags;
  	unsigned int sellt;
  	unsigned int tagset[2];
***************
*** 130,135 ****
--- 137,143 ----
  	Monitor *next;
  	Window barwin;
  	const Layout *lt[2];
+ 	Pertag *pertag;
  };
  
  typedef struct {
***************
*** 147,152 ****
--- 155,161 ----
  static void arrange(Monitor *m);
  static void arrangemon(Monitor *m);
  static void attach(Client *c);
+ static void attachbottom(Client *c);
  static void attachstack(Client *c);
  static void buttonpress(XEvent *e);
  static void checkotherwm(void);
***************
*** 163,168 ****
--- 172,178 ----
  static Monitor *dirtomon(int dir);
  static void drawbar(Monitor *m);
  static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
  static void enternotify(XEvent *e);
  static void expose(XEvent *e);
  static void focus(Client *c);
***************
*** 193,205 ****
--- 203,218 ----
  static void resizemouse(const Arg *arg);
  static void restack(Monitor *m);
  static void run(void);
+ static void runautostart(void);
  static void scan(void);
  static int sendevent(Client *c, Atom proto);
  static void sendmon(Client *c, Monitor *m);
  static void setclientstate(Client *c, long state);
  static void setfocus(Client *c);
  static void setfullscreen(Client *c, int fullscreen);
+ static void setgaps(const Arg *arg);
  static void setlayout(const Arg *arg);
+ static void setcfact(const Arg *arg);
  static void setmfact(const Arg *arg);
  static void setup(void);
  static void seturgent(Client *c, int urg);
***************
*** 211,216 ****
--- 224,230 ----
  static void tile(Monitor *);
  static void togglebar(const Arg *arg);
  static void togglefloating(const Arg *arg);
+ static void togglescratch(const Arg *arg);
  static void toggletag(const Arg *arg);
  static void toggleview(const Arg *arg);
  static void unfocus(Client *c, int setfocus);
***************
*** 233,242 ****
  static int xerrordummy(Display *dpy, XErrorEvent *ee);
  static int xerrorstart(Display *dpy, XErrorEvent *ee);
  static void zoom(const Arg *arg);
  
  /* variables */
  static const char broken[] = "broken";
! static char stext[256];
  static int screen;
  static int sw, sh;           /* X display screen geometry width, height */
  static int bh, blw = 0;      /* bar geometry */
--- 247,262 ----
  static int xerrordummy(Display *dpy, XErrorEvent *ee);
  static int xerrorstart(Display *dpy, XErrorEvent *ee);
  static void zoom(const Arg *arg);
+ static void centeredmaster(Monitor *m);
+ static void centeredfloatingmaster(Monitor *m);
  
  /* variables */
+ static const char autostartblocksh[] = "autostart_blocking.sh";
+ static const char autostartsh[] = "autostart.sh";
  static const char broken[] = "broken";
! static const char dwmdir[] = "dwm";
! static const char localshare[] = ".local/share";
! static char stext[1024];
  static int screen;
  static int sw, sh;           /* X display screen geometry width, height */
  static int bh, blw = 0;      /* bar geometry */
***************
*** 271,276 ****
--- 291,305 ----
  /* configuration, allows nested code to access above variables */
  #include "config.h"
  
+ struct Pertag {
+ 	unsigned int curtag, prevtag; /* current and previous tag */
+ 	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+ 	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+ 	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+ 	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+ 	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+ };
+ 
  /* compile-time check if all tags fit into an unsigned int bit array. */
  struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
  
***************
*** 299,304 ****
--- 328,338 ----
  		{
  			c->isfloating = r->isfloating;
  			c->tags |= r->tags;
+ 			if ((r->tags & SPTAGMASK) && r->isfloating) {
+ 				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+ 				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+ 			}
+ 
  			for (m = mons; m && m->num != r->monitor; m = m->next);
  			if (m)
  				c->mon = m;
***************
*** 308,314 ****
  		XFree(ch.res_class);
  	if (ch.res_name)
  		XFree(ch.res_name);
! 	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
  }
  
  int
--- 342,348 ----
  		XFree(ch.res_class);
  	if (ch.res_name)
  		XFree(ch.res_name);
! 	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
  }
  
  int
***************
*** 407,412 ****
--- 441,455 ----
  }
  
  void
+ attachbottom(Client *c)
+ {
+ 	Client **tc;
+ 	c->next = NULL;
+ 	for (tc = &c->mon->clients; *tc; tc = &(*tc)->next);
+ 	*tc = c;
+ }
+ 
+ void
  attachstack(Client *c)
  {
  	c->snext = c->mon->stack;
***************
*** 416,422 ****
  void
  buttonpress(XEvent *e)
  {
! 	unsigned int i, x, click;
  	Arg arg = {0};
  	Client *c;
  	Monitor *m;
--- 459,465 ----
  void
  buttonpress(XEvent *e)
  {
! 	unsigned int i, x, click, occ = 0;
  	Arg arg = {0};
  	Client *c;
  	Monitor *m;
***************
*** 431,439 ****
  	}
  	if (ev->window == selmon->barwin) {
  		i = x = 0;
! 		do
  			x += TEXTW(tags[i]);
! 		while (ev->x >= x && ++i < LENGTH(tags));
  		if (i < LENGTH(tags)) {
  			click = ClkTagBar;
  			arg.ui = 1 << i;
--- 474,487 ----
  	}
  	if (ev->window == selmon->barwin) {
  		i = x = 0;
! 		for (c = m->clients; c; c = c->next)
! 			occ |= c->tags == 255 ? 0 : c->tags;
! 		do {
! 			/* do not reserve space for vacant tags */
! 			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
! 				continue;
  			x += TEXTW(tags[i]);
! 		} while (ev->x >= x && ++i < LENGTH(tags));
  		if (i < LENGTH(tags)) {
  			click = ClkTagBar;
  			arg.ui = 1 << i;
***************
*** 484,490 ****
  		cleanupmon(mons);
  	for (i = 0; i < CurLast; i++)
  		drw_cur_free(drw, cursor[i]);
! 	for (i = 0; i < LENGTH(colors); i++)
  		free(scheme[i]);
  	XDestroyWindow(dpy, wmcheckwin);
  	drw_free(drw);
--- 532,538 ----
  		cleanupmon(mons);
  	for (i = 0; i < CurLast; i++)
  		drw_cur_free(drw, cursor[i]);
! 	for (i = 0; i < LENGTH(colors) + 1; i++)
  		free(scheme[i]);
  	XDestroyWindow(dpy, wmcheckwin);
  	drw_free(drw);
***************
*** 631,636 ****
--- 679,685 ----
  createmon(void)
  {
  	Monitor *m;
+ 	unsigned int i;
  
  	m = ecalloc(1, sizeof(Monitor));
  	m->tagset[0] = m->tagset[1] = 1;
***************
*** 638,646 ****
--- 687,710 ----
  	m->nmaster = nmaster;
  	m->showbar = showbar;
  	m->topbar = topbar;
+ 	m->gappx = gappx;
  	m->lt[0] = &layouts[0];
  	m->lt[1] = &layouts[1 % LENGTH(layouts)];
  	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+ 	m->pertag = ecalloc(1, sizeof(Pertag));
+ 	m->pertag->curtag = m->pertag->prevtag = 1;
+ 
+ 	for (i = 0; i <= LENGTH(tags); i++) {
+ 		m->pertag->nmasters[i] = m->nmaster;
+ 		m->pertag->mfacts[i] = m->mfact;
+ 
+ 		m->pertag->ltidxs[i][0] = m->lt[0];
+ 		m->pertag->ltidxs[i][1] = m->lt[1];
+ 		m->pertag->sellts[i] = m->sellt;
+ 
+ 		m->pertag->showbars[i] = m->showbar;
+ 	}
+ 
  	return m;
  }
  
***************
*** 692,697 ****
--- 756,870 ----
  	return m;
  }
  
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 	int ret, i, w, x, len;
+ 	short isCode = 0;
+ 	char *text;
+ 	char *p;
+ 
+ 	len = strlen(stext) + 1 ;
+ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+ 		die("malloc");
+ 	p = text;
+ 	memcpy(text, stext, len);
+ 
+ 	/* compute width of the status text */
+ 	w = 0;
+ 	i = -1;
+ 	while (text[++i]) {
+ 		if (text[i] == '^') {
+ 			if (!isCode) {
+ 				isCode = 1;
+ 				text[i] = '\0';
+ 				w += TEXTW(text) - lrpad;
+ 				text[i] = '^';
+ 				if (text[++i] == 'f')
+ 					w += atoi(text + ++i);
+ 			} else {
+ 				isCode = 0;
+ 				text = text + i + 1;
+ 				i = -1;
+ 			}
+ 		}
+ 	}
+ 	if (!isCode)
+ 		w += TEXTW(text) - lrpad;
+ 	else
+ 		isCode = 0;
+ 	text = p;
+ 
+ 	w += 2; /* 1px padding on both sides */
+ 	ret = x = m->ww - w;
+ 
+ 	
+ 	drw_setscheme(drw, scheme[LENGTH(colors)]);
+ 	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ 	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+ 	drw_rect(drw, x, 0, w, bh, 1, 1);
+ 	x++;
+ 
+ 	/* process status text */
+ 	i = -1;
+ 	while (text[++i]) {
+ 		if (text[i] == '^' && !isCode) {
+ 			isCode = 1;
+ 
+ 			text[i] = '\0';
+ 			w = TEXTW(text) - lrpad;
+ 			drw_text(drw, x, 0, w, bh, 0, text, 0);
+ 
+ 			x += w;
+ 
+ 			/* process code */
+ 			while (text[++i] != '^') {
+ 				if (text[i] == 'c') {
+ 					char buf[8];
+ 					memcpy(buf, (char*)text+i+1, 7);
+ 					buf[7] = '\0';
+ 					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+ 					i += 7;
+ 				} else if (text[i] == 'b') {
+ 					char buf[8];
+ 					memcpy(buf, (char*)text+i+1, 7);
+ 					buf[7] = '\0';
+ 					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+ 					i += 7;
+ 				} else if (text[i] == 'd') {
+ 					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ 					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+ 				} else if (text[i] == 'r') {
+ 					int rx = atoi(text + ++i);
+ 					while (text[++i] != ',');
+ 					int ry = atoi(text + ++i);
+ 					while (text[++i] != ',');
+ 					int rw = atoi(text + ++i);
+ 					while (text[++i] != ',');
+ 					int rh = atoi(text + ++i);
+ 
+ 					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+ 				} else if (text[i] == 'f') {
+ 					x += atoi(text + ++i);
+ 				}
+ 			}
+ 
+ 			text = text + i + 1;
+ 			i=-1;
+ 			isCode = 0;
+ 		}
+ 	}
+ 
+ 	if (!isCode) {
+ 		w = TEXTW(text) - lrpad;
+ 		drw_text(drw, x, 0, w, bh, 0, text, 0);
+ 	}
+ 
+ 	drw_setscheme(drw, scheme[SchemeNorm]);
+ 	free(p);
+ 
+ 	return ret;
+ }
+ 
  void
  drawbar(Monitor *m)
  {
***************
*** 703,727 ****
  
  	/* draw status first so it can be overdrawn by tags later */
  	if (m == selmon) { /* status is only drawn on selected monitor */
! 		drw_setscheme(drw, scheme[SchemeNorm]);
! 		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
! 		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
  	}
  
  	for (c = m->clients; c; c = c->next) {
! 		occ |= c->tags;
  		if (c->isurgent)
  			urg |= c->tags;
  	}
  	x = 0;
  	for (i = 0; i < LENGTH(tags); i++) {
  		w = TEXTW(tags[i]);
  		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
  		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
- 		if (occ & 1 << i)
- 			drw_rect(drw, x + boxs, boxs, boxw, boxw,
- 				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
- 				urg & 1 << i);
  		x += w;
  	}
  	w = blw = TEXTW(m->ltsymbol);
--- 876,898 ----
  
  	/* draw status first so it can be overdrawn by tags later */
  	if (m == selmon) { /* status is only drawn on selected monitor */
! 		sw = m->ww - drawstatusbar(m, bh, stext);
  	}
  
  	for (c = m->clients; c; c = c->next) {
! 		occ |= c->tags == 255 ? 0 : c->tags;
  		if (c->isurgent)
  			urg |= c->tags;
  	}
  	x = 0;
  	for (i = 0; i < LENGTH(tags); i++) {
+ 		/* do not draw vacant tags */
+ 		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+ 		continue;
+ 
  		w = TEXTW(tags[i]);
  		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
  		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
  		x += w;
  	}
  	w = blw = TEXTW(m->ltsymbol);
***************
*** 730,736 ****
  
  	if ((w = m->ww - sw - x) > bh) {
  		if (m->sel) {
! 			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
  			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
  			if (m->sel->isfloating)
  				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
--- 901,907 ----
  
  	if ((w = m->ww - sw - x) > bh) {
  		if (m->sel) {
! 			drw_setscheme(drw, scheme[m == selmon ? SchemeTitle : SchemeNorm]);
  			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
  			if (m->sel->isfloating)
  				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
***************
*** 966,972 ****
  void
  incnmaster(const Arg *arg)
  {
! 	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
  	arrange(selmon);
  }
  
--- 1137,1143 ----
  void
  incnmaster(const Arg *arg)
  {
! 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
  	arrange(selmon);
  }
  
***************
*** 1029,1034 ****
--- 1200,1206 ----
  	c->w = c->oldw = wa->width;
  	c->h = c->oldh = wa->height;
  	c->oldbw = wa->border_width;
+ 	c->cfact = 1.0;
  
  	updatetitle(c);
  	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
***************
*** 1056,1068 ****
  	updatewindowtype(c);
  	updatesizehints(c);
  	updatewmhints(c);
  	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
  	grabbuttons(c, 0);
  	if (!c->isfloating)
  		c->isfloating = c->oldstate = trans != None || c->isfixed;
  	if (c->isfloating)
  		XRaiseWindow(dpy, c->win);
! 	attach(c);
  	attachstack(c);
  	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
  		(unsigned char *) &(c->win), 1);
--- 1228,1242 ----
  	updatewindowtype(c);
  	updatesizehints(c);
  	updatewmhints(c);
+ 	c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
+ 	c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
  	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
  	grabbuttons(c, 0);
  	if (!c->isfloating)
  		c->isfloating = c->oldstate = trans != None || c->isfixed;
  	if (c->isfloating)
  		XRaiseWindow(dpy, c->win);
! 	attachbottom(c);
  	attachstack(c);
  	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
  		(unsigned char *) &(c->win), 1);
***************
*** 1381,1386 ****
--- 1555,1637 ----
  }
  
  void
+ runautostart(void)
+ {
+ 	char *pathpfx;
+ 	char *path;
+ 	char *xdgdatahome;
+ 	char *home;
+ 	struct stat sb;
+ 
+ 	if ((home = getenv("HOME")) == NULL)
+ 		/* this is almost impossible */
+ 		return;
+ 
+ 	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+ 	 * otherwise use ~/.local/share/dwm as autostart script directory
+ 	 */
+ 	xdgdatahome = getenv("XDG_DATA_HOME");
+ 	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+ 		/* space for path segments, separators and nul */
+ 		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+ 
+ 		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 	} else {
+ 		/* space for path segments, separators and nul */
+ 		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+ 		                     + strlen(dwmdir) + 3);
+ 
+ 		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* check if the autostart script directory exists */
+ 	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+ 		/* the XDG conformant path does not exist or is no directory
+ 		 * so we try ~/.dwm instead
+ 		 */
+ 		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+ 		if(pathpfx_new == NULL) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 		pathpfx = pathpfx_new;
+ 
+ 		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* try the blocking script first */
+ 	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+ 	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+ 		free(path);
+ 		free(pathpfx);
+ 	}
+ 
+ 	if (access(path, X_OK) == 0)
+ 		system(path);
+ 
+ 	/* now the non-blocking script */
+ 	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+ 		free(path);
+ 		free(pathpfx);
+ 	}
+ 
+ 	if (access(path, X_OK) == 0)
+ 		system(strcat(path, " &"));
+ 
+ 	free(pathpfx);
+ 	free(path);
+ }
+ 
+ void
  scan(void)
  {
  	unsigned int i, num;
***************
*** 1417,1423 ****
  	detachstack(c);
  	c->mon = m;
  	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
! 	attach(c);
  	attachstack(c);
  	focus(NULL);
  	arrange(NULL);
--- 1668,1674 ----
  	detachstack(c);
  	c->mon = m;
  	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
! 	attachbottom(c);
  	attachstack(c);
  	focus(NULL);
  	arrange(NULL);
***************
*** 1498,1509 ****
  }
  
  void
  setlayout(const Arg *arg)
  {
  	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
! 		selmon->sellt ^= 1;
  	if (arg && arg->v)
! 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
  	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
  	if (selmon->sel)
  		arrange(selmon);
--- 1749,1770 ----
  }
  
  void
+ setgaps(const Arg *arg)
+ {
+ 	if ((arg->i == 0) || (selmon->gappx + arg->i < 0))
+ 		selmon->gappx = 0;
+ 	else
+ 		selmon->gappx += arg->i;
+ 	arrange(selmon);
+ }
+ 
+ void
  setlayout(const Arg *arg)
  {
  	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
! 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
  	if (arg && arg->v)
! 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
  	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
  	if (selmon->sel)
  		arrange(selmon);
***************
*** 1511,1516 ****
--- 1772,1794 ----
  		drawbar(selmon);
  }
  
+ void setcfact(const Arg *arg) {
+ 	float f;
+ 	Client *c;
+ 
+ 	c = selmon->sel;
+ 
+ 	if(!arg || !c || !selmon->lt[selmon->sellt]->arrange)
+ 		return;
+ 	f = arg->f + c->cfact;
+ 	if(arg->f == 0.0)
+ 		f = 1.0;
+ 	else if(f < 0.25 || f > 4.0)
+ 		return;
+ 	c->cfact = f;
+ 	arrange(selmon);
+ }
+ 
  /* arg > 1.0 will set mfact absolutely */
  void
  setmfact(const Arg *arg)
***************
*** 1522,1528 ****
  	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
  	if (f < 0.1 || f > 0.9)
  		return;
! 	selmon->mfact = f;
  	arrange(selmon);
  }
  
--- 1800,1806 ----
  	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
  	if (f < 0.1 || f > 0.9)
  		return;
! 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
  	arrange(selmon);
  }
  
***************
*** 1567,1573 ****
  	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
  	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
  	/* init appearance */
! 	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
  	for (i = 0; i < LENGTH(colors); i++)
  		scheme[i] = drw_scm_create(drw, colors[i], 3);
  	/* init bars */
--- 1845,1852 ----
  	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
  	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
  	/* init appearance */
! 	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
! 	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
  	for (i = 0; i < LENGTH(colors); i++)
  		scheme[i] = drw_scm_create(drw, colors[i], 3);
  	/* init bars */
***************
*** 1616,1621 ****
--- 1895,1904 ----
  	if (!c)
  		return;
  	if (ISVISIBLE(c)) {
+ 		if ((c->tags & SPTAGMASK) && c->isfloating) {
+ 			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+ 			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+ 		}
  		/* show clients top down */
  		XMoveWindow(dpy, c->win, c->x, c->y);
  		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
***************
*** 1674,1705 ****
  tile(Monitor *m)
  {
  	unsigned int i, n, h, mw, my, ty;
  	Client *c;
  
! 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
  	if (n == 0)
  		return;
  
  	if (n > m->nmaster)
  		mw = m->nmaster ? m->ww * m->mfact : 0;
  	else
! 		mw = m->ww;
! 	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
  		if (i < m->nmaster) {
! 			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
! 			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
! 			my += HEIGHT(c);
  		} else {
! 			h = (m->wh - ty) / (n - i);
! 			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
! 			ty += HEIGHT(c);
  		}
  }
  
  void
  togglebar(const Arg *arg)
  {
! 	selmon->showbar = !selmon->showbar;
  	updatebarpos(selmon);
  	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
  	arrange(selmon);
--- 1957,1996 ----
  tile(Monitor *m)
  {
  	unsigned int i, n, h, mw, my, ty;
+ 	float mfacts = 0, sfacts = 0;
  	Client *c;
  
! 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++) {
! 		if (n < m->nmaster)
! 			mfacts += c->cfact;
! 		else
! 			sfacts += c->cfact;
! 	}
  	if (n == 0)
  		return;
  
  	if (n > m->nmaster)
  		mw = m->nmaster ? m->ww * m->mfact : 0;
  	else
! 		mw = m->ww - m->gappx;
! 	for (i = 0, my = ty = m->gappx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
  		if (i < m->nmaster) {
! 			h = (m->wh - my) * (c->cfact / mfacts) - m->gappx;
! 			resize(c, m->wx + m->gappx, m->wy + my, mw - (2*c->bw) - m->gappx, h - (2*c->bw), 0);
! 			my += HEIGHT(c) + m->gappx;
! 			mfacts -= c->cfact;
  		} else {
! 			h = (m->wh - ty) / (n - i) - m->gappx;
! 			resize(c, m->wx + mw + m->gappx, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappx, h - (2*c->bw), 0);
! 			ty += HEIGHT(c) + m->gappx;
! 			sfacts -= c->cfact;
  		}
  }
  
  void
  togglebar(const Arg *arg)
  {
! 	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
  	updatebarpos(selmon);
  	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
  	arrange(selmon);
***************
*** 1720,1725 ****
--- 2011,2042 ----
  }
  
  void
+ togglescratch(const Arg *arg)
+ {
+ 	Client *c;
+ 	unsigned int found = 0;
+ 	unsigned int scratchtag = SPTAG(arg->ui);
+ 	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+ 
+ 	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+ 	if (found) {
+ 		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+ 		if (newtagset) {
+ 			selmon->tagset[selmon->seltags] = newtagset;
+ 			focus(NULL);
+ 			arrange(selmon);
+ 		}
+ 		if (ISVISIBLE(c)) {
+ 			focus(c);
+ 			restack(selmon);
+ 		}
+ 	} else {
+ 		selmon->tagset[selmon->seltags] |= scratchtag;
+ 		spawn(&sparg);
+ 	}
+ }
+ 
+ void
  toggletag(const Arg *arg)
  {
  	unsigned int newtags;
***************
*** 1738,1746 ****
--- 2055,2087 ----
  toggleview(const Arg *arg)
  {
  	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+ 	int i;
  
  	if (newtagset) {
  		selmon->tagset[selmon->seltags] = newtagset;
+ 
+ 		if (newtagset == ~0) {
+ 			selmon->pertag->prevtag = selmon->pertag->curtag;
+ 			selmon->pertag->curtag = 0;
+ 		}
+ 
+ 		/* test if the user did not select the same tag */
+ 		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+ 			selmon->pertag->prevtag = selmon->pertag->curtag;
+ 			for (i = 0; !(newtagset & 1 << i); i++) ;
+ 			selmon->pertag->curtag = i + 1;
+ 		}
+ 
+ 		/* apply settings for this view */
+ 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ 		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ 		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ 
+ 		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ 			togglebar(NULL);
+ 
  		focus(NULL);
  		arrange(selmon);
  	}
***************
*** 1897,1903 ****
  					m->clients = c->next;
  					detachstack(c);
  					c->mon = mons;
! 					attach(c);
  					attachstack(c);
  				}
  				if (m == selmon)
--- 2238,2244 ----
  					m->clients = c->next;
  					detachstack(c);
  					c->mon = mons;
! 					attachbottom(c);
  					attachstack(c);
  				}
  				if (m == selmon)
***************
*** 2035,2045 ****
  void
  view(const Arg *arg)
  {
  	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
  		return;
  	selmon->seltags ^= 1; /* toggle sel tagset */
! 	if (arg->ui & TAGMASK)
  		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
  	focus(NULL);
  	arrange(selmon);
  }
--- 2376,2412 ----
  void
  view(const Arg *arg)
  {
+ 	int i;
+ 	unsigned int tmptag;
+ 
  	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
  		return;
  	selmon->seltags ^= 1; /* toggle sel tagset */
! 	if (arg->ui & TAGMASK) {
  		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+ 		selmon->pertag->prevtag = selmon->pertag->curtag;
+ 
+ 		if (arg->ui == ~0)
+ 			selmon->pertag->curtag = 0;
+ 		else {
+ 			for (i = 0; !(arg->ui & 1 << i); i++) ;
+ 			selmon->pertag->curtag = i + 1;
+ 		}
+ 	} else {
+ 		tmptag = selmon->pertag->prevtag;
+ 		selmon->pertag->prevtag = selmon->pertag->curtag;
+ 		selmon->pertag->curtag = tmptag;
+ 	}
+ 
+ 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ 	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ 	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ 	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ 
+ 	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ 		togglebar(NULL);
+ 
  	focus(NULL);
  	arrange(selmon);
  }
***************
*** 2142,2149 ****
--- 2509,2620 ----
  		die("pledge");
  #endif /* __OpenBSD__ */
  	scan();
+ 	runautostart();
  	run();
  	cleanup();
  	XCloseDisplay(dpy);
  	return EXIT_SUCCESS;
  }
+ 
+ void
+ centeredmaster(Monitor *m)
+ {
+ 	unsigned int i, n, h, mw, mx, my, oty, ety, tw;
+ 	Client *c;
+ 
+ 	/* count number of clients in the selected monitor */
+ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ 	if (n == 0)
+ 		return;
+ 
+ 	/* initialize areas */
+ 	mw = m->ww;
+ 	mx = 0;
+ 	my = 0;
+ 	tw = mw;
+ 
+ 	if (n > m->nmaster) {
+ 		/* go mfact box in the center if more than nmaster clients */
+ 		mw = m->nmaster ? m->ww * m->mfact : 0;
+ 		tw = m->ww - mw;
+ 
+ 		if (n - m->nmaster > 1) {
+ 			/* only one client */
+ 			mx = (m->ww - mw) / 2;
+ 			tw = (m->ww - mw) / 2;
+ 		}
+ 	}
+ 
+ 	oty = 0;
+ 	ety = 0;
+ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ 	if (i < m->nmaster) {
+ 		/* nmaster clients are stacked vertically, in the center
+ 		 * of the screen */
+ 		h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+ 		resize(c, m->wx + mx, m->wy + my, mw - (2*c->bw),
+ 		       h - (2*c->bw), 0);
+ 		my += HEIGHT(c);
+ 	} else {
+ 		/* stack clients are stacked vertically */
+ 		if ((i - m->nmaster) % 2 ) {
+ 			h = (m->wh - ety) / ( (1 + n - i) / 2);
+ 			resize(c, m->wx, m->wy + ety, tw - (2*c->bw),
+ 			       h - (2*c->bw), 0);
+ 			ety += HEIGHT(c);
+ 		} else {
+ 			h = (m->wh - oty) / ((1 + n - i) / 2);
+ 			resize(c, m->wx + mx + mw, m->wy + oty,
+ 			       tw - (2*c->bw), h - (2*c->bw), 0);
+ 			oty += HEIGHT(c);
+ 		}
+ 	}
+ }
+ 
+ void
+ centeredfloatingmaster(Monitor *m)
+ {
+ 	unsigned int i, n, w, mh, mw, mx, mxo, my, myo, tx;
+ 	Client *c;
+ 
+ 	/* count number of clients in the selected monitor */
+ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ 	if (n == 0)
+ 		return;
+ 
+ 	/* initialize nmaster area */
+ 	if (n > m->nmaster) {
+ 		/* go mfact box in the center if more than nmaster clients */
+ 		if (m->ww > m->wh) {
+ 			mw = m->nmaster ? m->ww * m->mfact : 0;
+ 			mh = m->nmaster ? m->wh * 0.9 : 0;
+ 		} else {
+ 			mh = m->nmaster ? m->wh * m->mfact : 0;
+ 			mw = m->nmaster ? m->ww * 0.9 : 0;
+ 		}
+ 		mx = mxo = (m->ww - mw) / 2;
+ 		my = myo = (m->wh - mh) / 2;
+ 	} else {
+ 		/* go fullscreen if all clients are in the master area */
+ 		mh = m->wh;
+ 		mw = m->ww;
+ 		mx = mxo = 0;
+ 		my = myo = 0;
+ 	}
+ 
+ 	for(i = tx = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ 	if (i < m->nmaster) {
+ 		/* nmaster clients are stacked horizontally, in the center
+ 		 * of the screen */
+ 		w = (mw + mxo - mx) / (MIN(n, m->nmaster) - i);
+ 		resize(c, m->wx + mx, m->wy + my, w - (2*c->bw),
+ 		       mh - (2*c->bw), 0);
+ 		mx += WIDTH(c);
+ 	} else {
+ 		/* stack clients are stacked horizontally */
+ 		w = (m->ww - tx) / (n - i);
+ 		resize(c, m->wx + tx, m->wy, w - (2*c->bw),
+ 		       m->wh - (2*c->bw), 0);
+ 		tx += WIDTH(c);
+ 	}
+ }
diff -crNb dwm-6.2/dwm.c.orig dwm/dwm.c.orig
*** dwm-6.2/dwm.c.orig	1969-12-31 21:00:00.000000000 -0300
--- dwm/dwm.c.orig	2021-10-31 17:28:42.155185935 -0300
***************
*** 0 ****
--- 1,2592 ----
+ /* See LICENSE file for copyright and license details.
+  *
+  * dynamic window manager is designed like any other X client as well. It is
+  * driven through handling X events. In contrast to other X clients, a window
+  * manager selects for SubstructureRedirectMask on the root window, to receive
+  * events about window (dis-)appearance. Only one X connection at a time is
+  * allowed to select for this event mask.
+  *
+  * The event handlers of dwm are organized in an array which is accessed
+  * whenever a new event has been fetched. This allows event dispatching
+  * in O(1) time.
+  *
+  * Each child of the root window is called a client, except windows which have
+  * set the override_redirect flag. Clients are organized in a linked client
+  * list on each monitor, the focus history is remembered through a stack list
+  * on each monitor. Each client contains a bit array to indicate the tags of a
+  * client.
+  *
+  * Keys and tagging rules are organized as arrays and defined in config.h.
+  *
+  * To understand everything else, start reading main().
+  */
+ #include <errno.h>
+ #include <locale.h>
+ #include <signal.h>
+ #include <stdarg.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <sys/wait.h>
+ #include <X11/cursorfont.h>
+ #include <X11/keysym.h>
+ #include <X11/Xatom.h>
+ #include <X11/Xlib.h>
+ #include <X11/Xproto.h>
+ #include <X11/Xutil.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif /* XINERAMA */
+ #include <X11/Xft/Xft.h>
+ 
+ #include "drw.h"
+ #include "util.h"
+ 
+ /* macros */
+ #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
+ #define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
+ #define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
+                                * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
+ #define ISVISIBLE(C)            ((C->tags & C->mon->tagset[C->mon->seltags]))
+ #define LENGTH(X)               (sizeof X / sizeof X[0])
+ #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+ #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+ #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ #define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+ #define TAGMASK     			((1 << NUMTAGS) - 1)
+ #define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+ #define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+ #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+ 
+ /* enums */
+ enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ enum { SchemeNorm, SchemeSel, SchemeTitle }; /* color schemes */
+ enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
+ enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
+        ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+ 
+ typedef union {
+ 	int i;
+ 	unsigned int ui;
+ 	float f;
+ 	const void *v;
+ } Arg;
+ 
+ typedef struct {
+ 	unsigned int click;
+ 	unsigned int mask;
+ 	unsigned int button;
+ 	void (*func)(const Arg *arg);
+ 	const Arg arg;
+ } Button;
+ 
+ typedef struct Monitor Monitor;
+ typedef struct Client Client;
+ struct Client {
+ 	char name[256];
+ 	float mina, maxa;
+ 	int x, y, w, h;
+ 	int oldx, oldy, oldw, oldh;
+ 	int basew, baseh, incw, inch, maxw, maxh, minw, minh;
+ 	int bw, oldbw;
+ 	unsigned int tags;
+ 	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+ 	Client *next;
+ 	Client *snext;
+ 	Monitor *mon;
+ 	Window win;
+ };
+ 
+ typedef struct {
+ 	unsigned int mod;
+ 	KeySym keysym;
+ 	void (*func)(const Arg *);
+ 	const Arg arg;
+ } Key;
+ 
+ typedef struct {
+ 	const char *symbol;
+ 	void (*arrange)(Monitor *);
+ } Layout;
+ 
+ typedef struct Pertag Pertag;
+ struct Monitor {
+ 	char ltsymbol[16];
+ 	float mfact;
+ 	int nmaster;
+ 	int num;
+ 	int by;               /* bar geometry */
+ 	int mx, my, mw, mh;   /* screen size */
+ 	int wx, wy, ww, wh;   /* window area  */
+ 	int gappx;            /* gaps between windows */
+ 	unsigned int seltags;
+ 	unsigned int sellt;
+ 	unsigned int tagset[2];
+ 	int showbar;
+ 	int topbar;
+ 	Client *clients;
+ 	Client *sel;
+ 	Client *stack;
+ 	Monitor *next;
+ 	Window barwin;
+ 	const Layout *lt[2];
+ 	Pertag *pertag;
+ };
+ 
+ typedef struct {
+ 	const char *class;
+ 	const char *instance;
+ 	const char *title;
+ 	unsigned int tags;
+ 	int isfloating;
+ 	int monitor;
+ } Rule;
+ 
+ /* function declarations */
+ static void applyrules(Client *c);
+ static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+ static void arrange(Monitor *m);
+ static void arrangemon(Monitor *m);
+ static void attach(Client *c);
+ static void attachbottom(Client *c);
+ static void attachstack(Client *c);
+ static void buttonpress(XEvent *e);
+ static void checkotherwm(void);
+ static void cleanup(void);
+ static void cleanupmon(Monitor *mon);
+ static void clientmessage(XEvent *e);
+ static void configure(Client *c);
+ static void configurenotify(XEvent *e);
+ static void configurerequest(XEvent *e);
+ static Monitor *createmon(void);
+ static void destroynotify(XEvent *e);
+ static void detach(Client *c);
+ static void detachstack(Client *c);
+ static Monitor *dirtomon(int dir);
+ static void drawbar(Monitor *m);
+ static void drawbars(void);
+ static int drawstatusbar(Monitor *m, int bh, char* text);
+ static void enternotify(XEvent *e);
+ static void expose(XEvent *e);
+ static void focus(Client *c);
+ static void focusin(XEvent *e);
+ static void focusmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+ static int getrootptr(int *x, int *y);
+ static long getstate(Window w);
+ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
+ static void grabbuttons(Client *c, int focused);
+ static void grabkeys(void);
+ static void incnmaster(const Arg *arg);
+ static void keypress(XEvent *e);
+ static void killclient(const Arg *arg);
+ static void manage(Window w, XWindowAttributes *wa);
+ static void mappingnotify(XEvent *e);
+ static void maprequest(XEvent *e);
+ static void monocle(Monitor *m);
+ static void motionnotify(XEvent *e);
+ static void movemouse(const Arg *arg);
+ static Client *nexttiled(Client *c);
+ static void pop(Client *);
+ static void propertynotify(XEvent *e);
+ static void quit(const Arg *arg);
+ static Monitor *recttomon(int x, int y, int w, int h);
+ static void resize(Client *c, int x, int y, int w, int h, int interact);
+ static void resizeclient(Client *c, int x, int y, int w, int h);
+ static void resizemouse(const Arg *arg);
+ static void restack(Monitor *m);
+ static void run(void);
+ static void runautostart(void);
+ static void scan(void);
+ static int sendevent(Client *c, Atom proto);
+ static void sendmon(Client *c, Monitor *m);
+ static void setclientstate(Client *c, long state);
+ static void setfocus(Client *c);
+ static void setfullscreen(Client *c, int fullscreen);
+ static void setgaps(const Arg *arg);
+ static void setlayout(const Arg *arg);
+ static void setmfact(const Arg *arg);
+ static void setup(void);
+ static void seturgent(Client *c, int urg);
+ static void showhide(Client *c);
+ static void sigchld(int unused);
+ static void spawn(const Arg *arg);
+ static void tag(const Arg *arg);
+ static void tagmon(const Arg *arg);
+ static void tile(Monitor *);
+ static void togglebar(const Arg *arg);
+ static void togglefloating(const Arg *arg);
+ static void togglescratch(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
+ static void unfocus(Client *c, int setfocus);
+ static void unmanage(Client *c, int destroyed);
+ static void unmapnotify(XEvent *e);
+ static void updatebarpos(Monitor *m);
+ static void updatebars(void);
+ static void updateclientlist(void);
+ static int updategeom(void);
+ static void updatenumlockmask(void);
+ static void updatesizehints(Client *c);
+ static void updatestatus(void);
+ static void updatetitle(Client *c);
+ static void updatewindowtype(Client *c);
+ static void updatewmhints(Client *c);
+ static void view(const Arg *arg);
+ static Client *wintoclient(Window w);
+ static Monitor *wintomon(Window w);
+ static int xerror(Display *dpy, XErrorEvent *ee);
+ static int xerrordummy(Display *dpy, XErrorEvent *ee);
+ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+ static void zoom(const Arg *arg);
+ static void centeredmaster(Monitor *m);
+ static void centeredfloatingmaster(Monitor *m);
+ 
+ /* variables */
+ static const char autostartblocksh[] = "autostart_blocking.sh";
+ static const char autostartsh[] = "autostart.sh";
+ static const char broken[] = "broken";
+ static const char dwmdir[] = "dwm";
+ static const char localshare[] = ".local/share";
+ static char stext[1024];
+ static int screen;
+ static int sw, sh;           /* X display screen geometry width, height */
+ static int bh, blw = 0;      /* bar geometry */
+ static int lrpad;            /* sum of left and right padding for text */
+ static int (*xerrorxlib)(Display *, XErrorEvent *);
+ static unsigned int numlockmask = 0;
+ static void (*handler[LASTEvent]) (XEvent *) = {
+ 	[ButtonPress] = buttonpress,
+ 	[ClientMessage] = clientmessage,
+ 	[ConfigureRequest] = configurerequest,
+ 	[ConfigureNotify] = configurenotify,
+ 	[DestroyNotify] = destroynotify,
+ 	[EnterNotify] = enternotify,
+ 	[Expose] = expose,
+ 	[FocusIn] = focusin,
+ 	[KeyPress] = keypress,
+ 	[MappingNotify] = mappingnotify,
+ 	[MapRequest] = maprequest,
+ 	[MotionNotify] = motionnotify,
+ 	[PropertyNotify] = propertynotify,
+ 	[UnmapNotify] = unmapnotify
+ };
+ static Atom wmatom[WMLast], netatom[NetLast];
+ static int running = 1;
+ static Cur *cursor[CurLast];
+ static Clr **scheme;
+ static Display *dpy;
+ static Drw *drw;
+ static Monitor *mons, *selmon;
+ static Window root, wmcheckwin;
+ 
+ /* configuration, allows nested code to access above variables */
+ #include "config.h"
+ 
+ struct Pertag {
+ 	unsigned int curtag, prevtag; /* current and previous tag */
+ 	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+ 	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+ 	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+ 	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+ 	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+ };
+ 
+ /* compile-time check if all tags fit into an unsigned int bit array. */
+ struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+ 
+ /* function implementations */
+ void
+ applyrules(Client *c)
+ {
+ 	const char *class, *instance;
+ 	unsigned int i;
+ 	const Rule *r;
+ 	Monitor *m;
+ 	XClassHint ch = { NULL, NULL };
+ 
+ 	/* rule matching */
+ 	c->isfloating = 0;
+ 	c->tags = 0;
+ 	XGetClassHint(dpy, c->win, &ch);
+ 	class    = ch.res_class ? ch.res_class : broken;
+ 	instance = ch.res_name  ? ch.res_name  : broken;
+ 
+ 	for (i = 0; i < LENGTH(rules); i++) {
+ 		r = &rules[i];
+ 		if ((!r->title || strstr(c->name, r->title))
+ 		&& (!r->class || strstr(class, r->class))
+ 		&& (!r->instance || strstr(instance, r->instance)))
+ 		{
+ 			c->isfloating = r->isfloating;
+ 			c->tags |= r->tags;
+ 			if ((r->tags & SPTAGMASK) && r->isfloating) {
+ 				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+ 				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+ 			}
+ 
+ 			for (m = mons; m && m->num != r->monitor; m = m->next);
+ 			if (m)
+ 				c->mon = m;
+ 		}
+ 	}
+ 	if (ch.res_class)
+ 		XFree(ch.res_class);
+ 	if (ch.res_name)
+ 		XFree(ch.res_name);
+ 	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+ }
+ 
+ int
+ applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
+ {
+ 	int baseismin;
+ 	Monitor *m = c->mon;
+ 
+ 	/* set minimum possible */
+ 	*w = MAX(1, *w);
+ 	*h = MAX(1, *h);
+ 	if (interact) {
+ 		if (*x > sw)
+ 			*x = sw - WIDTH(c);
+ 		if (*y > sh)
+ 			*y = sh - HEIGHT(c);
+ 		if (*x + *w + 2 * c->bw < 0)
+ 			*x = 0;
+ 		if (*y + *h + 2 * c->bw < 0)
+ 			*y = 0;
+ 	} else {
+ 		if (*x >= m->wx + m->ww)
+ 			*x = m->wx + m->ww - WIDTH(c);
+ 		if (*y >= m->wy + m->wh)
+ 			*y = m->wy + m->wh - HEIGHT(c);
+ 		if (*x + *w + 2 * c->bw <= m->wx)
+ 			*x = m->wx;
+ 		if (*y + *h + 2 * c->bw <= m->wy)
+ 			*y = m->wy;
+ 	}
+ 	if (*h < bh)
+ 		*h = bh;
+ 	if (*w < bh)
+ 		*w = bh;
+ 	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
+ 		/* see last two sentences in ICCCM 4.1.2.3 */
+ 		baseismin = c->basew == c->minw && c->baseh == c->minh;
+ 		if (!baseismin) { /* temporarily remove base dimensions */
+ 			*w -= c->basew;
+ 			*h -= c->baseh;
+ 		}
+ 		/* adjust for aspect limits */
+ 		if (c->mina > 0 && c->maxa > 0) {
+ 			if (c->maxa < (float)*w / *h)
+ 				*w = *h * c->maxa + 0.5;
+ 			else if (c->mina < (float)*h / *w)
+ 				*h = *w * c->mina + 0.5;
+ 		}
+ 		if (baseismin) { /* increment calculation requires this */
+ 			*w -= c->basew;
+ 			*h -= c->baseh;
+ 		}
+ 		/* adjust for increment value */
+ 		if (c->incw)
+ 			*w -= *w % c->incw;
+ 		if (c->inch)
+ 			*h -= *h % c->inch;
+ 		/* restore base dimensions */
+ 		*w = MAX(*w + c->basew, c->minw);
+ 		*h = MAX(*h + c->baseh, c->minh);
+ 		if (c->maxw)
+ 			*w = MIN(*w, c->maxw);
+ 		if (c->maxh)
+ 			*h = MIN(*h, c->maxh);
+ 	}
+ 	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
+ }
+ 
+ void
+ arrange(Monitor *m)
+ {
+ 	if (m)
+ 		showhide(m->stack);
+ 	else for (m = mons; m; m = m->next)
+ 		showhide(m->stack);
+ 	if (m) {
+ 		arrangemon(m);
+ 		restack(m);
+ 	} else for (m = mons; m; m = m->next)
+ 		arrangemon(m);
+ }
+ 
+ void
+ arrangemon(Monitor *m)
+ {
+ 	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
+ 	if (m->lt[m->sellt]->arrange)
+ 		m->lt[m->sellt]->arrange(m);
+ }
+ 
+ void
+ attach(Client *c)
+ {
+ 	c->next = c->mon->clients;
+ 	c->mon->clients = c;
+ }
+ 
+ void
+ attachbottom(Client *c)
+ {
+ 	Client **tc;
+ 	c->next = NULL;
+ 	for (tc = &c->mon->clients; *tc; tc = &(*tc)->next);
+ 	*tc = c;
+ }
+ 
+ void
+ attachstack(Client *c)
+ {
+ 	c->snext = c->mon->stack;
+ 	c->mon->stack = c;
+ }
+ 
+ void
+ buttonpress(XEvent *e)
+ {
+ 	unsigned int i, x, click, occ = 0;
+ 	Arg arg = {0};
+ 	Client *c;
+ 	Monitor *m;
+ 	XButtonPressedEvent *ev = &e->xbutton;
+ 
+ 	click = ClkRootWin;
+ 	/* focus monitor if necessary */
+ 	if ((m = wintomon(ev->window)) && m != selmon) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+ 	}
+ 	if (ev->window == selmon->barwin) {
+ 		i = x = 0;
+ 		for (c = m->clients; c; c = c->next)
+ 			occ |= c->tags == 255 ? 0 : c->tags;
+ 		do {
+ 			/* do not reserve space for vacant tags */
+ 			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+ 				continue;
+ 			x += TEXTW(tags[i]);
+ 		} while (ev->x >= x && ++i < LENGTH(tags));
+ 		if (i < LENGTH(tags)) {
+ 			click = ClkTagBar;
+ 			arg.ui = 1 << i;
+ 		} else if (ev->x < x + blw)
+ 			click = ClkLtSymbol;
+ 		else if (ev->x > selmon->ww - TEXTW(stext))
+ 			click = ClkStatusText;
+ 		else
+ 			click = ClkWinTitle;
+ 	} else if ((c = wintoclient(ev->window))) {
+ 		focus(c);
+ 		restack(selmon);
+ 		XAllowEvents(dpy, ReplayPointer, CurrentTime);
+ 		click = ClkClientWin;
+ 	}
+ 	for (i = 0; i < LENGTH(buttons); i++)
+ 		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
+ 		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
+ 			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
+ }
+ 
+ void
+ checkotherwm(void)
+ {
+ 	xerrorxlib = XSetErrorHandler(xerrorstart);
+ 	/* this causes an error if some other window manager is running */
+ 	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
+ 	XSync(dpy, False);
+ 	XSetErrorHandler(xerror);
+ 	XSync(dpy, False);
+ }
+ 
+ void
+ cleanup(void)
+ {
+ 	Arg a = {.ui = ~0};
+ 	Layout foo = { "", NULL };
+ 	Monitor *m;
+ 	size_t i;
+ 
+ 	view(&a);
+ 	selmon->lt[selmon->sellt] = &foo;
+ 	for (m = mons; m; m = m->next)
+ 		while (m->stack)
+ 			unmanage(m->stack, 0);
+ 	XUngrabKey(dpy, AnyKey, AnyModifier, root);
+ 	while (mons)
+ 		cleanupmon(mons);
+ 	for (i = 0; i < CurLast; i++)
+ 		drw_cur_free(drw, cursor[i]);
+ 	for (i = 0; i < LENGTH(colors) + 1; i++)
+ 		free(scheme[i]);
+ 	XDestroyWindow(dpy, wmcheckwin);
+ 	drw_free(drw);
+ 	XSync(dpy, False);
+ 	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
+ 	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+ }
+ 
+ void
+ cleanupmon(Monitor *mon)
+ {
+ 	Monitor *m;
+ 
+ 	if (mon == mons)
+ 		mons = mons->next;
+ 	else {
+ 		for (m = mons; m && m->next != mon; m = m->next);
+ 		m->next = mon->next;
+ 	}
+ 	XUnmapWindow(dpy, mon->barwin);
+ 	XDestroyWindow(dpy, mon->barwin);
+ 	free(mon);
+ }
+ 
+ void
+ clientmessage(XEvent *e)
+ {
+ 	XClientMessageEvent *cme = &e->xclient;
+ 	Client *c = wintoclient(cme->window);
+ 
+ 	if (!c)
+ 		return;
+ 	if (cme->message_type == netatom[NetWMState]) {
+ 		if (cme->data.l[1] == netatom[NetWMFullscreen]
+ 		|| cme->data.l[2] == netatom[NetWMFullscreen])
+ 			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+ 				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
+ 	} else if (cme->message_type == netatom[NetActiveWindow]) {
+ 		if (c != selmon->sel && !c->isurgent)
+ 			seturgent(c, 1);
+ 	}
+ }
+ 
+ void
+ configure(Client *c)
+ {
+ 	XConfigureEvent ce;
+ 
+ 	ce.type = ConfigureNotify;
+ 	ce.display = dpy;
+ 	ce.event = c->win;
+ 	ce.window = c->win;
+ 	ce.x = c->x;
+ 	ce.y = c->y;
+ 	ce.width = c->w;
+ 	ce.height = c->h;
+ 	ce.border_width = c->bw;
+ 	ce.above = None;
+ 	ce.override_redirect = False;
+ 	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
+ }
+ 
+ void
+ configurenotify(XEvent *e)
+ {
+ 	Monitor *m;
+ 	Client *c;
+ 	XConfigureEvent *ev = &e->xconfigure;
+ 	int dirty;
+ 
+ 	/* TODO: updategeom handling sucks, needs to be simplified */
+ 	if (ev->window == root) {
+ 		dirty = (sw != ev->width || sh != ev->height);
+ 		sw = ev->width;
+ 		sh = ev->height;
+ 		if (updategeom() || dirty) {
+ 			drw_resize(drw, sw, bh);
+ 			updatebars();
+ 			for (m = mons; m; m = m->next) {
+ 				for (c = m->clients; c; c = c->next)
+ 					if (c->isfullscreen)
+ 						resizeclient(c, m->mx, m->my, m->mw, m->mh);
+ 				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+ 			}
+ 			focus(NULL);
+ 			arrange(NULL);
+ 		}
+ 	}
+ }
+ 
+ void
+ configurerequest(XEvent *e)
+ {
+ 	Client *c;
+ 	Monitor *m;
+ 	XConfigureRequestEvent *ev = &e->xconfigurerequest;
+ 	XWindowChanges wc;
+ 
+ 	if ((c = wintoclient(ev->window))) {
+ 		if (ev->value_mask & CWBorderWidth)
+ 			c->bw = ev->border_width;
+ 		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
+ 			m = c->mon;
+ 			if (ev->value_mask & CWX) {
+ 				c->oldx = c->x;
+ 				c->x = m->mx + ev->x;
+ 			}
+ 			if (ev->value_mask & CWY) {
+ 				c->oldy = c->y;
+ 				c->y = m->my + ev->y;
+ 			}
+ 			if (ev->value_mask & CWWidth) {
+ 				c->oldw = c->w;
+ 				c->w = ev->width;
+ 			}
+ 			if (ev->value_mask & CWHeight) {
+ 				c->oldh = c->h;
+ 				c->h = ev->height;
+ 			}
+ 			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
+ 				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
+ 			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
+ 				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
+ 			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
+ 				configure(c);
+ 			if (ISVISIBLE(c))
+ 				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+ 		} else
+ 			configure(c);
+ 	} else {
+ 		wc.x = ev->x;
+ 		wc.y = ev->y;
+ 		wc.width = ev->width;
+ 		wc.height = ev->height;
+ 		wc.border_width = ev->border_width;
+ 		wc.sibling = ev->above;
+ 		wc.stack_mode = ev->detail;
+ 		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
+ 	}
+ 	XSync(dpy, False);
+ }
+ 
+ Monitor *
+ createmon(void)
+ {
+ 	Monitor *m;
+ 	unsigned int i;
+ 
+ 	m = ecalloc(1, sizeof(Monitor));
+ 	m->tagset[0] = m->tagset[1] = 1;
+ 	m->mfact = mfact;
+ 	m->nmaster = nmaster;
+ 	m->showbar = showbar;
+ 	m->topbar = topbar;
+ 	m->gappx = gappx;
+ 	m->lt[0] = &layouts[0];
+ 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+ 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+ 	m->pertag = ecalloc(1, sizeof(Pertag));
+ 	m->pertag->curtag = m->pertag->prevtag = 1;
+ 
+ 	for (i = 0; i <= LENGTH(tags); i++) {
+ 		m->pertag->nmasters[i] = m->nmaster;
+ 		m->pertag->mfacts[i] = m->mfact;
+ 
+ 		m->pertag->ltidxs[i][0] = m->lt[0];
+ 		m->pertag->ltidxs[i][1] = m->lt[1];
+ 		m->pertag->sellts[i] = m->sellt;
+ 
+ 		m->pertag->showbars[i] = m->showbar;
+ 	}
+ 
+ 	return m;
+ }
+ 
+ void
+ destroynotify(XEvent *e)
+ {
+ 	Client *c;
+ 	XDestroyWindowEvent *ev = &e->xdestroywindow;
+ 
+ 	if ((c = wintoclient(ev->window)))
+ 		unmanage(c, 1);
+ }
+ 
+ void
+ detach(Client *c)
+ {
+ 	Client **tc;
+ 
+ 	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
+ 	*tc = c->next;
+ }
+ 
+ void
+ detachstack(Client *c)
+ {
+ 	Client **tc, *t;
+ 
+ 	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
+ 	*tc = c->snext;
+ 
+ 	if (c == c->mon->sel) {
+ 		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
+ 		c->mon->sel = t;
+ 	}
+ }
+ 
+ Monitor *
+ dirtomon(int dir)
+ {
+ 	Monitor *m = NULL;
+ 
+ 	if (dir > 0) {
+ 		if (!(m = selmon->next))
+ 			m = mons;
+ 	} else if (selmon == mons)
+ 		for (m = mons; m->next; m = m->next);
+ 	else
+ 		for (m = mons; m->next != selmon; m = m->next);
+ 	return m;
+ }
+ 
+ int
+ drawstatusbar(Monitor *m, int bh, char* stext) {
+ 	int ret, i, w, x, len;
+ 	short isCode = 0;
+ 	char *text;
+ 	char *p;
+ 
+ 	len = strlen(stext) + 1 ;
+ 	if (!(text = (char*) malloc(sizeof(char)*len)))
+ 		die("malloc");
+ 	p = text;
+ 	memcpy(text, stext, len);
+ 
+ 	/* compute width of the status text */
+ 	w = 0;
+ 	i = -1;
+ 	while (text[++i]) {
+ 		if (text[i] == '^') {
+ 			if (!isCode) {
+ 				isCode = 1;
+ 				text[i] = '\0';
+ 				w += TEXTW(text) - lrpad;
+ 				text[i] = '^';
+ 				if (text[++i] == 'f')
+ 					w += atoi(text + ++i);
+ 			} else {
+ 				isCode = 0;
+ 				text = text + i + 1;
+ 				i = -1;
+ 			}
+ 		}
+ 	}
+ 	if (!isCode)
+ 		w += TEXTW(text) - lrpad;
+ 	else
+ 		isCode = 0;
+ 	text = p;
+ 
+ 	w += 2; /* 1px padding on both sides */
+ 	ret = x = m->ww - w;
+ 
+ 	
+ 	drw_setscheme(drw, scheme[LENGTH(colors)]);
+ 	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ 	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+ 	drw_rect(drw, x, 0, w, bh, 1, 1);
+ 	x++;
+ 
+ 	/* process status text */
+ 	i = -1;
+ 	while (text[++i]) {
+ 		if (text[i] == '^' && !isCode) {
+ 			isCode = 1;
+ 
+ 			text[i] = '\0';
+ 			w = TEXTW(text) - lrpad;
+ 			drw_text(drw, x, 0, w, bh, 0, text, 0);
+ 
+ 			x += w;
+ 
+ 			/* process code */
+ 			while (text[++i] != '^') {
+ 				if (text[i] == 'c') {
+ 					char buf[8];
+ 					memcpy(buf, (char*)text+i+1, 7);
+ 					buf[7] = '\0';
+ 					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+ 					i += 7;
+ 				} else if (text[i] == 'b') {
+ 					char buf[8];
+ 					memcpy(buf, (char*)text+i+1, 7);
+ 					buf[7] = '\0';
+ 					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+ 					i += 7;
+ 				} else if (text[i] == 'd') {
+ 					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ 					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+ 				} else if (text[i] == 'r') {
+ 					int rx = atoi(text + ++i);
+ 					while (text[++i] != ',');
+ 					int ry = atoi(text + ++i);
+ 					while (text[++i] != ',');
+ 					int rw = atoi(text + ++i);
+ 					while (text[++i] != ',');
+ 					int rh = atoi(text + ++i);
+ 
+ 					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+ 				} else if (text[i] == 'f') {
+ 					x += atoi(text + ++i);
+ 				}
+ 			}
+ 
+ 			text = text + i + 1;
+ 			i=-1;
+ 			isCode = 0;
+ 		}
+ 	}
+ 
+ 	if (!isCode) {
+ 		w = TEXTW(text) - lrpad;
+ 		drw_text(drw, x, 0, w, bh, 0, text, 0);
+ 	}
+ 
+ 	drw_setscheme(drw, scheme[SchemeNorm]);
+ 	free(p);
+ 
+ 	return ret;
+ }
+ 
+ void
+ drawbar(Monitor *m)
+ {
+ 	int x, w, sw = 0;
+ 	int boxs = drw->fonts->h / 9;
+ 	int boxw = drw->fonts->h / 6 + 2;
+ 	unsigned int i, occ = 0, urg = 0;
+ 	Client *c;
+ 
+ 	/* draw status first so it can be overdrawn by tags later */
+ 	if (m == selmon) { /* status is only drawn on selected monitor */
+ 		sw = m->ww - drawstatusbar(m, bh, stext);
+ 	}
+ 
+ 	for (c = m->clients; c; c = c->next) {
+ 		occ |= c->tags == 255 ? 0 : c->tags;
+ 		if (c->isurgent)
+ 			urg |= c->tags;
+ 	}
+ 	x = 0;
+ 	for (i = 0; i < LENGTH(tags); i++) {
+ 		/* do not draw vacant tags */
+ 		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+ 		continue;
+ 
+ 		w = TEXTW(tags[i]);
+ 		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+ 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+ 		x += w;
+ 	}
+ 	w = blw = TEXTW(m->ltsymbol);
+ 	drw_setscheme(drw, scheme[SchemeNorm]);
+ 	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0);
+ 
+ 	if ((w = m->ww - sw - x) > bh) {
+ 		if (m->sel) {
+ 			drw_setscheme(drw, scheme[m == selmon ? SchemeTitle : SchemeNorm]);
+ 			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+ 			if (m->sel->isfloating)
+ 				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+ 		} else {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_rect(drw, x, 0, w, bh, 1, 1);
+ 		}
+ 	}
+ 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+ }
+ 
+ void
+ drawbars(void)
+ {
+ 	Monitor *m;
+ 
+ 	for (m = mons; m; m = m->next)
+ 		drawbar(m);
+ }
+ 
+ void
+ enternotify(XEvent *e)
+ {
+ 	Client *c;
+ 	Monitor *m;
+ 	XCrossingEvent *ev = &e->xcrossing;
+ 
+ 	if ((ev->mode != NotifyNormal || ev->detail == NotifyInferior) && ev->window != root)
+ 		return;
+ 	c = wintoclient(ev->window);
+ 	m = c ? c->mon : wintomon(ev->window);
+ 	if (m != selmon) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 	} else if (!c || c == selmon->sel)
+ 		return;
+ 	focus(c);
+ }
+ 
+ void
+ expose(XEvent *e)
+ {
+ 	Monitor *m;
+ 	XExposeEvent *ev = &e->xexpose;
+ 
+ 	if (ev->count == 0 && (m = wintomon(ev->window)))
+ 		drawbar(m);
+ }
+ 
+ void
+ focus(Client *c)
+ {
+ 	if (!c || !ISVISIBLE(c))
+ 		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
+ 	if (selmon->sel && selmon->sel != c)
+ 		unfocus(selmon->sel, 0);
+ 	if (c) {
+ 		if (c->mon != selmon)
+ 			selmon = c->mon;
+ 		if (c->isurgent)
+ 			seturgent(c, 0);
+ 		detachstack(c);
+ 		attachstack(c);
+ 		grabbuttons(c, 1);
+ 		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+ 		setfocus(c);
+ 	} else {
+ 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+ 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+ 	}
+ 	selmon->sel = c;
+ 	drawbars();
+ }
+ 
+ /* there are some broken focus acquiring clients needing extra handling */
+ void
+ focusin(XEvent *e)
+ {
+ 	XFocusChangeEvent *ev = &e->xfocus;
+ 
+ 	if (selmon->sel && ev->window != selmon->sel->win)
+ 		setfocus(selmon->sel);
+ }
+ 
+ void
+ focusmon(const Arg *arg)
+ {
+ 	Monitor *m;
+ 
+ 	if (!mons->next)
+ 		return;
+ 	if ((m = dirtomon(arg->i)) == selmon)
+ 		return;
+ 	unfocus(selmon->sel, 0);
+ 	selmon = m;
+ 	focus(NULL);
+ }
+ 
+ void
+ focusstack(const Arg *arg)
+ {
+ 	Client *c = NULL, *i;
+ 
+ 	if (!selmon->sel)
+ 		return;
+ 	if (arg->i > 0) {
+ 		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
+ 		if (!c)
+ 			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
+ 	} else {
+ 		for (i = selmon->clients; i != selmon->sel; i = i->next)
+ 			if (ISVISIBLE(i))
+ 				c = i;
+ 		if (!c)
+ 			for (; i; i = i->next)
+ 				if (ISVISIBLE(i))
+ 					c = i;
+ 	}
+ 	if (c) {
+ 		focus(c);
+ 		restack(selmon);
+ 	}
+ }
+ 
+ Atom
+ getatomprop(Client *c, Atom prop)
+ {
+ 	int di;
+ 	unsigned long dl;
+ 	unsigned char *p = NULL;
+ 	Atom da, atom = None;
+ 
+ 	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
+ 		&da, &di, &dl, &dl, &p) == Success && p) {
+ 		atom = *(Atom *)p;
+ 		XFree(p);
+ 	}
+ 	return atom;
+ }
+ 
+ int
+ getrootptr(int *x, int *y)
+ {
+ 	int di;
+ 	unsigned int dui;
+ 	Window dummy;
+ 
+ 	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
+ }
+ 
+ long
+ getstate(Window w)
+ {
+ 	int format;
+ 	long result = -1;
+ 	unsigned char *p = NULL;
+ 	unsigned long n, extra;
+ 	Atom real;
+ 
+ 	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
+ 		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
+ 		return -1;
+ 	if (n != 0)
+ 		result = *p;
+ 	XFree(p);
+ 	return result;
+ }
+ 
+ int
+ gettextprop(Window w, Atom atom, char *text, unsigned int size)
+ {
+ 	char **list = NULL;
+ 	int n;
+ 	XTextProperty name;
+ 
+ 	if (!text || size == 0)
+ 		return 0;
+ 	text[0] = '\0';
+ 	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
+ 		return 0;
+ 	if (name.encoding == XA_STRING)
+ 		strncpy(text, (char *)name.value, size - 1);
+ 	else {
+ 		if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
+ 			strncpy(text, *list, size - 1);
+ 			XFreeStringList(list);
+ 		}
+ 	}
+ 	text[size - 1] = '\0';
+ 	XFree(name.value);
+ 	return 1;
+ }
+ 
+ void
+ grabbuttons(Client *c, int focused)
+ {
+ 	updatenumlockmask();
+ 	{
+ 		unsigned int i, j;
+ 		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+ 		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+ 		if (!focused)
+ 			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
+ 				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
+ 		for (i = 0; i < LENGTH(buttons); i++)
+ 			if (buttons[i].click == ClkClientWin)
+ 				for (j = 0; j < LENGTH(modifiers); j++)
+ 					XGrabButton(dpy, buttons[i].button,
+ 						buttons[i].mask | modifiers[j],
+ 						c->win, False, BUTTONMASK,
+ 						GrabModeAsync, GrabModeSync, None, None);
+ 	}
+ }
+ 
+ void
+ grabkeys(void)
+ {
+ 	updatenumlockmask();
+ 	{
+ 		unsigned int i, j;
+ 		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
+ 		KeyCode code;
+ 
+ 		XUngrabKey(dpy, AnyKey, AnyModifier, root);
+ 		for (i = 0; i < LENGTH(keys); i++)
+ 			if ((code = XKeysymToKeycode(dpy, keys[i].keysym)))
+ 				for (j = 0; j < LENGTH(modifiers); j++)
+ 					XGrabKey(dpy, code, keys[i].mod | modifiers[j], root,
+ 						True, GrabModeAsync, GrabModeAsync);
+ 	}
+ }
+ 
+ void
+ incnmaster(const Arg *arg)
+ {
+ 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+ 	arrange(selmon);
+ }
+ 
+ #ifdef XINERAMA
+ static int
+ isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
+ {
+ 	while (n--)
+ 		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
+ 		&& unique[n].width == info->width && unique[n].height == info->height)
+ 			return 0;
+ 	return 1;
+ }
+ #endif /* XINERAMA */
+ 
+ void
+ keypress(XEvent *e)
+ {
+ 	unsigned int i;
+ 	KeySym keysym;
+ 	XKeyEvent *ev;
+ 
+ 	ev = &e->xkey;
+ 	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
+ 	for (i = 0; i < LENGTH(keys); i++)
+ 		if (keysym == keys[i].keysym
+ 		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
+ 		&& keys[i].func)
+ 			keys[i].func(&(keys[i].arg));
+ }
+ 
+ void
+ killclient(const Arg *arg)
+ {
+ 	if (!selmon->sel)
+ 		return;
+ 	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
+ 		XGrabServer(dpy);
+ 		XSetErrorHandler(xerrordummy);
+ 		XSetCloseDownMode(dpy, DestroyAll);
+ 		XKillClient(dpy, selmon->sel->win);
+ 		XSync(dpy, False);
+ 		XSetErrorHandler(xerror);
+ 		XUngrabServer(dpy);
+ 	}
+ }
+ 
+ void
+ manage(Window w, XWindowAttributes *wa)
+ {
+ 	Client *c, *t = NULL;
+ 	Window trans = None;
+ 	XWindowChanges wc;
+ 
+ 	c = ecalloc(1, sizeof(Client));
+ 	c->win = w;
+ 	/* geometry */
+ 	c->x = c->oldx = wa->x;
+ 	c->y = c->oldy = wa->y;
+ 	c->w = c->oldw = wa->width;
+ 	c->h = c->oldh = wa->height;
+ 	c->oldbw = wa->border_width;
+ 
+ 	updatetitle(c);
+ 	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+ 		c->mon = t->mon;
+ 		c->tags = t->tags;
+ 	} else {
+ 		c->mon = selmon;
+ 		applyrules(c);
+ 	}
+ 
+ 	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
+ 		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
+ 	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
+ 		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
+ 	c->x = MAX(c->x, c->mon->mx);
+ 	/* only fix client y-offset, if the client center might cover the bar */
+ 	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
+ 		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
+ 	c->bw = borderpx;
+ 
+ 	wc.border_width = c->bw;
+ 	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
+ 	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+ 	configure(c); /* propagates border_width, if size doesn't change */
+ 	updatewindowtype(c);
+ 	updatesizehints(c);
+ 	updatewmhints(c);
+ 	c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
+ 	c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
+ 	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+ 	grabbuttons(c, 0);
+ 	if (!c->isfloating)
+ 		c->isfloating = c->oldstate = trans != None || c->isfixed;
+ 	if (c->isfloating)
+ 		XRaiseWindow(dpy, c->win);
+ 	attachbottom(c);
+ 	attachstack(c);
+ 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+ 		(unsigned char *) &(c->win), 1);
+ 	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
+ 	setclientstate(c, NormalState);
+ 	if (c->mon == selmon)
+ 		unfocus(selmon->sel, 0);
+ 	c->mon->sel = c;
+ 	arrange(c->mon);
+ 	XMapWindow(dpy, c->win);
+ 	focus(NULL);
+ }
+ 
+ void
+ mappingnotify(XEvent *e)
+ {
+ 	XMappingEvent *ev = &e->xmapping;
+ 
+ 	XRefreshKeyboardMapping(ev);
+ 	if (ev->request == MappingKeyboard)
+ 		grabkeys();
+ }
+ 
+ void
+ maprequest(XEvent *e)
+ {
+ 	static XWindowAttributes wa;
+ 	XMapRequestEvent *ev = &e->xmaprequest;
+ 
+ 	if (!XGetWindowAttributes(dpy, ev->window, &wa))
+ 		return;
+ 	if (wa.override_redirect)
+ 		return;
+ 	if (!wintoclient(ev->window))
+ 		manage(ev->window, &wa);
+ }
+ 
+ void
+ monocle(Monitor *m)
+ {
+ 	unsigned int n = 0;
+ 	Client *c;
+ 
+ 	for (c = m->clients; c; c = c->next)
+ 		if (ISVISIBLE(c))
+ 			n++;
+ 	if (n > 0) /* override layout symbol */
+ 		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
+ 	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
+ 		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+ }
+ 
+ void
+ motionnotify(XEvent *e)
+ {
+ 	static Monitor *mon = NULL;
+ 	Monitor *m;
+ 	XMotionEvent *ev = &e->xmotion;
+ 
+ 	if (ev->window != root)
+ 		return;
+ 	if ((m = recttomon(ev->x_root, ev->y_root, 1, 1)) != mon && mon) {
+ 		unfocus(selmon->sel, 1);
+ 		selmon = m;
+ 		focus(NULL);
+ 	}
+ 	mon = m;
+ }
+ 
+ void
+ movemouse(const Arg *arg)
+ {
+ 	int x, y, ocx, ocy, nx, ny;
+ 	Client *c;
+ 	Monitor *m;
+ 	XEvent ev;
+ 	Time lasttime = 0;
+ 
+ 	if (!(c = selmon->sel))
+ 		return;
+ 	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+ 		return;
+ 	restack(selmon);
+ 	ocx = c->x;
+ 	ocy = c->y;
+ 	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+ 		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
+ 		return;
+ 	if (!getrootptr(&x, &y))
+ 		return;
+ 	do {
+ 		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+ 		switch(ev.type) {
+ 		case ConfigureRequest:
+ 		case Expose:
+ 		case MapRequest:
+ 			handler[ev.type](&ev);
+ 			break;
+ 		case MotionNotify:
+ 			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+ 				continue;
+ 			lasttime = ev.xmotion.time;
+ 
+ 			nx = ocx + (ev.xmotion.x - x);
+ 			ny = ocy + (ev.xmotion.y - y);
+ 			if (abs(selmon->wx - nx) < snap)
+ 				nx = selmon->wx;
+ 			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
+ 				nx = selmon->wx + selmon->ww - WIDTH(c);
+ 			if (abs(selmon->wy - ny) < snap)
+ 				ny = selmon->wy;
+ 			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
+ 				ny = selmon->wy + selmon->wh - HEIGHT(c);
+ 			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+ 			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
+ 				togglefloating(NULL);
+ 			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+ 				resize(c, nx, ny, c->w, c->h, 1);
+ 			break;
+ 		}
+ 	} while (ev.type != ButtonRelease);
+ 	XUngrabPointer(dpy, CurrentTime);
+ 	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+ 		sendmon(c, m);
+ 		selmon = m;
+ 		focus(NULL);
+ 	}
+ }
+ 
+ Client *
+ nexttiled(Client *c)
+ {
+ 	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
+ 	return c;
+ }
+ 
+ void
+ pop(Client *c)
+ {
+ 	detach(c);
+ 	attach(c);
+ 	focus(c);
+ 	arrange(c->mon);
+ }
+ 
+ void
+ propertynotify(XEvent *e)
+ {
+ 	Client *c;
+ 	Window trans;
+ 	XPropertyEvent *ev = &e->xproperty;
+ 
+ 	if ((ev->window == root) && (ev->atom == XA_WM_NAME))
+ 		updatestatus();
+ 	else if (ev->state == PropertyDelete)
+ 		return; /* ignore */
+ 	else if ((c = wintoclient(ev->window))) {
+ 		switch(ev->atom) {
+ 		default: break;
+ 		case XA_WM_TRANSIENT_FOR:
+ 			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
+ 				(c->isfloating = (wintoclient(trans)) != NULL))
+ 				arrange(c->mon);
+ 			break;
+ 		case XA_WM_NORMAL_HINTS:
+ 			updatesizehints(c);
+ 			break;
+ 		case XA_WM_HINTS:
+ 			updatewmhints(c);
+ 			drawbars();
+ 			break;
+ 		}
+ 		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+ 			updatetitle(c);
+ 			if (c == c->mon->sel)
+ 				drawbar(c->mon);
+ 		}
+ 		if (ev->atom == netatom[NetWMWindowType])
+ 			updatewindowtype(c);
+ 	}
+ }
+ 
+ void
+ quit(const Arg *arg)
+ {
+ 	running = 0;
+ }
+ 
+ Monitor *
+ recttomon(int x, int y, int w, int h)
+ {
+ 	Monitor *m, *r = selmon;
+ 	int a, area = 0;
+ 
+ 	for (m = mons; m; m = m->next)
+ 		if ((a = INTERSECT(x, y, w, h, m)) > area) {
+ 			area = a;
+ 			r = m;
+ 		}
+ 	return r;
+ }
+ 
+ void
+ resize(Client *c, int x, int y, int w, int h, int interact)
+ {
+ 	if (applysizehints(c, &x, &y, &w, &h, interact))
+ 		resizeclient(c, x, y, w, h);
+ }
+ 
+ void
+ resizeclient(Client *c, int x, int y, int w, int h)
+ {
+ 	XWindowChanges wc;
+ 
+ 	c->oldx = c->x; c->x = wc.x = x;
+ 	c->oldy = c->y; c->y = wc.y = y;
+ 	c->oldw = c->w; c->w = wc.width = w;
+ 	c->oldh = c->h; c->h = wc.height = h;
+ 	wc.border_width = c->bw;
+ 	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
+ 	configure(c);
+ 	XSync(dpy, False);
+ }
+ 
+ void
+ resizemouse(const Arg *arg)
+ {
+ 	int ocx, ocy, nw, nh;
+ 	Client *c;
+ 	Monitor *m;
+ 	XEvent ev;
+ 	Time lasttime = 0;
+ 
+ 	if (!(c = selmon->sel))
+ 		return;
+ 	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+ 		return;
+ 	restack(selmon);
+ 	ocx = c->x;
+ 	ocy = c->y;
+ 	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+ 		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
+ 		return;
+ 	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+ 	do {
+ 		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
+ 		switch(ev.type) {
+ 		case ConfigureRequest:
+ 		case Expose:
+ 		case MapRequest:
+ 			handler[ev.type](&ev);
+ 			break;
+ 		case MotionNotify:
+ 			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+ 				continue;
+ 			lasttime = ev.xmotion.time;
+ 
+ 			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
+ 			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
+ 			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
+ 			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
+ 			{
+ 				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
+ 				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
+ 					togglefloating(NULL);
+ 			}
+ 			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+ 				resize(c, c->x, c->y, nw, nh, 1);
+ 			break;
+ 		}
+ 	} while (ev.type != ButtonRelease);
+ 	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
+ 	XUngrabPointer(dpy, CurrentTime);
+ 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+ 	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+ 		sendmon(c, m);
+ 		selmon = m;
+ 		focus(NULL);
+ 	}
+ }
+ 
+ void
+ restack(Monitor *m)
+ {
+ 	Client *c;
+ 	XEvent ev;
+ 	XWindowChanges wc;
+ 
+ 	drawbar(m);
+ 	if (!m->sel)
+ 		return;
+ 	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
+ 		XRaiseWindow(dpy, m->sel->win);
+ 	if (m->lt[m->sellt]->arrange) {
+ 		wc.stack_mode = Below;
+ 		wc.sibling = m->barwin;
+ 		for (c = m->stack; c; c = c->snext)
+ 			if (!c->isfloating && ISVISIBLE(c)) {
+ 				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
+ 				wc.sibling = c->win;
+ 			}
+ 	}
+ 	XSync(dpy, False);
+ 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
+ }
+ 
+ void
+ run(void)
+ {
+ 	XEvent ev;
+ 	/* main event loop */
+ 	XSync(dpy, False);
+ 	while (running && !XNextEvent(dpy, &ev))
+ 		if (handler[ev.type])
+ 			handler[ev.type](&ev); /* call handler */
+ }
+ 
+ void
+ runautostart(void)
+ {
+ 	char *pathpfx;
+ 	char *path;
+ 	char *xdgdatahome;
+ 	char *home;
+ 	struct stat sb;
+ 
+ 	if ((home = getenv("HOME")) == NULL)
+ 		/* this is almost impossible */
+ 		return;
+ 
+ 	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+ 	 * otherwise use ~/.local/share/dwm as autostart script directory
+ 	 */
+ 	xdgdatahome = getenv("XDG_DATA_HOME");
+ 	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+ 		/* space for path segments, separators and nul */
+ 		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+ 
+ 		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 	} else {
+ 		/* space for path segments, separators and nul */
+ 		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+ 		                     + strlen(dwmdir) + 3);
+ 
+ 		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* check if the autostart script directory exists */
+ 	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+ 		/* the XDG conformant path does not exist or is no directory
+ 		 * so we try ~/.dwm instead
+ 		 */
+ 		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+ 		if(pathpfx_new == NULL) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 		pathpfx = pathpfx_new;
+ 
+ 		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+ 			free(pathpfx);
+ 			return;
+ 		}
+ 	}
+ 
+ 	/* try the blocking script first */
+ 	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+ 	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+ 		free(path);
+ 		free(pathpfx);
+ 	}
+ 
+ 	if (access(path, X_OK) == 0)
+ 		system(path);
+ 
+ 	/* now the non-blocking script */
+ 	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+ 		free(path);
+ 		free(pathpfx);
+ 	}
+ 
+ 	if (access(path, X_OK) == 0)
+ 		system(strcat(path, " &"));
+ 
+ 	free(pathpfx);
+ 	free(path);
+ }
+ 
+ void
+ scan(void)
+ {
+ 	unsigned int i, num;
+ 	Window d1, d2, *wins = NULL;
+ 	XWindowAttributes wa;
+ 
+ 	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
+ 		for (i = 0; i < num; i++) {
+ 			if (!XGetWindowAttributes(dpy, wins[i], &wa)
+ 			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
+ 				continue;
+ 			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
+ 				manage(wins[i], &wa);
+ 		}
+ 		for (i = 0; i < num; i++) { /* now the transients */
+ 			if (!XGetWindowAttributes(dpy, wins[i], &wa))
+ 				continue;
+ 			if (XGetTransientForHint(dpy, wins[i], &d1)
+ 			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
+ 				manage(wins[i], &wa);
+ 		}
+ 		if (wins)
+ 			XFree(wins);
+ 	}
+ }
+ 
+ void
+ sendmon(Client *c, Monitor *m)
+ {
+ 	if (c->mon == m)
+ 		return;
+ 	unfocus(c, 1);
+ 	detach(c);
+ 	detachstack(c);
+ 	c->mon = m;
+ 	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+ 	attachbottom(c);
+ 	attachstack(c);
+ 	focus(NULL);
+ 	arrange(NULL);
+ }
+ 
+ void
+ setclientstate(Client *c, long state)
+ {
+ 	long data[] = { state, None };
+ 
+ 	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
+ 		PropModeReplace, (unsigned char *)data, 2);
+ }
+ 
+ int
+ sendevent(Client *c, Atom proto)
+ {
+ 	int n;
+ 	Atom *protocols;
+ 	int exists = 0;
+ 	XEvent ev;
+ 
+ 	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
+ 		while (!exists && n--)
+ 			exists = protocols[n] == proto;
+ 		XFree(protocols);
+ 	}
+ 	if (exists) {
+ 		ev.type = ClientMessage;
+ 		ev.xclient.window = c->win;
+ 		ev.xclient.message_type = wmatom[WMProtocols];
+ 		ev.xclient.format = 32;
+ 		ev.xclient.data.l[0] = proto;
+ 		ev.xclient.data.l[1] = CurrentTime;
+ 		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
+ 	}
+ 	return exists;
+ }
+ 
+ void
+ setfocus(Client *c)
+ {
+ 	if (!c->neverfocus) {
+ 		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
+ 		XChangeProperty(dpy, root, netatom[NetActiveWindow],
+ 			XA_WINDOW, 32, PropModeReplace,
+ 			(unsigned char *) &(c->win), 1);
+ 	}
+ 	sendevent(c, wmatom[WMTakeFocus]);
+ }
+ 
+ void
+ setfullscreen(Client *c, int fullscreen)
+ {
+ 	if (fullscreen && !c->isfullscreen) {
+ 		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+ 			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
+ 		c->isfullscreen = 1;
+ 		c->oldstate = c->isfloating;
+ 		c->oldbw = c->bw;
+ 		c->bw = 0;
+ 		c->isfloating = 1;
+ 		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+ 		XRaiseWindow(dpy, c->win);
+ 	} else if (!fullscreen && c->isfullscreen){
+ 		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+ 			PropModeReplace, (unsigned char*)0, 0);
+ 		c->isfullscreen = 0;
+ 		c->isfloating = c->oldstate;
+ 		c->bw = c->oldbw;
+ 		c->x = c->oldx;
+ 		c->y = c->oldy;
+ 		c->w = c->oldw;
+ 		c->h = c->oldh;
+ 		resizeclient(c, c->x, c->y, c->w, c->h);
+ 		arrange(c->mon);
+ 	}
+ }
+ 
+ void
+ setgaps(const Arg *arg)
+ {
+ 	if ((arg->i == 0) || (selmon->gappx + arg->i < 0))
+ 		selmon->gappx = 0;
+ 	else
+ 		selmon->gappx += arg->i;
+ 	arrange(selmon);
+ }
+ 
+ void
+ setlayout(const Arg *arg)
+ {
+ 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+ 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+ 	if (arg && arg->v)
+ 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+ 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+ 	if (selmon->sel)
+ 		arrange(selmon);
+ 	else
+ 		drawbar(selmon);
+ }
+ 
+ /* arg > 1.0 will set mfact absolutely */
+ void
+ setmfact(const Arg *arg)
+ {
+ 	float f;
+ 
+ 	if (!arg || !selmon->lt[selmon->sellt]->arrange)
+ 		return;
+ 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+ 	if (f < 0.1 || f > 0.9)
+ 		return;
+ 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+ 	arrange(selmon);
+ }
+ 
+ void
+ setup(void)
+ {
+ 	int i;
+ 	XSetWindowAttributes wa;
+ 	Atom utf8string;
+ 
+ 	/* clean up any zombies immediately */
+ 	sigchld(0);
+ 
+ 	/* init screen */
+ 	screen = DefaultScreen(dpy);
+ 	sw = DisplayWidth(dpy, screen);
+ 	sh = DisplayHeight(dpy, screen);
+ 	root = RootWindow(dpy, screen);
+ 	drw = drw_create(dpy, screen, root, sw, sh);
+ 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+ 		die("no fonts could be loaded.");
+ 	lrpad = drw->fonts->h;
+ 	bh = drw->fonts->h + 2;
+ 	updategeom();
+ 	/* init atoms */
+ 	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+ 	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
+ 	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+ 	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
+ 	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
+ 	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
+ 	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
+ 	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
+ 	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+ 	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+ 	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+ 	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+ 	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+ 	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+ 	/* init cursors */
+ 	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
+ 	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+ 	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+ 	/* init appearance */
+ 	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+ 	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+ 	for (i = 0; i < LENGTH(colors); i++)
+ 		scheme[i] = drw_scm_create(drw, colors[i], 3);
+ 	/* init bars */
+ 	updatebars();
+ 	updatestatus();
+ 	/* supporting window for NetWMCheck */
+ 	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
+ 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
+ 		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+ 	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
+ 		PropModeReplace, (unsigned char *) "dwm", 3);
+ 	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
+ 		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
+ 	/* EWMH support per view */
+ 	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
+ 		PropModeReplace, (unsigned char *) netatom, NetLast);
+ 	XDeleteProperty(dpy, root, netatom[NetClientList]);
+ 	/* select events */
+ 	wa.cursor = cursor[CurNormal]->cursor;
+ 	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
+ 		|ButtonPressMask|PointerMotionMask|EnterWindowMask
+ 		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
+ 	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
+ 	XSelectInput(dpy, root, wa.event_mask);
+ 	grabkeys();
+ 	focus(NULL);
+ }
+ 
+ 
+ void
+ seturgent(Client *c, int urg)
+ {
+ 	XWMHints *wmh;
+ 
+ 	c->isurgent = urg;
+ 	if (!(wmh = XGetWMHints(dpy, c->win)))
+ 		return;
+ 	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
+ 	XSetWMHints(dpy, c->win, wmh);
+ 	XFree(wmh);
+ }
+ 
+ void
+ showhide(Client *c)
+ {
+ 	if (!c)
+ 		return;
+ 	if (ISVISIBLE(c)) {
+ 		if ((c->tags & SPTAGMASK) && c->isfloating) {
+ 			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+ 			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+ 		}
+ 		/* show clients top down */
+ 		XMoveWindow(dpy, c->win, c->x, c->y);
+ 		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+ 			resize(c, c->x, c->y, c->w, c->h, 0);
+ 		showhide(c->snext);
+ 	} else {
+ 		/* hide clients bottom up */
+ 		showhide(c->snext);
+ 		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+ 	}
+ }
+ 
+ void
+ sigchld(int unused)
+ {
+ 	if (signal(SIGCHLD, sigchld) == SIG_ERR)
+ 		die("can't install SIGCHLD handler:");
+ 	while (0 < waitpid(-1, NULL, WNOHANG));
+ }
+ 
+ void
+ spawn(const Arg *arg)
+ {
+ 	if (arg->v == dmenucmd)
+ 		dmenumon[0] = '0' + selmon->num;
+ 	if (fork() == 0) {
+ 		if (dpy)
+ 			close(ConnectionNumber(dpy));
+ 		setsid();
+ 		execvp(((char **)arg->v)[0], (char **)arg->v);
+ 		fprintf(stderr, "dwm: execvp %s", ((char **)arg->v)[0]);
+ 		perror(" failed");
+ 		exit(EXIT_SUCCESS);
+ 	}
+ }
+ 
+ void
+ tag(const Arg *arg)
+ {
+ 	if (selmon->sel && arg->ui & TAGMASK) {
+ 		selmon->sel->tags = arg->ui & TAGMASK;
+ 		focus(NULL);
+ 		arrange(selmon);
+ 	}
+ }
+ 
+ void
+ tagmon(const Arg *arg)
+ {
+ 	if (!selmon->sel || !mons->next)
+ 		return;
+ 	sendmon(selmon->sel, dirtomon(arg->i));
+ }
+ 
+ void
+ tile(Monitor *m)
+ {
+ 	unsigned int i, n, h, mw, my, ty;
+ 	Client *c;
+ 
+ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ 	if (n == 0)
+ 		return;
+ 
+ 	if (n > m->nmaster)
+ 		mw = m->nmaster ? m->ww * m->mfact : 0;
+ 	else
+ 		mw = m->ww - m->gappx;
+ 	for (i = 0, my = ty = m->gappx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ 		if (i < m->nmaster) {
+ 			h = (m->wh - my) / (MIN(n, m->nmaster) - i) - m->gappx;
+ 			resize(c, m->wx + m->gappx, m->wy + my, mw - (2*c->bw) - m->gappx, h - (2*c->bw), 0);
+ 			my += HEIGHT(c) + m->gappx;
+ 		} else {
+ 			h = (m->wh - ty) / (n - i) - m->gappx;
+ 			resize(c, m->wx + mw + m->gappx, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappx, h - (2*c->bw), 0);
+ 			ty += HEIGHT(c) + m->gappx;
+ 		}
+ }
+ 
+ void
+ togglebar(const Arg *arg)
+ {
+ 	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
+ 	updatebarpos(selmon);
+ 	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+ 	arrange(selmon);
+ }
+ 
+ void
+ togglefloating(const Arg *arg)
+ {
+ 	if (!selmon->sel)
+ 		return;
+ 	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+ 		return;
+ 	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+ 	if (selmon->sel->isfloating)
+ 		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
+ 			selmon->sel->w, selmon->sel->h, 0);
+ 	arrange(selmon);
+ }
+ 
+ void
+ togglescratch(const Arg *arg)
+ {
+ 	Client *c;
+ 	unsigned int found = 0;
+ 	unsigned int scratchtag = SPTAG(arg->ui);
+ 	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+ 
+ 	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+ 	if (found) {
+ 		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+ 		if (newtagset) {
+ 			selmon->tagset[selmon->seltags] = newtagset;
+ 			focus(NULL);
+ 			arrange(selmon);
+ 		}
+ 		if (ISVISIBLE(c)) {
+ 			focus(c);
+ 			restack(selmon);
+ 		}
+ 	} else {
+ 		selmon->tagset[selmon->seltags] |= scratchtag;
+ 		spawn(&sparg);
+ 	}
+ }
+ 
+ void
+ toggletag(const Arg *arg)
+ {
+ 	unsigned int newtags;
+ 
+ 	if (!selmon->sel)
+ 		return;
+ 	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
+ 	if (newtags) {
+ 		selmon->sel->tags = newtags;
+ 		focus(NULL);
+ 		arrange(selmon);
+ 	}
+ }
+ 
+ void
+ toggleview(const Arg *arg)
+ {
+ 	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+ 	int i;
+ 
+ 	if (newtagset) {
+ 		selmon->tagset[selmon->seltags] = newtagset;
+ 
+ 		if (newtagset == ~0) {
+ 			selmon->pertag->prevtag = selmon->pertag->curtag;
+ 			selmon->pertag->curtag = 0;
+ 		}
+ 
+ 		/* test if the user did not select the same tag */
+ 		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+ 			selmon->pertag->prevtag = selmon->pertag->curtag;
+ 			for (i = 0; !(newtagset & 1 << i); i++) ;
+ 			selmon->pertag->curtag = i + 1;
+ 		}
+ 
+ 		/* apply settings for this view */
+ 		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ 		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ 		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ 
+ 		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ 			togglebar(NULL);
+ 
+ 		focus(NULL);
+ 		arrange(selmon);
+ 	}
+ }
+ 
+ void
+ unfocus(Client *c, int setfocus)
+ {
+ 	if (!c)
+ 		return;
+ 	grabbuttons(c, 0);
+ 	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+ 	if (setfocus) {
+ 		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+ 		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+ 	}
+ }
+ 
+ void
+ unmanage(Client *c, int destroyed)
+ {
+ 	Monitor *m = c->mon;
+ 	XWindowChanges wc;
+ 
+ 	detach(c);
+ 	detachstack(c);
+ 	if (!destroyed) {
+ 		wc.border_width = c->oldbw;
+ 		XGrabServer(dpy); /* avoid race conditions */
+ 		XSetErrorHandler(xerrordummy);
+ 		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
+ 		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+ 		setclientstate(c, WithdrawnState);
+ 		XSync(dpy, False);
+ 		XSetErrorHandler(xerror);
+ 		XUngrabServer(dpy);
+ 	}
+ 	free(c);
+ 	focus(NULL);
+ 	updateclientlist();
+ 	arrange(m);
+ }
+ 
+ void
+ unmapnotify(XEvent *e)
+ {
+ 	Client *c;
+ 	XUnmapEvent *ev = &e->xunmap;
+ 
+ 	if ((c = wintoclient(ev->window))) {
+ 		if (ev->send_event)
+ 			setclientstate(c, WithdrawnState);
+ 		else
+ 			unmanage(c, 0);
+ 	}
+ }
+ 
+ void
+ updatebars(void)
+ {
+ 	Monitor *m;
+ 	XSetWindowAttributes wa = {
+ 		.override_redirect = True,
+ 		.background_pixmap = ParentRelative,
+ 		.event_mask = ButtonPressMask|ExposureMask
+ 	};
+ 	XClassHint ch = {"dwm", "dwm"};
+ 	for (m = mons; m; m = m->next) {
+ 		if (m->barwin)
+ 			continue;
+ 		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, m->ww, bh, 0, DefaultDepth(dpy, screen),
+ 				CopyFromParent, DefaultVisual(dpy, screen),
+ 				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+ 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+ 		XMapRaised(dpy, m->barwin);
+ 		XSetClassHint(dpy, m->barwin, &ch);
+ 	}
+ }
+ 
+ void
+ updatebarpos(Monitor *m)
+ {
+ 	m->wy = m->my;
+ 	m->wh = m->mh;
+ 	if (m->showbar) {
+ 		m->wh -= bh;
+ 		m->by = m->topbar ? m->wy : m->wy + m->wh;
+ 		m->wy = m->topbar ? m->wy + bh : m->wy;
+ 	} else
+ 		m->by = -bh;
+ }
+ 
+ void
+ updateclientlist()
+ {
+ 	Client *c;
+ 	Monitor *m;
+ 
+ 	XDeleteProperty(dpy, root, netatom[NetClientList]);
+ 	for (m = mons; m; m = m->next)
+ 		for (c = m->clients; c; c = c->next)
+ 			XChangeProperty(dpy, root, netatom[NetClientList],
+ 				XA_WINDOW, 32, PropModeAppend,
+ 				(unsigned char *) &(c->win), 1);
+ }
+ 
+ int
+ updategeom(void)
+ {
+ 	int dirty = 0;
+ 
+ #ifdef XINERAMA
+ 	if (XineramaIsActive(dpy)) {
+ 		int i, j, n, nn;
+ 		Client *c;
+ 		Monitor *m;
+ 		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
+ 		XineramaScreenInfo *unique = NULL;
+ 
+ 		for (n = 0, m = mons; m; m = m->next, n++);
+ 		/* only consider unique geometries as separate screens */
+ 		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
+ 		for (i = 0, j = 0; i < nn; i++)
+ 			if (isuniquegeom(unique, j, &info[i]))
+ 				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
+ 		XFree(info);
+ 		nn = j;
+ 		if (n <= nn) { /* new monitors available */
+ 			for (i = 0; i < (nn - n); i++) {
+ 				for (m = mons; m && m->next; m = m->next);
+ 				if (m)
+ 					m->next = createmon();
+ 				else
+ 					mons = createmon();
+ 			}
+ 			for (i = 0, m = mons; i < nn && m; m = m->next, i++)
+ 				if (i >= n
+ 				|| unique[i].x_org != m->mx || unique[i].y_org != m->my
+ 				|| unique[i].width != m->mw || unique[i].height != m->mh)
+ 				{
+ 					dirty = 1;
+ 					m->num = i;
+ 					m->mx = m->wx = unique[i].x_org;
+ 					m->my = m->wy = unique[i].y_org;
+ 					m->mw = m->ww = unique[i].width;
+ 					m->mh = m->wh = unique[i].height;
+ 					updatebarpos(m);
+ 				}
+ 		} else { /* less monitors available nn < n */
+ 			for (i = nn; i < n; i++) {
+ 				for (m = mons; m && m->next; m = m->next);
+ 				while ((c = m->clients)) {
+ 					dirty = 1;
+ 					m->clients = c->next;
+ 					detachstack(c);
+ 					c->mon = mons;
+ 					attachbottom(c);
+ 					attachstack(c);
+ 				}
+ 				if (m == selmon)
+ 					selmon = mons;
+ 				cleanupmon(m);
+ 			}
+ 		}
+ 		free(unique);
+ 	} else
+ #endif /* XINERAMA */
+ 	{ /* default monitor setup */
+ 		if (!mons)
+ 			mons = createmon();
+ 		if (mons->mw != sw || mons->mh != sh) {
+ 			dirty = 1;
+ 			mons->mw = mons->ww = sw;
+ 			mons->mh = mons->wh = sh;
+ 			updatebarpos(mons);
+ 		}
+ 	}
+ 	if (dirty) {
+ 		selmon = mons;
+ 		selmon = wintomon(root);
+ 	}
+ 	return dirty;
+ }
+ 
+ void
+ updatenumlockmask(void)
+ {
+ 	unsigned int i, j;
+ 	XModifierKeymap *modmap;
+ 
+ 	numlockmask = 0;
+ 	modmap = XGetModifierMapping(dpy);
+ 	for (i = 0; i < 8; i++)
+ 		for (j = 0; j < modmap->max_keypermod; j++)
+ 			if (modmap->modifiermap[i * modmap->max_keypermod + j]
+ 				== XKeysymToKeycode(dpy, XK_Num_Lock))
+ 				numlockmask = (1 << i);
+ 	XFreeModifiermap(modmap);
+ }
+ 
+ void
+ updatesizehints(Client *c)
+ {
+ 	long msize;
+ 	XSizeHints size;
+ 
+ 	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
+ 		/* size is uninitialized, ensure that size.flags aren't used */
+ 		size.flags = PSize;
+ 	if (size.flags & PBaseSize) {
+ 		c->basew = size.base_width;
+ 		c->baseh = size.base_height;
+ 	} else if (size.flags & PMinSize) {
+ 		c->basew = size.min_width;
+ 		c->baseh = size.min_height;
+ 	} else
+ 		c->basew = c->baseh = 0;
+ 	if (size.flags & PResizeInc) {
+ 		c->incw = size.width_inc;
+ 		c->inch = size.height_inc;
+ 	} else
+ 		c->incw = c->inch = 0;
+ 	if (size.flags & PMaxSize) {
+ 		c->maxw = size.max_width;
+ 		c->maxh = size.max_height;
+ 	} else
+ 		c->maxw = c->maxh = 0;
+ 	if (size.flags & PMinSize) {
+ 		c->minw = size.min_width;
+ 		c->minh = size.min_height;
+ 	} else if (size.flags & PBaseSize) {
+ 		c->minw = size.base_width;
+ 		c->minh = size.base_height;
+ 	} else
+ 		c->minw = c->minh = 0;
+ 	if (size.flags & PAspect) {
+ 		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
+ 		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
+ 	} else
+ 		c->maxa = c->mina = 0.0;
+ 	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
+ }
+ 
+ void
+ updatestatus(void)
+ {
+ 	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+ 		strcpy(stext, "dwm-"VERSION);
+ 	drawbar(selmon);
+ }
+ 
+ void
+ updatetitle(Client *c)
+ {
+ 	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
+ 		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
+ 	if (c->name[0] == '\0') /* hack to mark broken clients */
+ 		strcpy(c->name, broken);
+ }
+ 
+ void
+ updatewindowtype(Client *c)
+ {
+ 	Atom state = getatomprop(c, netatom[NetWMState]);
+ 	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
+ 
+ 	if (state == netatom[NetWMFullscreen])
+ 		setfullscreen(c, 1);
+ 	if (wtype == netatom[NetWMWindowTypeDialog])
+ 		c->isfloating = 1;
+ }
+ 
+ void
+ updatewmhints(Client *c)
+ {
+ 	XWMHints *wmh;
+ 
+ 	if ((wmh = XGetWMHints(dpy, c->win))) {
+ 		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
+ 			wmh->flags &= ~XUrgencyHint;
+ 			XSetWMHints(dpy, c->win, wmh);
+ 		} else
+ 			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+ 		if (wmh->flags & InputHint)
+ 			c->neverfocus = !wmh->input;
+ 		else
+ 			c->neverfocus = 0;
+ 		XFree(wmh);
+ 	}
+ }
+ 
+ void
+ view(const Arg *arg)
+ {
+ 	int i;
+ 	unsigned int tmptag;
+ 
+ 	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+ 		return;
+ 	selmon->seltags ^= 1; /* toggle sel tagset */
+ 	if (arg->ui & TAGMASK) {
+ 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+ 		selmon->pertag->prevtag = selmon->pertag->curtag;
+ 
+ 		if (arg->ui == ~0)
+ 			selmon->pertag->curtag = 0;
+ 		else {
+ 			for (i = 0; !(arg->ui & 1 << i); i++) ;
+ 			selmon->pertag->curtag = i + 1;
+ 		}
+ 	} else {
+ 		tmptag = selmon->pertag->prevtag;
+ 		selmon->pertag->prevtag = selmon->pertag->curtag;
+ 		selmon->pertag->curtag = tmptag;
+ 	}
+ 
+ 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ 	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ 	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ 	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ 
+ 	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ 		togglebar(NULL);
+ 
+ 	focus(NULL);
+ 	arrange(selmon);
+ }
+ 
+ Client *
+ wintoclient(Window w)
+ {
+ 	Client *c;
+ 	Monitor *m;
+ 
+ 	for (m = mons; m; m = m->next)
+ 		for (c = m->clients; c; c = c->next)
+ 			if (c->win == w)
+ 				return c;
+ 	return NULL;
+ }
+ 
+ Monitor *
+ wintomon(Window w)
+ {
+ 	int x, y;
+ 	Client *c;
+ 	Monitor *m;
+ 
+ 	if (w == root && getrootptr(&x, &y))
+ 		return recttomon(x, y, 1, 1);
+ 	for (m = mons; m; m = m->next)
+ 		if (w == m->barwin)
+ 			return m;
+ 	if ((c = wintoclient(w)))
+ 		return c->mon;
+ 	return selmon;
+ }
+ 
+ /* There's no way to check accesses to destroyed windows, thus those cases are
+  * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
+  * default error handler, which may call exit. */
+ int
+ xerror(Display *dpy, XErrorEvent *ee)
+ {
+ 	if (ee->error_code == BadWindow
+ 	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
+ 	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
+ 	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
+ 	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
+ 	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
+ 	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
+ 	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
+ 	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
+ 		return 0;
+ 	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
+ 		ee->request_code, ee->error_code);
+ 	return xerrorxlib(dpy, ee); /* may call exit */
+ }
+ 
+ int
+ xerrordummy(Display *dpy, XErrorEvent *ee)
+ {
+ 	return 0;
+ }
+ 
+ /* Startup Error handler to check if another window manager
+  * is already running. */
+ int
+ xerrorstart(Display *dpy, XErrorEvent *ee)
+ {
+ 	die("dwm: another window manager is already running");
+ 	return -1;
+ }
+ 
+ void
+ zoom(const Arg *arg)
+ {
+ 	Client *c = selmon->sel;
+ 
+ 	if (!selmon->lt[selmon->sellt]->arrange
+ 	|| (selmon->sel && selmon->sel->isfloating))
+ 		return;
+ 	if (c == nexttiled(selmon->clients))
+ 		if (!c || !(c = nexttiled(c->next)))
+ 			return;
+ 	pop(c);
+ }
+ 
+ int
+ main(int argc, char *argv[])
+ {
+ 	if (argc == 2 && !strcmp("-v", argv[1]))
+ 		die("dwm-"VERSION);
+ 	else if (argc != 1)
+ 		die("usage: dwm [-v]");
+ 	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("dwm: cannot open display");
+ 	checkotherwm();
+ 	setup();
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath proc exec", NULL) == -1)
+ 		die("pledge");
+ #endif /* __OpenBSD__ */
+ 	scan();
+ 	runautostart();
+ 	run();
+ 	cleanup();
+ 	XCloseDisplay(dpy);
+ 	return EXIT_SUCCESS;
+ }
+ 
+ void
+ centeredmaster(Monitor *m)
+ {
+ 	unsigned int i, n, h, mw, mx, my, oty, ety, tw;
+ 	Client *c;
+ 
+ 	/* count number of clients in the selected monitor */
+ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ 	if (n == 0)
+ 		return;
+ 
+ 	/* initialize areas */
+ 	mw = m->ww;
+ 	mx = 0;
+ 	my = 0;
+ 	tw = mw;
+ 
+ 	if (n > m->nmaster) {
+ 		/* go mfact box in the center if more than nmaster clients */
+ 		mw = m->nmaster ? m->ww * m->mfact : 0;
+ 		tw = m->ww - mw;
+ 
+ 		if (n - m->nmaster > 1) {
+ 			/* only one client */
+ 			mx = (m->ww - mw) / 2;
+ 			tw = (m->ww - mw) / 2;
+ 		}
+ 	}
+ 
+ 	oty = 0;
+ 	ety = 0;
+ 	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ 	if (i < m->nmaster) {
+ 		/* nmaster clients are stacked vertically, in the center
+ 		 * of the screen */
+ 		h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+ 		resize(c, m->wx + mx, m->wy + my, mw - (2*c->bw),
+ 		       h - (2*c->bw), 0);
+ 		my += HEIGHT(c);
+ 	} else {
+ 		/* stack clients are stacked vertically */
+ 		if ((i - m->nmaster) % 2 ) {
+ 			h = (m->wh - ety) / ( (1 + n - i) / 2);
+ 			resize(c, m->wx, m->wy + ety, tw - (2*c->bw),
+ 			       h - (2*c->bw), 0);
+ 			ety += HEIGHT(c);
+ 		} else {
+ 			h = (m->wh - oty) / ((1 + n - i) / 2);
+ 			resize(c, m->wx + mx + mw, m->wy + oty,
+ 			       tw - (2*c->bw), h - (2*c->bw), 0);
+ 			oty += HEIGHT(c);
+ 		}
+ 	}
+ }
+ 
+ void
+ centeredfloatingmaster(Monitor *m)
+ {
+ 	unsigned int i, n, w, mh, mw, mx, mxo, my, myo, tx;
+ 	Client *c;
+ 
+ 	/* count number of clients in the selected monitor */
+ 	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ 	if (n == 0)
+ 		return;
+ 
+ 	/* initialize nmaster area */
+ 	if (n > m->nmaster) {
+ 		/* go mfact box in the center if more than nmaster clients */
+ 		if (m->ww > m->wh) {
+ 			mw = m->nmaster ? m->ww * m->mfact : 0;
+ 			mh = m->nmaster ? m->wh * 0.9 : 0;
+ 		} else {
+ 			mh = m->nmaster ? m->wh * m->mfact : 0;
+ 			mw = m->nmaster ? m->ww * 0.9 : 0;
+ 		}
+ 		mx = mxo = (m->ww - mw) / 2;
+ 		my = myo = (m->wh - mh) / 2;
+ 	} else {
+ 		/* go fullscreen if all clients are in the master area */
+ 		mh = m->wh;
+ 		mw = m->ww;
+ 		mx = mxo = 0;
+ 		my = myo = 0;
+ 	}
+ 
+ 	for(i = tx = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ 	if (i < m->nmaster) {
+ 		/* nmaster clients are stacked horizontally, in the center
+ 		 * of the screen */
+ 		w = (mw + mxo - mx) / (MIN(n, m->nmaster) - i);
+ 		resize(c, m->wx + mx, m->wy + my, w - (2*c->bw),
+ 		       mh - (2*c->bw), 0);
+ 		mx += WIDTH(c);
+ 	} else {
+ 		/* stack clients are stacked horizontally */
+ 		w = (m->ww - tx) / (n - i);
+ 		resize(c, m->wx + tx, m->wy, w - (2*c->bw),
+ 		       m->wh - (2*c->bw), 0);
+ 		tx += WIDTH(c);
+ 	}
+ }
diff -crNb dwm-6.2/dwm.c.rej dwm/dwm.c.rej
*** dwm-6.2/dwm.c.rej	1969-12-31 21:00:00.000000000 -0300
--- dwm/dwm.c.rej	2021-10-31 17:28:42.155185935 -0300
***************
*** 0 ****
--- 1,19 ----
+ --- dwm.c	2019-02-02 15:55:28.000000000 +0300
+ +++ dwm.c	2020-02-18 03:33:58.213447007 +0300
+ @@ -1712,13 +1738,15 @@
+  		mw = m->ww;
+  	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+  		if (i < m->nmaster) {
+ -			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+ +			h = (m->wh - my) * (c->cfact / mfacts);
+  			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+  			my += HEIGHT(c);
+ +			mfacts -= c->cfact;
+  		} else {
+  			h = (m->wh - ty) / (n - i);
+  			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+  			ty += HEIGHT(c);
+ +			sfacts -= c->cfact;
+  		}
+  }
+  
Binary files dwm-6.2/dwm.o and dwm/dwm.o differ
diff -crNb dwm-6.2/movestack.c dwm/movestack.c
*** dwm-6.2/movestack.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/movestack.c	2021-10-31 17:28:42.179186115 -0300
***************
*** 0 ****
--- 1,49 ----
+ void
+ movestack(const Arg *arg) {
+ 	Client *c = NULL, *p = NULL, *pc = NULL, *i;
+ 
+ 	if(arg->i > 0) {
+ 		/* find the client after selmon->sel */
+ 		for(c = selmon->sel->next; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+ 		if(!c)
+ 			for(c = selmon->clients; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+ 
+ 	}
+ 	else {
+ 		/* find the client before selmon->sel */
+ 		for(i = selmon->clients; i != selmon->sel; i = i->next)
+ 			if(ISVISIBLE(i) && !i->isfloating)
+ 				c = i;
+ 		if(!c)
+ 			for(; i; i = i->next)
+ 				if(ISVISIBLE(i) && !i->isfloating)
+ 					c = i;
+ 	}
+ 	/* find the client before selmon->sel and c */
+ 	for(i = selmon->clients; i && (!p || !pc); i = i->next) {
+ 		if(i->next == selmon->sel)
+ 			p = i;
+ 		if(i->next == c)
+ 			pc = i;
+ 	}
+ 
+ 	/* swap c and selmon->sel selmon->clients in the selmon->clients list */
+ 	if(c && c != selmon->sel) {
+ 		Client *temp = selmon->sel->next==c?selmon->sel:selmon->sel->next;
+ 		selmon->sel->next = c->next==selmon->sel?c:c->next;
+ 		c->next = temp;
+ 
+ 		if(p && p != c)
+ 			p->next = c;
+ 		if(pc && pc != selmon->sel)
+ 			pc->next = selmon->sel;
+ 
+ 		if(selmon->sel == selmon->clients)
+ 			selmon->clients = c;
+ 		else if(c == selmon->clients)
+ 			selmon->clients = selmon->sel;
+ 
+ 		arrange(selmon);
+ 	}
+ }
+ 
diff -crNb dwm-6.2/patches/dwm-alwayscenter-20200625-f04cac6.diff dwm/patches/dwm-alwayscenter-20200625-f04cac6.diff
*** dwm-6.2/patches/dwm-alwayscenter-20200625-f04cac6.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-alwayscenter-20200625-f04cac6.diff	2021-10-31 17:28:42.430188000 -0300
***************
*** 0 ****
--- 1,12 ----
+ diff -up dwm/dwm.c dwmmod/dwm.c
+ --- dwm/dwm.c	2020-06-25 00:21:30.383692180 -0300
+ +++ dwmmod/dwm.c	2020-06-25 00:20:35.643692330 -0300
+ @@ -1057,6 +1057,8 @@ manage(Window w, XWindowAttributes *wa)
+  	updatewindowtype(c);
+  	updatesizehints(c);
+  	updatewmhints(c);
+ +	c->x = c->mon->mx + (c->mon->mw - WIDTH(c)) / 2;
+ +	c->y = c->mon->my + (c->mon->mh - HEIGHT(c)) / 2;
+  	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
+  	grabbuttons(c, 0);
+  	if (!c->isfloating)
diff -crNb dwm-6.2/patches/dwm-attachbottom-6.2.diff dwm/patches/dwm-attachbottom-6.2.diff
*** dwm-6.2/patches/dwm-attachbottom-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-attachbottom-6.2.diff	2021-10-31 17:28:42.430188000 -0300
***************
*** 0 ****
--- 1,54 ----
+ diff -up dwm-6.2/dwm.c dwm-6.2-attachbottom/dwm.c
+ --- dwm-6.2/dwm.c	2019-02-02 13:55:28.000000000 +0100
+ +++ dwm-6.2-attachbottom/dwm.c	2020-12-27 10:43:35.956867775 +0100
+ @@ -147,6 +147,7 @@ static int applysizehints(Client *c, int
+  static void arrange(Monitor *m);
+  static void arrangemon(Monitor *m);
+  static void attach(Client *c);
+ +static void attachbottom(Client *c);
+  static void attachstack(Client *c);
+  static void buttonpress(XEvent *e);
+  static void checkotherwm(void);
+ @@ -407,6 +408,15 @@ attach(Client *c)
+  }
+  
+  void
+ +attachbottom(Client *c)
+ +{
+ +	Client **tc;
+ +	c->next = NULL;
+ +	for (tc = &c->mon->clients; *tc; tc = &(*tc)->next);
+ +	*tc = c;
+ +}
+ +
+ +void
+  attachstack(Client *c)
+  {
+  	c->snext = c->mon->stack;
+ @@ -1062,7 +1072,7 @@ manage(Window w, XWindowAttributes *wa)
+  		c->isfloating = c->oldstate = trans != None || c->isfixed;
+  	if (c->isfloating)
+  		XRaiseWindow(dpy, c->win);
+ -	attach(c);
+ +	attachbottom(c);
+  	attachstack(c);
+  	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
+  		(unsigned char *) &(c->win), 1);
+ @@ -1417,7 +1427,7 @@ sendmon(Client *c, Monitor *m)
+  	detachstack(c);
+  	c->mon = m;
+  	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+ -	attach(c);
+ +	attachbottom(c);
+  	attachstack(c);
+  	focus(NULL);
+  	arrange(NULL);
+ @@ -1897,7 +1907,7 @@ updategeom(void)
+  					m->clients = c->next;
+  					detachstack(c);
+  					c->mon = mons;
+ -					attach(c);
+ +					attachbottom(c);
+  					attachstack(c);
+  				}
+  				if (m == selmon)
diff -crNb dwm-6.2/patches/dwm-autostart-20210120-cb3f58a.diff dwm/patches/dwm-autostart-20210120-cb3f58a.diff
*** dwm-6.2/patches/dwm-autostart-20210120-cb3f58a.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-autostart-20210120-cb3f58a.diff	2021-10-31 17:28:42.431188007 -0300
***************
*** 0 ****
--- 1,179 ----
+ From 37e970479dc5d40e57fc0cbfeaa5e39941483237 Mon Sep 17 00:00:00 2001
+ From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
+ Date: Wed, 10 Jun 2020 10:59:02 +0000
+ Subject: [PATCH] dwm-xdgautostart-6.2.diff
+ 
+ ===================================================================
+ ---
+  dwm.1 | 23 +++++++++++++++++
+  dwm.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  2 files changed, 105 insertions(+)
+ 
+ diff --git a/dwm.1 b/dwm.1
+ index 13b3729..9533aa6 100644
+ --- a/dwm.1
+ +++ b/dwm.1
+ @@ -30,6 +30,14 @@ top left corner.  The tags which are applied to one or more windows are
+  indicated with an empty square in the top left corner.
+  .P
+  dwm draws a small border around windows to indicate the focus state.
+ +.P
+ +On start, dwm can start additional programs that may be specified in two special
+ +shell scripts (see the FILES section below), autostart_blocking.sh and
+ +autostart.sh.  The former is executed first and dwm will wait for its
+ +termination before starting.  The latter is executed in the background before
+ +dwm enters its handler loop.
+ +.P
+ +Either of these files may be omitted.
+  .SH OPTIONS
+  .TP
+  .B \-v
+ @@ -152,6 +160,21 @@ Toggles focused window between floating and tiled state.
+  .TP
+  .B Mod1\-Button3
+  Resize focused window while dragging. Tiled windows will be toggled to the floating state.
+ +.SH FILES
+ +The files containing programs to be started along with dwm are searched for in
+ +the following directories:
+ +.IP "1. $XDG_DATA_HOME/dwm"
+ +.IP "2. $HOME/.local/share/dwm"
+ +.IP "3. $HOME/.dwm"
+ +.P
+ +The first existing directory is scanned for any of the autostart files below.
+ +.TP 15
+ +autostart.sh
+ +This file is started as a shell background process before dwm enters its handler
+ +loop.
+ +.TP 15
+ +autostart_blocking.sh
+ +This file is started before any autostart.sh; dwm waits for its termination.
+  .SH CUSTOMIZATION
+  dwm is customized by creating a custom config.h and (re)compiling the source
+  code. This keeps it fast, secure and simple.
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..2156b49 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -29,6 +29,7 @@
+  #include <string.h>
+  #include <unistd.h>
+  #include <sys/types.h>
+ +#include <sys/stat.h>
+  #include <sys/wait.h>
+  #include <X11/cursorfont.h>
+  #include <X11/keysym.h>
+ @@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
+  static void resizemouse(const Arg *arg);
+  static void restack(Monitor *m);
+  static void run(void);
+ +static void runautostart(void);
+  static void scan(void);
+  static int sendevent(Client *c, Atom proto);
+  static void sendmon(Client *c, Monitor *m);
+ @@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
+  static void zoom(const Arg *arg);
+  
+  /* variables */
+ +static const char autostartblocksh[] = "autostart_blocking.sh";
+ +static const char autostartsh[] = "autostart.sh";
+  static const char broken[] = "broken";
+ +static const char dwmdir[] = "dwm";
+ +static const char localshare[] = ".local/share";
+  static char stext[256];
+  static int screen;
+  static int sw, sh;           /* X display screen geometry width, height */
+ @@ -1380,6 +1386,83 @@ run(void)
+  			handler[ev.type](&ev); /* call handler */
+  }
+  
+ +void
+ +runautostart(void)
+ +{
+ +	char *pathpfx;
+ +	char *path;
+ +	char *xdgdatahome;
+ +	char *home;
+ +	struct stat sb;
+ +
+ +	if ((home = getenv("HOME")) == NULL)
+ +		/* this is almost impossible */
+ +		return;
+ +
+ +	/* if $XDG_DATA_HOME is set and not empty, use $XDG_DATA_HOME/dwm,
+ +	 * otherwise use ~/.local/share/dwm as autostart script directory
+ +	 */
+ +	xdgdatahome = getenv("XDG_DATA_HOME");
+ +	if (xdgdatahome != NULL && *xdgdatahome != '\0') {
+ +		/* space for path segments, separators and nul */
+ +		pathpfx = ecalloc(1, strlen(xdgdatahome) + strlen(dwmdir) + 2);
+ +
+ +		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+ +			free(pathpfx);
+ +			return;
+ +		}
+ +	} else {
+ +		/* space for path segments, separators and nul */
+ +		pathpfx = ecalloc(1, strlen(home) + strlen(localshare)
+ +		                     + strlen(dwmdir) + 3);
+ +
+ +		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+ +			free(pathpfx);
+ +			return;
+ +		}
+ +	}
+ +
+ +	/* check if the autostart script directory exists */
+ +	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+ +		/* the XDG conformant path does not exist or is no directory
+ +		 * so we try ~/.dwm instead
+ +		 */
+ +		char *pathpfx_new = realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3);
+ +		if(pathpfx_new == NULL) {
+ +			free(pathpfx);
+ +			return;
+ +		}
+ +		pathpfx = pathpfx_new;
+ +
+ +		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+ +			free(pathpfx);
+ +			return;
+ +		}
+ +	}
+ +
+ +	/* try the blocking script first */
+ +	path = ecalloc(1, strlen(pathpfx) + strlen(autostartblocksh) + 2);
+ +	if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+ +		free(path);
+ +		free(pathpfx);
+ +	}
+ +
+ +	if (access(path, X_OK) == 0)
+ +		system(path);
+ +
+ +	/* now the non-blocking script */
+ +	if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+ +		free(path);
+ +		free(pathpfx);
+ +	}
+ +
+ +	if (access(path, X_OK) == 0)
+ +		system(strcat(path, " &"));
+ +
+ +	free(pathpfx);
+ +	free(path);
+ +}
+ +
+  void
+  scan(void)
+  {
+ @@ -2142,6 +2223,7 @@ main(int argc, char *argv[])
+  		die("pledge");
+  #endif /* __OpenBSD__ */
+  	scan();
+ +	runautostart();
+  	run();
+  	cleanup();
+  	XCloseDisplay(dpy);
+ -- 
+ 2.27.0
+ 
diff -crNb dwm-6.2/patches/dwm-centeredmaster-6.1.diff dwm/patches/dwm-centeredmaster-6.1.diff
*** dwm-6.2/patches/dwm-centeredmaster-6.1.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-centeredmaster-6.1.diff	2021-10-31 17:28:42.431188007 -0300
***************
*** 0 ****
--- 1,142 ----
+ diff --git a/config.def.h b/config.def.h
+ index 7054c06..527b214 100644
+ --- a/config.def.h
+ +++ b/config.def.h
+ @@ -39,6 +39,8 @@ static const Layout layouts[] = {
+  	{ "[]=",      tile },    /* first entry is default */
+  	{ "><>",      NULL },    /* no layout function means floating behavior */
+  	{ "[M]",      monocle },
+ +	{ "|M|",      centeredmaster },
+ +	{ ">M>",      centeredfloatingmaster },
+  };
+  
+  /* key definitions */
+ @@ -74,6 +76,8 @@ static Key keys[] = {
+  	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
+  	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
+  	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+ +	{ MODKEY,                       XK_u,      setlayout,      {.v = &layouts[3]} },
+ +	{ MODKEY,                       XK_o,      setlayout,      {.v = &layouts[4]} },
+  	{ MODKEY,                       XK_space,  setlayout,      {0} },
+  	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
+  	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
+ diff --git a/dwm.c b/dwm.c
+ index 0362114..1e81412 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -233,6 +233,8 @@ static int xerror(Display *dpy, XErrorEvent *ee);
+  static int xerrordummy(Display *dpy, XErrorEvent *ee);
+  static int xerrorstart(Display *dpy, XErrorEvent *ee);
+  static void zoom(const Arg *arg);
+ +static void centeredmaster(Monitor *m);
+ +static void centeredfloatingmaster(Monitor *m);
+  
+  /* variables */
+  static const char broken[] = "broken";
+ @@ -2139,3 +2141,106 @@ main(int argc, char *argv[])
+  	XCloseDisplay(dpy);
+  	return EXIT_SUCCESS;
+  }
+ +
+ +void
+ +centeredmaster(Monitor *m)
+ +{
+ +	unsigned int i, n, h, mw, mx, my, oty, ety, tw;
+ +	Client *c;
+ +
+ +	/* count number of clients in the selected monitor */
+ +	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ +	if (n == 0)
+ +		return;
+ +
+ +	/* initialize areas */
+ +	mw = m->ww;
+ +	mx = 0;
+ +	my = 0;
+ +	tw = mw;
+ +
+ +	if (n > m->nmaster) {
+ +		/* go mfact box in the center if more than nmaster clients */
+ +		mw = m->nmaster ? m->ww * m->mfact : 0;
+ +		tw = m->ww - mw;
+ +
+ +		if (n - m->nmaster > 1) {
+ +			/* only one client */
+ +			mx = (m->ww - mw) / 2;
+ +			tw = (m->ww - mw) / 2;
+ +		}
+ +	}
+ +
+ +	oty = 0;
+ +	ety = 0;
+ +	for (i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ +	if (i < m->nmaster) {
+ +		/* nmaster clients are stacked vertically, in the center
+ +		 * of the screen */
+ +		h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+ +		resize(c, m->wx + mx, m->wy + my, mw - (2*c->bw),
+ +		       h - (2*c->bw), 0);
+ +		my += HEIGHT(c);
+ +	} else {
+ +		/* stack clients are stacked vertically */
+ +		if ((i - m->nmaster) % 2 ) {
+ +			h = (m->wh - ety) / ( (1 + n - i) / 2);
+ +			resize(c, m->wx, m->wy + ety, tw - (2*c->bw),
+ +			       h - (2*c->bw), 0);
+ +			ety += HEIGHT(c);
+ +		} else {
+ +			h = (m->wh - oty) / ((1 + n - i) / 2);
+ +			resize(c, m->wx + mx + mw, m->wy + oty,
+ +			       tw - (2*c->bw), h - (2*c->bw), 0);
+ +			oty += HEIGHT(c);
+ +		}
+ +	}
+ +}
+ +
+ +void
+ +centeredfloatingmaster(Monitor *m)
+ +{
+ +	unsigned int i, n, w, mh, mw, mx, mxo, my, myo, tx;
+ +	Client *c;
+ +
+ +	/* count number of clients in the selected monitor */
+ +	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
+ +	if (n == 0)
+ +		return;
+ +
+ +	/* initialize nmaster area */
+ +	if (n > m->nmaster) {
+ +		/* go mfact box in the center if more than nmaster clients */
+ +		if (m->ww > m->wh) {
+ +			mw = m->nmaster ? m->ww * m->mfact : 0;
+ +			mh = m->nmaster ? m->wh * 0.9 : 0;
+ +		} else {
+ +			mh = m->nmaster ? m->wh * m->mfact : 0;
+ +			mw = m->nmaster ? m->ww * 0.9 : 0;
+ +		}
+ +		mx = mxo = (m->ww - mw) / 2;
+ +		my = myo = (m->wh - mh) / 2;
+ +	} else {
+ +		/* go fullscreen if all clients are in the master area */
+ +		mh = m->wh;
+ +		mw = m->ww;
+ +		mx = mxo = 0;
+ +		my = myo = 0;
+ +	}
+ +
+ +	for(i = tx = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ +	if (i < m->nmaster) {
+ +		/* nmaster clients are stacked horizontally, in the center
+ +		 * of the screen */
+ +		w = (mw + mxo - mx) / (MIN(n, m->nmaster) - i);
+ +		resize(c, m->wx + mx, m->wy + my, w - (2*c->bw),
+ +		       mh - (2*c->bw), 0);
+ +		mx += WIDTH(c);
+ +	} else {
+ +		/* stack clients are stacked horizontally */
+ +		w = (m->ww - tx) / (n - i);
+ +		resize(c, m->wx + tx, m->wy, w - (2*c->bw),
+ +		       m->wh - (2*c->bw), 0);
+ +		tx += WIDTH(c);
+ +	}
+ +}
diff -crNb dwm-6.2/patches/dwm-centeredwindowname-20180909-6.2.diff dwm/patches/dwm-centeredwindowname-20180909-6.2.diff
*** dwm-6.2/patches/dwm-centeredwindowname-20180909-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-centeredwindowname-20180909-6.2.diff	2021-10-31 17:28:42.431188007 -0300
***************
*** 0 ****
--- 1,27 ----
+ From bd6efd81eabab77c91a3e95b528b19db2d58525b Mon Sep 17 00:00:00 2001
+ From: Sacules <leociancalucas@gmail.com>
+ Date: Sun, 9 Sep 2018 17:12:58 -0300
+ Subject: [PATCH] Centers windows names on status bar.
+ 
+ ---
+  dwm.c | 3 ++-
+  1 file changed, 2 insertions(+), 1 deletion(-)
+ 
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..9d5ef7a 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -730,8 +730,9 @@ drawbar(Monitor *m)
+  
+  	if ((w = m->ww - sw - x) > bh) {
+  		if (m->sel) {
+ +			int mid = (m->ww - TEXTW(m->sel->name)) / 2 - x;
+  			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+ -			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+ +			drw_text(drw, x, 0, w, bh, mid, m->sel->name, 0);
+  			if (m->sel->isfloating)
+  				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+  		} else {
+ -- 
+ 2.18.0
+ 
diff -crNb dwm-6.2/patches/dwm-fullgaps-6.2.diff dwm/patches/dwm-fullgaps-6.2.diff
*** dwm-6.2/patches/dwm-fullgaps-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-fullgaps-6.2.diff	2021-10-31 17:28:42.432188015 -0300
***************
*** 0 ****
--- 1,95 ----
+ diff --git a/config.def.h b/config.def.h
+ index 1c0b587..38d2f6c 100644
+ --- a/config.def.h
+ +++ b/config.def.h
+ @@ -2,6 +2,7 @@
+  
+  /* appearance */
+  static const unsigned int borderpx  = 1;        /* border pixel of windows */
+ +static const unsigned int gappx     = 5;        /* gaps between windows */
+  static const unsigned int snap      = 32;       /* snap pixel */
+  static const int showbar            = 1;        /* 0 means no bar */
+  static const int topbar             = 1;        /* 0 means bottom bar */
+ @@ -84,6 +85,9 @@ static Key keys[] = {
+  	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+  	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+  	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+ +	{ MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
+ +	{ MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
+ +	{ MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
+  	TAGKEYS(                        XK_1,                      0)
+  	TAGKEYS(                        XK_2,                      1)
+  	TAGKEYS(                        XK_3,                      2)
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..4363627 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -119,6 +119,7 @@ struct Monitor {
+  	int by;               /* bar geometry */
+  	int mx, my, mw, mh;   /* screen size */
+  	int wx, wy, ww, wh;   /* window area  */
+ +	int gappx;            /* gaps between windows */
+  	unsigned int seltags;
+  	unsigned int sellt;
+  	unsigned int tagset[2];
+ @@ -199,6 +200,7 @@ static void sendmon(Client *c, Monitor *m);
+  static void setclientstate(Client *c, long state);
+  static void setfocus(Client *c);
+  static void setfullscreen(Client *c, int fullscreen);
+ +static void setgaps(const Arg *arg);
+  static void setlayout(const Arg *arg);
+  static void setmfact(const Arg *arg);
+  static void setup(void);
+ @@ -638,6 +640,7 @@ createmon(void)
+  	m->nmaster = nmaster;
+  	m->showbar = showbar;
+  	m->topbar = topbar;
+ +	m->gappx = gappx;
+  	m->lt[0] = &layouts[0];
+  	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+  	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+ @@ -1497,6 +1500,16 @@ setfullscreen(Client *c, int fullscreen)
+  	}
+  }
+  
+ +void
+ +setgaps(const Arg *arg)
+ +{
+ +	if ((arg->i == 0) || (selmon->gappx + arg->i < 0))
+ +		selmon->gappx = 0;
+ +	else
+ +		selmon->gappx += arg->i;
+ +	arrange(selmon);
+ +}
+ +
+  void
+  setlayout(const Arg *arg)
+  {
+ @@ -1683,16 +1696,16 @@ tile(Monitor *m)
+  	if (n > m->nmaster)
+  		mw = m->nmaster ? m->ww * m->mfact : 0;
+  	else
+ -		mw = m->ww;
+ -	for (i = my = ty = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+ +		mw = m->ww - m->gappx;
+ +	for (i = 0, my = ty = m->gappx, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
+  		if (i < m->nmaster) {
+ -			h = (m->wh - my) / (MIN(n, m->nmaster) - i);
+ -			resize(c, m->wx, m->wy + my, mw - (2*c->bw), h - (2*c->bw), 0);
+ -			my += HEIGHT(c);
+ +			h = (m->wh - my) / (MIN(n, m->nmaster) - i) - m->gappx;
+ +			resize(c, m->wx + m->gappx, m->wy + my, mw - (2*c->bw) - m->gappx, h - (2*c->bw), 0);
+ +			my += HEIGHT(c) + m->gappx;
+  		} else {
+ -			h = (m->wh - ty) / (n - i);
+ -			resize(c, m->wx + mw, m->wy + ty, m->ww - mw - (2*c->bw), h - (2*c->bw), 0);
+ -			ty += HEIGHT(c);
+ +			h = (m->wh - ty) / (n - i) - m->gappx;
+ +			resize(c, m->wx + mw + m->gappx, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappx, h - (2*c->bw), 0);
+ +			ty += HEIGHT(c) + m->gappx;
+  		}
+  }
+  
+ -- 
+ 2.20.1
+ 
diff -crNb dwm-6.2/patches/dwm-hide_vacant_tags-6.2.diff dwm/patches/dwm-hide_vacant_tags-6.2.diff
*** dwm-6.2/patches/dwm-hide_vacant_tags-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-hide_vacant_tags-6.2.diff	2021-10-31 17:28:42.432188015 -0300
***************
*** 0 ****
--- 1,55 ----
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..c4aa3de 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -416,7 +416,7 @@ attachstack(Client *c)
+  void
+  buttonpress(XEvent *e)
+  {
+ -	unsigned int i, x, click;
+ +	unsigned int i, x, click, occ = 0;
+  	Arg arg = {0};
+  	Client *c;
+  	Monitor *m;
+ @@ -431,9 +431,14 @@ buttonpress(XEvent *e)
+  	}
+  	if (ev->window == selmon->barwin) {
+  		i = x = 0;
+ -		do
+ +		for (c = m->clients; c; c = c->next)
+ +			occ |= c->tags == 255 ? 0 : c->tags;
+ +		do {
+ +			/* do not reserve space for vacant tags */
+ +			if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+ +				continue;
+  			x += TEXTW(tags[i]);
+ -		while (ev->x >= x && ++i < LENGTH(tags));
+ +		} while (ev->x >= x && ++i < LENGTH(tags));
+  		if (i < LENGTH(tags)) {
+  			click = ClkTagBar;
+  			arg.ui = 1 << i;
+ @@ -709,19 +714,19 @@ drawbar(Monitor *m)
+  	}
+  
+  	for (c = m->clients; c; c = c->next) {
+ -		occ |= c->tags;
+ +		occ |= c->tags == 255 ? 0 : c->tags;
+  		if (c->isurgent)
+  			urg |= c->tags;
+  	}
+  	x = 0;
+  	for (i = 0; i < LENGTH(tags); i++) {
+ +		/* do not draw vacant tags */
+ +		if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i))
+ +		continue;
+ +
+  		w = TEXTW(tags[i]);
+  		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+  		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i);
+ -		if (occ & 1 << i)
+ -			drw_rect(drw, x + boxs, boxs, boxw, boxw,
+ -				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
+ -				urg & 1 << i);
+  		x += w;
+  	}
+  	w = blw = TEXTW(m->ltsymbol);
diff -crNb dwm-6.2/patches/dwm-movestack-6.1.diff dwm/patches/dwm-movestack-6.1.diff
*** dwm-6.2/patches/dwm-movestack-6.1.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-movestack-6.1.diff	2021-10-31 17:28:42.432188015 -0300
***************
*** 0 ****
--- 1,73 ----
+ diff -r 050d521d66d8 config.def.h
+ --- a/config.def.h	Tue Aug 24 13:13:20 2010 +0100
+ +++ b/config.def.h	Sun Sep 05 18:43:07 2010 +0200
+ @@ -57,6 +57,7 @@
+  static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", normbgcolor, "-nf", normfgcolor, "-sb", selbgcolor, "-sf", selfgcolor, NULL };
+  static const char *termcmd[]  = { "st", NULL };
+  
+ +#include "movestack.c"
+  static Key keys[] = {
+  	/* modifier                     key        function        argument */
+  	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ @@ -68,6 +69,8 @@
+  	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+  	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
+  	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+ +	{ MODKEY|ShiftMask,             XK_j,      movestack,      {.i = +1 } },
+ +	{ MODKEY|ShiftMask,             XK_k,      movestack,      {.i = -1 } },
+  	{ MODKEY,                       XK_Return, zoom,           {0} },
+  	{ MODKEY,                       XK_Tab,    view,           {0} },
+  	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+ diff -r 050d521d66d8 movestack.c
+ --- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+ +++ b/movestack.c	Sun Sep 05 18:43:07 2010 +0200
+ @@ -0,0 +1,49 @@
+ +void
+ +movestack(const Arg *arg) {
+ +	Client *c = NULL, *p = NULL, *pc = NULL, *i;
+ +
+ +	if(arg->i > 0) {
+ +		/* find the client after selmon->sel */
+ +		for(c = selmon->sel->next; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+ +		if(!c)
+ +			for(c = selmon->clients; c && (!ISVISIBLE(c) || c->isfloating); c = c->next);
+ +
+ +	}
+ +	else {
+ +		/* find the client before selmon->sel */
+ +		for(i = selmon->clients; i != selmon->sel; i = i->next)
+ +			if(ISVISIBLE(i) && !i->isfloating)
+ +				c = i;
+ +		if(!c)
+ +			for(; i; i = i->next)
+ +				if(ISVISIBLE(i) && !i->isfloating)
+ +					c = i;
+ +	}
+ +	/* find the client before selmon->sel and c */
+ +	for(i = selmon->clients; i && (!p || !pc); i = i->next) {
+ +		if(i->next == selmon->sel)
+ +			p = i;
+ +		if(i->next == c)
+ +			pc = i;
+ +	}
+ +
+ +	/* swap c and selmon->sel selmon->clients in the selmon->clients list */
+ +	if(c && c != selmon->sel) {
+ +		Client *temp = selmon->sel->next==c?selmon->sel:selmon->sel->next;
+ +		selmon->sel->next = c->next==selmon->sel?c:c->next;
+ +		c->next = temp;
+ +
+ +		if(p && p != c)
+ +			p->next = c;
+ +		if(pc && pc != selmon->sel)
+ +			pc->next = selmon->sel;
+ +
+ +		if(selmon->sel == selmon->clients)
+ +			selmon->clients = c;
+ +		else if(c == selmon->clients)
+ +			selmon->clients = selmon->sel;
+ +
+ +		arrange(selmon);
+ +	}
+ +}
+ +
diff -crNb dwm-6.2/patches/dwm-pertag-6.2.diff dwm/patches/dwm-pertag-6.2.diff
*** dwm-6.2/patches/dwm-pertag-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-pertag-6.2.diff	2021-10-31 17:28:42.433188022 -0300
***************
*** 0 ****
--- 1,177 ----
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..6474055 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -111,6 +111,7 @@ typedef struct {
+  	void (*arrange)(Monitor *);
+  } Layout;
+  
+ +typedef struct Pertag Pertag;
+  struct Monitor {
+  	char ltsymbol[16];
+  	float mfact;
+ @@ -130,6 +131,7 @@ struct Monitor {
+  	Monitor *next;
+  	Window barwin;
+  	const Layout *lt[2];
+ +	Pertag *pertag;
+  };
+  
+  typedef struct {
+ @@ -271,6 +273,15 @@ static Window root, wmcheckwin;
+  /* configuration, allows nested code to access above variables */
+  #include "config.h"
+  
+ +struct Pertag {
+ +	unsigned int curtag, prevtag; /* current and previous tag */
+ +	int nmasters[LENGTH(tags) + 1]; /* number of windows in master area */
+ +	float mfacts[LENGTH(tags) + 1]; /* mfacts per tag */
+ +	unsigned int sellts[LENGTH(tags) + 1]; /* selected layouts */
+ +	const Layout *ltidxs[LENGTH(tags) + 1][2]; /* matrix of tags and layouts indexes  */
+ +	int showbars[LENGTH(tags) + 1]; /* display bar for the current tag */
+ +};
+ +
+  /* compile-time check if all tags fit into an unsigned int bit array. */
+  struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+  
+ @@ -631,6 +642,7 @@ Monitor *
+  createmon(void)
+  {
+  	Monitor *m;
+ +	unsigned int i;
+  
+  	m = ecalloc(1, sizeof(Monitor));
+  	m->tagset[0] = m->tagset[1] = 1;
+ @@ -641,6 +653,20 @@ createmon(void)
+  	m->lt[0] = &layouts[0];
+  	m->lt[1] = &layouts[1 % LENGTH(layouts)];
+  	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+ +	m->pertag = ecalloc(1, sizeof(Pertag));
+ +	m->pertag->curtag = m->pertag->prevtag = 1;
+ +
+ +	for (i = 0; i <= LENGTH(tags); i++) {
+ +		m->pertag->nmasters[i] = m->nmaster;
+ +		m->pertag->mfacts[i] = m->mfact;
+ +
+ +		m->pertag->ltidxs[i][0] = m->lt[0];
+ +		m->pertag->ltidxs[i][1] = m->lt[1];
+ +		m->pertag->sellts[i] = m->sellt;
+ +
+ +		m->pertag->showbars[i] = m->showbar;
+ +	}
+ +
+  	return m;
+  }
+  
+ @@ -966,7 +992,7 @@ grabkeys(void)
+  void
+  incnmaster(const Arg *arg)
+  {
+ -	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+ +	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+  	arrange(selmon);
+  }
+  
+ @@ -1501,9 +1527,9 @@ void
+  setlayout(const Arg *arg)
+  {
+  	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+ -		selmon->sellt ^= 1;
+ +		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
+  	if (arg && arg->v)
+ -		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+ +		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+  	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
+  	if (selmon->sel)
+  		arrange(selmon);
+ @@ -1522,7 +1548,7 @@ setmfact(const Arg *arg)
+  	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+  	if (f < 0.1 || f > 0.9)
+  		return;
+ -	selmon->mfact = f;
+ +	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+  	arrange(selmon);
+  }
+  
+ @@ -1699,7 +1725,7 @@ tile(Monitor *m)
+  void
+  togglebar(const Arg *arg)
+  {
+ -	selmon->showbar = !selmon->showbar;
+ +	selmon->showbar = selmon->pertag->showbars[selmon->pertag->curtag] = !selmon->showbar;
+  	updatebarpos(selmon);
+  	XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
+  	arrange(selmon);
+ @@ -1738,9 +1764,33 @@ void
+  toggleview(const Arg *arg)
+  {
+  	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+ +	int i;
+  
+  	if (newtagset) {
+  		selmon->tagset[selmon->seltags] = newtagset;
+ +
+ +		if (newtagset == ~0) {
+ +			selmon->pertag->prevtag = selmon->pertag->curtag;
+ +			selmon->pertag->curtag = 0;
+ +		}
+ +
+ +		/* test if the user did not select the same tag */
+ +		if (!(newtagset & 1 << (selmon->pertag->curtag - 1))) {
+ +			selmon->pertag->prevtag = selmon->pertag->curtag;
+ +			for (i = 0; !(newtagset & 1 << i); i++) ;
+ +			selmon->pertag->curtag = i + 1;
+ +		}
+ +
+ +		/* apply settings for this view */
+ +		selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ +		selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ +		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ +		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ +		selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ +
+ +		if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ +			togglebar(NULL);
+ +
+  		focus(NULL);
+  		arrange(selmon);
+  	}
+ @@ -2035,11 +2085,37 @@ updatewmhints(Client *c)
+  void
+  view(const Arg *arg)
+  {
+ +	int i;
+ +	unsigned int tmptag;
+ +
+  	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+  		return;
+  	selmon->seltags ^= 1; /* toggle sel tagset */
+ -	if (arg->ui & TAGMASK)
+ +	if (arg->ui & TAGMASK) {
+  		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+ +		selmon->pertag->prevtag = selmon->pertag->curtag;
+ +
+ +		if (arg->ui == ~0)
+ +			selmon->pertag->curtag = 0;
+ +		else {
+ +			for (i = 0; !(arg->ui & 1 << i); i++) ;
+ +			selmon->pertag->curtag = i + 1;
+ +		}
+ +	} else {
+ +		tmptag = selmon->pertag->prevtag;
+ +		selmon->pertag->prevtag = selmon->pertag->curtag;
+ +		selmon->pertag->curtag = tmptag;
+ +	}
+ +
+ +	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag];
+ +	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag];
+ +	selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag];
+ +	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
+ +	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
+ +
+ +	if (selmon->showbar != selmon->pertag->showbars[selmon->pertag->curtag])
+ +		togglebar(NULL);
+ +
+  	focus(NULL);
+  	arrange(selmon);
+  }
diff -crNb dwm-6.2/patches/dwm-scratchpads-20200414-728d397b.diff dwm/patches/dwm-scratchpads-20200414-728d397b.diff
*** dwm-6.2/patches/dwm-scratchpads-20200414-728d397b.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-scratchpads-20200414-728d397b.diff	2021-10-31 17:28:42.433188022 -0300
***************
*** 0 ****
--- 1,199 ----
+ From 728d397b21982af88737277fd9d6939a7b558786 Mon Sep 17 00:00:00 2001
+ From: Christian Tenllado <ctenllado@gmail.com>
+ Date: Tue, 14 Apr 2020 23:31:15 +0200
+ Subject: [PATCH] Multiple scratchpads
+ 
+ This patch enables multiple scratchpads, each with one asigned window.
+ This enables the same scratchpad workflow that you have in i3.
+ 
+ Scratchpads are implemented as special tags, whose mask does not
+ apply to new spawned windows. To assign a window to a scratchpad you
+ have to set up a rule, as you do with regular tags.
+ 
+ Windows tagged with scratchpad tags can be set floating or not in the
+ rules array. Most users would probably want them floating (i3 style),
+ but having them tiled does also perfectly work and might fit better the
+ DWM approach. In case they are set floating, the patch moves them to the
+ center of the screen whenever they are shown. The patch can easily be
+ modified to make this last feature configurable in the rules array (see
+ the center patch).
+ 
+ The togglescratch function, borrowed from the previous scratchpad patch
+ and slightly modified, can be used to spawn a registered scratchpad
+ process or toggle its view. This function looks for a window tagged with
+ the selected scratchpad tag. If it is found its view is toggled. If it is
+ not found the corresponding registered command is spawned. The
+ config.def.h shows three examples of its use to spawn a terminal in the
+ first scratchpad tag, a second terminal running ranger on the second
+ scratchpad tag and the keepassxc application to manage passwords on a
+ third scratchpad tag.
+ 
+ If you prefer to spawn your scratchpad applications from the startup
+ script, you might opt for binding keys to toggleview instead, as
+ scratchpads are just special tags (you may even extend the TAGKEYS macro
+ to generalize the key bindings).
+ ---
+  config.def.h | 28 ++++++++++++++++++++++++----
+  dwm.c        | 43 +++++++++++++++++++++++++++++++++++++++++--
+  2 files changed, 65 insertions(+), 6 deletions(-)
+ 
+ diff --git a/config.def.h b/config.def.h
+ index 1c0b587..06265e1 100644
+ --- a/config.def.h
+ +++ b/config.def.h
+ @@ -18,17 +18,33 @@ static const char *colors[][3]      = {
+  	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+  };
+  
+ +typedef struct {
+ +	const char *name;
+ +	const void *cmd;
+ +} Sp;
+ +const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL };
+ +const char *spcmd2[] = {"st", "-n", "spfm", "-g", "144x41", "-e", "ranger", NULL };
+ +const char *spcmd3[] = {"keepassxc", NULL };
+ +static Sp scratchpads[] = {
+ +	/* name          cmd  */
+ +	{"spterm",      spcmd1},
+ +	{"spranger",    spcmd2},
+ +	{"keepassxc",   spcmd3},
+ +};
+ +
+  /* tagging */
+  static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
+ -
+  static const Rule rules[] = {
+  	/* xprop(1):
+  	 *	WM_CLASS(STRING) = instance, class
+  	 *	WM_NAME(STRING) = title
+  	 */
+  	/* class      instance    title       tags mask     isfloating   monitor */
+ -	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
+ -	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+ +	{ "Gimp",	  NULL,			NULL,		0,				1,			 -1 },
+ +	{ "Firefox",  NULL,			NULL,		1 << 8,			0,			 -1 },
+ +	{ NULL,		  "spterm",		NULL,		SPTAG(0),		1,			 -1 },
+ +	{ NULL,		  "spfm",		NULL,		SPTAG(1),		1,			 -1 },
+ +	{ NULL,		  "keepassxc",	NULL,		SPTAG(2),		0,			 -1 },
+  };
+  
+  /* layout(s) */
+ @@ -59,6 +75,7 @@ static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn()
+  static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+  static const char *termcmd[]  = { "st", NULL };
+  
+ +
+  static Key keys[] = {
+  	/* modifier                     key        function        argument */
+  	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
+ @@ -84,6 +101,9 @@ static Key keys[] = {
+  	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
+  	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
+  	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
+ +	{ MODKEY,            			XK_y,  	   togglescratch,  {.ui = 0 } },
+ +	{ MODKEY,            			XK_u,	   togglescratch,  {.ui = 1 } },
+ +	{ MODKEY,            			XK_x,	   togglescratch,  {.ui = 2 } },
+  	TAGKEYS(                        XK_1,                      0)
+  	TAGKEYS(                        XK_2,                      1)
+  	TAGKEYS(                        XK_3,                      2)
+ @@ -106,7 +126,7 @@ static Button buttons[] = {
+  	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
+  	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
+  	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
+ -	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
+ +	{ ClkClientWin,         MODKEY,         Button1,        resizemouse,    {0} },
+  	{ ClkTagBar,            0,              Button1,        view,           {0} },
+  	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
+  	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..646aa1a 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -54,7 +54,10 @@
+  #define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
+  #define WIDTH(X)                ((X)->w + 2 * (X)->bw)
+  #define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
+ -#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
+ +#define NUMTAGS					(LENGTH(tags) + LENGTH(scratchpads))
+ +#define TAGMASK     			((1 << NUMTAGS) - 1)
+ +#define SPTAG(i) 				((1 << LENGTH(tags)) << (i))
+ +#define SPTAGMASK   			(((1 << LENGTH(scratchpads))-1) << LENGTH(tags))
+  #define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
+  
+  /* enums */
+ @@ -211,6 +214,7 @@ static void tagmon(const Arg *arg);
+  static void tile(Monitor *);
+  static void togglebar(const Arg *arg);
+  static void togglefloating(const Arg *arg);
+ +static void togglescratch(const Arg *arg);
+  static void toggletag(const Arg *arg);
+  static void toggleview(const Arg *arg);
+  static void unfocus(Client *c, int setfocus);
+ @@ -299,6 +303,11 @@ applyrules(Client *c)
+  		{
+  			c->isfloating = r->isfloating;
+  			c->tags |= r->tags;
+ +			if ((r->tags & SPTAGMASK) && r->isfloating) {
+ +				c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+ +				c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+ +			}
+ +
+  			for (m = mons; m && m->num != r->monitor; m = m->next);
+  			if (m)
+  				c->mon = m;
+ @@ -308,7 +317,7 @@ applyrules(Client *c)
+  		XFree(ch.res_class);
+  	if (ch.res_name)
+  		XFree(ch.res_name);
+ -	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+ +	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : (c->mon->tagset[c->mon->seltags] & ~SPTAGMASK);
+  }
+  
+  int
+ @@ -1616,6 +1625,10 @@ showhide(Client *c)
+  	if (!c)
+  		return;
+  	if (ISVISIBLE(c)) {
+ +		if ((c->tags & SPTAGMASK) && c->isfloating) {
+ +			c->x = c->mon->wx + (c->mon->ww / 2 - WIDTH(c) / 2);
+ +			c->y = c->mon->wy + (c->mon->wh / 2 - HEIGHT(c) / 2);
+ +		}
+  		/* show clients top down */
+  		XMoveWindow(dpy, c->win, c->x, c->y);
+  		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
+ @@ -1719,6 +1732,32 @@ togglefloating(const Arg *arg)
+  	arrange(selmon);
+  }
+  
+ +void
+ +togglescratch(const Arg *arg)
+ +{
+ +	Client *c;
+ +	unsigned int found = 0;
+ +	unsigned int scratchtag = SPTAG(arg->ui);
+ +	Arg sparg = {.v = scratchpads[arg->ui].cmd};
+ +
+ +	for (c = selmon->clients; c && !(found = c->tags & scratchtag); c = c->next);
+ +	if (found) {
+ +		unsigned int newtagset = selmon->tagset[selmon->seltags] ^ scratchtag;
+ +		if (newtagset) {
+ +			selmon->tagset[selmon->seltags] = newtagset;
+ +			focus(NULL);
+ +			arrange(selmon);
+ +		}
+ +		if (ISVISIBLE(c)) {
+ +			focus(c);
+ +			restack(selmon);
+ +		}
+ +	} else {
+ +		selmon->tagset[selmon->seltags] |= scratchtag;
+ +		spawn(&sparg);
+ +	}
+ +}
+ +
+  void
+  toggletag(const Arg *arg)
+  {
+ -- 
+ 2.20.1
+ 
diff -crNb dwm-6.2/patches/dwm-status2d-6.2.diff dwm/patches/dwm-status2d-6.2.diff
*** dwm-6.2/patches/dwm-status2d-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-status2d-6.2.diff	2021-10-31 17:28:42.433188022 -0300
***************
*** 0 ****
--- 1,166 ----
+ diff --git a/dwm.c b/dwm.c
+ index d27cb67..464c9d6 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -163,6 +163,7 @@ static void detach(Client *c);
+  static Monitor *dirtomon(int dir);
+  static void drawbar(Monitor *m);
+  static void drawbars(void);
+ +static int drawstatusbar(Monitor *m, int bh, char* text);
+  static void enternotify(XEvent *e);
+  static void expose(XEvent *e);
+  static void focus(Client *c);
+ @@ -237,7 +238,7 @@ static void zoom(const Arg *arg);
+  
+  /* variables */
+  static const char broken[] = "broken";
+ -static char stext[256];
+ +static char stext[1024];
+  static int screen;
+  static int sw, sh;           /* X display screen geometry width, height */
+  static int bh, blw = 0;      /* bar geometry */
+ @@ -483,7 +484,7 @@ cleanup(void)
+  		cleanupmon(mons);
+  	for (i = 0; i < CurLast; i++)
+  		drw_cur_free(drw, cursor[i]);
+ -	for (i = 0; i < LENGTH(colors); i++)
+ +	for (i = 0; i < LENGTH(colors) + 1; i++)
+  		free(scheme[i]);
+  	XDestroyWindow(dpy, wmcheckwin);
+  	drw_free(drw);
+ @@ -690,6 +691,114 @@ dirtomon(int dir)
+  	return m;
+  }
+  
+ +int
+ +drawstatusbar(Monitor *m, int bh, char* stext) {
+ +	int ret, i, w, x, len;
+ +	short isCode = 0;
+ +	char *text;
+ +	char *p;
+ +
+ +	len = strlen(stext) + 1 ;
+ +	if (!(text = (char*) malloc(sizeof(char)*len)))
+ +		die("malloc");
+ +	p = text;
+ +	memcpy(text, stext, len);
+ +
+ +	/* compute width of the status text */
+ +	w = 0;
+ +	i = -1;
+ +	while (text[++i]) {
+ +		if (text[i] == '^') {
+ +			if (!isCode) {
+ +				isCode = 1;
+ +				text[i] = '\0';
+ +				w += TEXTW(text) - lrpad;
+ +				text[i] = '^';
+ +				if (text[++i] == 'f')
+ +					w += atoi(text + ++i);
+ +			} else {
+ +				isCode = 0;
+ +				text = text + i + 1;
+ +				i = -1;
+ +			}
+ +		}
+ +	}
+ +	if (!isCode)
+ +		w += TEXTW(text) - lrpad;
+ +	else
+ +		isCode = 0;
+ +	text = p;
+ +
+ +	w += 2; /* 1px padding on both sides */
+ +	ret = x = m->ww - w;
+ +
+ +	drw_setscheme(drw, scheme[LENGTH(colors)]);
+ +	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ +	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+ +	drw_rect(drw, x, 0, w, bh, 1, 1);
+ +	x++;
+ +
+ +	/* process status text */
+ +	i = -1;
+ +	while (text[++i]) {
+ +		if (text[i] == '^' && !isCode) {
+ +			isCode = 1;
+ +
+ +			text[i] = '\0';
+ +			w = TEXTW(text) - lrpad;
+ +			drw_text(drw, x, 0, w, bh, 0, text, 0);
+ +
+ +			x += w;
+ +
+ +			/* process code */
+ +			while (text[++i] != '^') {
+ +				if (text[i] == 'c') {
+ +					char buf[8];
+ +					memcpy(buf, (char*)text+i+1, 7);
+ +					buf[7] = '\0';
+ +					drw_clr_create(drw, &drw->scheme[ColFg], buf);
+ +					i += 7;
+ +				} else if (text[i] == 'b') {
+ +					char buf[8];
+ +					memcpy(buf, (char*)text+i+1, 7);
+ +					buf[7] = '\0';
+ +					drw_clr_create(drw, &drw->scheme[ColBg], buf);
+ +					i += 7;
+ +				} else if (text[i] == 'd') {
+ +					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+ +					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+ +				} else if (text[i] == 'r') {
+ +					int rx = atoi(text + ++i);
+ +					while (text[++i] != ',');
+ +					int ry = atoi(text + ++i);
+ +					while (text[++i] != ',');
+ +					int rw = atoi(text + ++i);
+ +					while (text[++i] != ',');
+ +					int rh = atoi(text + ++i);
+ +
+ +					drw_rect(drw, rx + x, ry, rw, rh, 1, 0);
+ +				} else if (text[i] == 'f') {
+ +					x += atoi(text + ++i);
+ +				}
+ +			}
+ +
+ +			text = text + i + 1;
+ +			i=-1;
+ +			isCode = 0;
+ +		}
+ +	}
+ +
+ +	if (!isCode) {
+ +		w = TEXTW(text) - lrpad;
+ +		drw_text(drw, x, 0, w, bh, 0, text, 0);
+ +	}
+ +
+ +	drw_setscheme(drw, scheme[SchemeNorm]);
+ +	free(p);
+ +
+ +	return ret;
+ +}
+ +
+  void
+  drawbar(Monitor *m)
+  {
+ @@ -701,9 +802,7 @@ drawbar(Monitor *m)
+  
+  	/* draw status first so it can be overdrawn by tags later */
+  	if (m == selmon) { /* status is only drawn on selected monitor */
+ -		drw_setscheme(drw, scheme[SchemeNorm]);
+ -		sw = TEXTW(stext) - lrpad + 2; /* 2px right padding */
+ -		drw_text(drw, m->ww - sw, 0, sw, bh, 0, stext, 0);
+ +		sw = m->ww - drawstatusbar(m, bh, stext);
+  	}
+  
+  	for (c = m->clients; c; c = c->next) {
+ @@ -1572,7 +1671,8 @@ setup(void)
+  	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+  	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+  	/* init appearance */
+ -	scheme = ecalloc(LENGTH(colors), sizeof(Clr *));
+ +	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+ +	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+  	for (i = 0; i < LENGTH(colors); i++)
+  		scheme[i] = drw_scm_create(drw, colors[i], 3);
+  	/* init bars */
diff -crNb dwm-6.2/patches/dwm-titlecolor-20190206-6.2.diff dwm/patches/dwm-titlecolor-20190206-6.2.diff
*** dwm-6.2/patches/dwm-titlecolor-20190206-6.2.diff	1969-12-31 21:00:00.000000000 -0300
--- dwm/patches/dwm-titlecolor-20190206-6.2.diff	2021-10-31 17:28:42.434188030 -0300
***************
*** 0 ****
--- 1,47 ----
+ From b15016b717c88eb378d87703dcf2169b6059047c Mon Sep 17 00:00:00 2001
+ From: knary <theknary@gmail.com>
+ Date: Wed, 6 Feb 2019 21:44:19 -0500
+ Subject: [PATCH] Adds title bar color scheme, seperating it from SchemeSel.
+ 
+ ---
+  config.def.h | 1 +
+  dwm.c        | 4 ++--
+  2 files changed, 3 insertions(+), 2 deletions(-)
+ 
+ diff --git a/config.def.h b/config.def.h
+ index 1c0b587..48e7ace 100644
+ --- a/config.def.h
+ +++ b/config.def.h
+ @@ -16,6 +16,7 @@ static const char *colors[][3]      = {
+  	/*               fg         bg         border   */
+  	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
+  	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+ +	[SchemeTitle]  = { col_gray4, col_cyan,  col_cyan  },
+  };
+  
+  /* tagging */
+ diff --git a/dwm.c b/dwm.c
+ index 4465af1..216e1f3 100644
+ --- a/dwm.c
+ +++ b/dwm.c
+ @@ -59,7 +59,7 @@
+  
+  /* enums */
+  enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
+ -enum { SchemeNorm, SchemeSel }; /* color schemes */
+ +enum { SchemeNorm, SchemeSel, SchemeTitle }; /* color schemes */
+  enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
+         NetWMFullscreen, NetActiveWindow, NetWMWindowType,
+         NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+ @@ -730,7 +730,7 @@ drawbar(Monitor *m)
+  
+  	if ((w = m->ww - sw - x) > bh) {
+  		if (m->sel) {
+ -			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+ +			drw_setscheme(drw, scheme[m == selmon ? SchemeTitle : SchemeNorm]);
+  			drw_text(drw, x, 0, w, bh, lrpad / 2, m->sel->name, 0);
+  			if (m->sel->isfloating)
+  				drw_rect(drw, x + boxs, boxs, boxw, boxw, m->sel->isfixed, 0);
+ -- 
+ 2.20.1
+ 
diff -crNb dwm-6.2/slstatus/LICENSE dwm/slstatus/LICENSE
*** dwm-6.2/slstatus/LICENSE	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/LICENSE	2021-10-31 17:28:42.434188030 -0300
***************
*** 0 ****
--- 1,40 ----
+ ISC License
+ 
+ Copyright 2016-2020 Aaron Marcher <me@drkhsh.at>
+ 
+ Copyright 2016 Roy Freytag <rfreytag@hs-mittweida.de>
+ Copyright 2016 Vincent Loupmon <vincentloupmon@gmail.com>
+ Copyright 2016 Daniel Walter <d.walter@0x90.at>
+ Copyright 2016-2018 Ali H. Fardan <raiz@firemail.cc>
+ Copyright 2016 Jody Leonard <me@jodyleonard.com>
+ Copyright 2016-2018 Quentin Rameau <quinq@fifth.space>
+ Copyright 2016 Mike Coddington <mike@coddington.us>
+ Copyright 2016-2018 parazyd <parazyd@dyne.org>
+ Copyright 2017 Tobias Stoeckmann <tobias@stoeckmann.org>
+ Copyright 2017-2018 Laslo Hunhold <dev@frign.de>
+ Copyright 2018 Darron Anderson <darronanderson@protonmail.com>
+ Copyright 2018 Josuah Demangeon <mail@josuah.net>
+ Copyright 2018 Tobias Tschinkowitz <tobias@he4d.net>
+ Copyright 2018 David Demelier <markand@malikania.fr>
+ Copyright 2018-2019 Michael Buch <michaelbuch12@gmail.com>
+ Copyright 2018 Ian Remmler <ian@remmler.org>
+ Copyright 2016-2019 Joerg Jung <jung@openbsd.org>
+ Copyright 2019 Ryan Kes <alrayyes@gmail.com>
+ Copyright 2019 Cem Keylan <cem@ckyln.com>
+ Copyright 2019 dsp <dsp@2f30.org>
+ Copyright 2019-2020 Ingo Feinerer <feinerer@logic.at>
+ Copyright 2020 Alexandre Ratchov <alex@caoua.org>
+ Copyright 2020 Mart Lubbers <mart@martlubbers.net>
+ Copyright 2020 Daniel Moch <daniel@danielmoch.com>
+ 
+ Permission to use, copy, modify, and/or distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff -crNb dwm-6.2/slstatus/Makefile dwm/slstatus/Makefile
*** dwm-6.2/slstatus/Makefile	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/Makefile	2021-10-31 17:28:42.434188030 -0300
***************
*** 0 ****
--- 1,68 ----
+ # See LICENSE file for copyright and license details
+ # slstatus - suckless status monitor
+ .POSIX:
+ 
+ include config.mk
+ 
+ REQ = util
+ COM =\
+ 	components/battery\
+ 	components/cpu\
+ 	components/datetime\
+ 	components/disk\
+ 	components/entropy\
+ 	components/hostname\
+ 	components/ip\
+ 	components/kernel_release\
+ 	components/keyboard_indicators\
+ 	components/keymap\
+ 	components/load_avg\
+ 	components/netspeeds\
+ 	components/num_files\
+ 	components/ram\
+ 	components/run_command\
+ 	components/separator\
+ 	components/swap\
+ 	components/temperature\
+ 	components/uptime\
+ 	components/user\
+ 	components/volume\
+ 	components/wifi
+ 
+ all: slstatus
+ 
+ $(COM:=.o): config.mk $(REQ:=.h)
+ slstatus.o: slstatus.c slstatus.h arg.h config.h config.mk $(REQ:=.h)
+ 
+ .c.o:
+ 	$(CC) -o $@ -c $(CPPFLAGS) $(CFLAGS) $<
+ 
+ config.h:
+ 	cp config.def.h $@
+ 
+ slstatus: slstatus.o $(COM:=.o) $(REQ:=.o)
+ 	$(CC) -o $@ $(LDFLAGS) $(COM:=.o) $(REQ:=.o) slstatus.o $(LDLIBS)
+ 
+ clean:
+ 	rm -f slstatus slstatus.o $(COM:=.o) $(REQ:=.o)
+ 
+ dist:
+ 	rm -rf "slstatus-$(VERSION)"
+ 	mkdir -p "slstatus-$(VERSION)/components"
+ 	cp -R LICENSE Makefile README config.mk config.def.h \
+ 	      arg.h slstatus.c $(COM:=.c) $(REQ:=.c) $(REQ:=.h) \
+ 	      slstatus.1 "slstatus-$(VERSION)"
+ 	tar -cf - "slstatus-$(VERSION)" | gzip -c > "slstatus-$(VERSION).tar.gz"
+ 	rm -rf "slstatus-$(VERSION)"
+ 
+ install: all
+ 	mkdir -p "$(DESTDIR)$(PREFIX)/bin"
+ 	cp -f slstatus "$(DESTDIR)$(PREFIX)/bin"
+ 	chmod 755 "$(DESTDIR)$(PREFIX)/bin/slstatus"
+ 	mkdir -p "$(DESTDIR)$(MANPREFIX)/man1"
+ 	cp -f slstatus.1 "$(DESTDIR)$(MANPREFIX)/man1"
+ 	chmod 644 "$(DESTDIR)$(MANPREFIX)/man1/slstatus.1"
+ 
+ uninstall:
+ 	rm -f "$(DESTDIR)$(PREFIX)/bin/slstatus"
+ 	rm -f "$(DESTDIR)$(MANPREFIX)/man1/slstatus.1"
diff -crNb dwm-6.2/slstatus/README dwm/slstatus/README
*** dwm-6.2/slstatus/README	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/README	2021-10-31 17:28:42.435188037 -0300
***************
*** 0 ****
--- 1,65 ----
+ slstatus - suckless status
+ ==========================
+ slstatus is a suckless status monitor for window managers that use WM_NAME
+ (e.g. dwm) or stdin to fill the status bar.
+ 
+ 
+ Features
+ --------
+ - Battery percentage/state/time left
+ - CPU usage
+ - CPU frequency
+ - Custom shell commands
+ - Date and time
+ - Disk status (free storage, percentage, total storage and used storage)
+ - Available entropy
+ - Username/GID/UID
+ - Hostname
+ - IP address (IPv4 and IPv6)
+ - Kernel version
+ - Keyboard indicators
+ - Keymap
+ - Load average
+ - Network speeds (RX and TX)
+ - Number of files in a directory (hint: Maildir)
+ - Memory status (free memory, percentage, total memory and used memory)
+ - Swap status (free swap, percentage, total swap and used swap)
+ - Temperature
+ - Uptime
+ - Volume percentage
+ - WiFi signal percentage and ESSID
+ 
+ 
+ Requirements
+ ------------
+ Currently slstatus works on FreeBSD, Linux and OpenBSD.
+ In order to build slstatus you need the Xlib header files.
+ 
+ 
+ Installation
+ ------------
+ Edit config.mk to match your local setup (slstatus is installed into the
+ /usr/local namespace by default).
+ 
+ Afterwards enter the following command to build and install slstatus (if
+ necessary as root):
+ 
+     make clean install
+ 
+ 
+ Running slstatus
+ ----------------
+ See the man page for details.
+ 
+ 
+ Configuration
+ -------------
+ slstatus can be customized by creating a custom config.h and (re)compiling the
+ source code. This keeps it fast, secure and simple.
+ 
+ 
+ Upcoming
+ --------
+ 
+ A release (v1.0) will come soon... ;)
+ After a long phase of inactivity, development has been continued!
diff -crNb dwm-6.2/slstatus/arg.h dwm/slstatus/arg.h
*** dwm-6.2/slstatus/arg.h	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/arg.h	2021-10-31 17:28:42.435188037 -0300
***************
*** 0 ****
--- 1,33 ----
+ /* See LICENSE file for copyright and license details. */
+ #ifndef ARG_H
+ #define ARG_H
+ 
+ extern char *argv0;
+ 
+ /* int main(int argc, char *argv[]) */
+ #define ARGBEGIN for (argv0 = *argv, *argv ? (argc--, argv++) : ((void *)0);      \
+                       *argv && (*argv)[0] == '-' && (*argv)[1]; argc--, argv++) { \
+                  	int i_, argused_;                                         \
+                  	if ((*argv)[1] == '-' && !(*argv)[2]) {                   \
+                  		argc--, argv++;                                   \
+                  		break;                                            \
+                  	}                                                         \
+                  	for (i_ = 1, argused_ = 0; (*argv)[i_]; i_++) {           \
+                  		switch((*argv)[i_])
+ #define ARGEND   		if (argused_) {                                   \
+                  			if ((*argv)[i_ + 1]) {                    \
+                  				break;                            \
+                  			} else {                                  \
+                  				argc--, argv++;                   \
+                  				break;                            \
+                  			}                                         \
+                  		}                                                 \
+                  	}                                                         \
+                  }
+ #define ARGC()   ((*argv)[i_])
+ #define ARGF_(x) (((*argv)[i_ + 1]) ? (argused_ = 1, &((*argv)[i_ + 1])) :        \
+                   (*(argv + 1))     ? (argused_ = 1, *(argv + 1))        : (x))
+ #define EARGF(x) ARGF_(((x), exit(1), (char *)0))
+ #define ARGF()   ARGF_((char *)0)
+ 
+ #endif
diff -crNb dwm-6.2/slstatus/components/battery.c dwm/slstatus/components/battery.c
*** dwm-6.2/slstatus/components/battery.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/battery.c	2021-10-31 17:28:42.496188495 -0300
***************
*** 0 ****
--- 1,252 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <string.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(__linux__)
+ 	#include <limits.h>
+ 	#include <stdint.h>
+ 	#include <unistd.h>
+ 
+ 	static const char *
+ 	pick(const char *bat, const char *f1, const char *f2, char *path,
+ 	     size_t length)
+ 	{
+ 		if (esnprintf(path, length, f1, bat) > 0 &&
+ 		    access(path, R_OK) == 0) {
+ 			return f1;
+ 		}
+ 
+ 		if (esnprintf(path, length, f2, bat) > 0 &&
+ 		    access(path, R_OK) == 0) {
+ 			return f2;
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	battery_perc(const char *bat)
+ 	{
+ 		int perc;
+ 		char path[PATH_MAX];
+ 
+ 		if (esnprintf(path, sizeof(path),
+ 		              "/sys/class/power_supply/%s/capacity", bat) < 0) {
+ 			return NULL;
+ 		}
+ 		if (pscanf(path, "%d", &perc) != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", perc);
+ 	}
+ 
+ 	const char *
+ 	battery_state(const char *bat)
+ 	{
+ 		static struct {
+ 			char *state;
+ 			char *symbol;
+ 		} map[] = {
+ 			{ "Charging",    "ï‰‚ +" },
+ 			{ "Discharging", "ï‰‚ -" },
+ 			{ "Full",        "ï‰€" },
+ 		};
+ 		size_t i;
+ 		char path[PATH_MAX], state[12];
+ 
+ 		if (esnprintf(path, sizeof(path),
+ 		              "/sys/class/power_supply/%s/status", bat) < 0) {
+ 			return NULL;
+ 		}
+ 		if (pscanf(path, "%12s", state) != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		for (i = 0; i < LEN(map); i++) {
+ 			if (!strcmp(map[i].state, state)) {
+ 				break;
+ 			}
+ 		}
+ 		return (i == LEN(map)) ? "?" : map[i].symbol;
+ 	}
+ 
+ 	const char *
+ 	battery_remaining(const char *bat)
+ 	{
+ 		uintmax_t charge_now, current_now, m, h;
+ 		double timeleft;
+ 		char path[PATH_MAX], state[12];
+ 
+ 		if (esnprintf(path, sizeof(path),
+ 		              "/sys/class/power_supply/%s/status", bat) < 0) {
+ 			return NULL;
+ 		}
+ 		if (pscanf(path, "%12s", state) != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		if (!pick(bat, "/sys/class/power_supply/%s/charge_now",
+ 		          "/sys/class/power_supply/%s/energy_now", path,
+ 		          sizeof(path)) ||
+ 		    pscanf(path, "%ju", &charge_now) < 0) {
+ 			return NULL;
+ 		}
+ 
+ 		if (!strcmp(state, "Discharging")) {
+ 			if (!pick(bat, "/sys/class/power_supply/%s/current_now",
+ 			          "/sys/class/power_supply/%s/power_now", path,
+ 			          sizeof(path)) ||
+ 			    pscanf(path, "%ju", &current_now) < 0) {
+ 				return NULL;
+ 			}
+ 
+ 			if (current_now == 0) {
+ 				return NULL;
+ 			}
+ 
+ 			timeleft = (double)charge_now / (double)current_now;
+ 			h = timeleft;
+ 			m = (timeleft - (double)h) * 60;
+ 
+ 			return bprintf("%juh %jum", h, m);
+ 		}
+ 
+ 		return "";
+ 	}
+ #elif defined(__OpenBSD__)
+ 	#include <fcntl.h>
+ 	#include <machine/apmvar.h>
+ 	#include <sys/ioctl.h>
+ 	#include <unistd.h>
+ 
+ 	static int
+ 	load_apm_power_info(struct apm_power_info *apm_info)
+ 	{
+ 		int fd;
+ 
+ 		fd = open("/dev/apm", O_RDONLY);
+ 		if (fd < 0) {
+ 			warn("open '/dev/apm':");
+ 			return 0;
+ 		}
+ 
+ 		memset(apm_info, 0, sizeof(struct apm_power_info));
+ 		if (ioctl(fd, APM_IOC_GETPOWER, apm_info) < 0) {
+ 			warn("ioctl 'APM_IOC_GETPOWER':");
+ 			close(fd);
+ 			return 0;
+ 		}
+ 		return close(fd), 1;
+ 	}
+ 
+ 	const char *
+ 	battery_perc(const char *unused)
+ 	{
+ 		struct apm_power_info apm_info;
+ 
+ 		if (load_apm_power_info(&apm_info)) {
+ 			return bprintf("%d", apm_info.battery_life);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	battery_state(const char *unused)
+ 	{
+ 		struct {
+ 			unsigned int state;
+ 			char *symbol;
+ 		} map[] = {
+ 			{ APM_AC_ON,      "+" },
+ 			{ APM_AC_OFF,     "-" },
+ 		};
+ 		struct apm_power_info apm_info;
+ 		size_t i;
+ 
+ 		if (load_apm_power_info(&apm_info)) {
+ 			for (i = 0; i < LEN(map); i++) {
+ 				if (map[i].state == apm_info.ac_state) {
+ 					break;
+ 				}
+ 			}
+ 			return (i == LEN(map)) ? "?" : map[i].symbol;
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	battery_remaining(const char *unused)
+ 	{
+ 		struct apm_power_info apm_info;
+ 
+ 		if (load_apm_power_info(&apm_info)) {
+ 			if (apm_info.ac_state != APM_AC_ON) {
+ 				return bprintf("%uh %02um",
+ 			                       apm_info.minutes_left / 60,
+ 				               apm_info.minutes_left % 60);
+ 			} else {
+ 				return "";
+ 			}
+ 		}
+ 
+ 		return NULL;
+ 	}
+ #elif defined(__FreeBSD__)
+ 	#include <sys/sysctl.h>
+ 
+ 	const char *
+ 	battery_perc(const char *unused)
+ 	{
+ 		int cap;
+ 		size_t len;
+ 
+ 		len = sizeof(cap);
+ 		if (sysctlbyname("hw.acpi.battery.life", &cap, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		return bprintf("%d", cap);
+ 	}
+ 
+ 	const char *
+ 	battery_state(const char *unused)
+ 	{
+ 		int state;
+ 		size_t len;
+ 
+ 		len = sizeof(state);
+ 		if (sysctlbyname("hw.acpi.battery.state", &state, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		switch(state) {
+ 			case 0:
+ 			case 2:
+ 				return "+";
+ 			case 1:
+ 				return "-";
+ 			default:
+ 				return "?";
+ 		}
+ 	}
+ 
+ 	const char *
+ 	battery_remaining(const char *unused)
+ 	{
+ 		int rem;
+ 		size_t len;
+ 
+ 		len = sizeof(rem);
+ 		if (sysctlbyname("hw.acpi.battery.time", &rem, &len, NULL, 0) == -1
+ 				|| !len
+ 				|| rem == -1)
+ 			return NULL;
+ 
+ 		return bprintf("%uh %02um", rem / 60, rem % 60);
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/battery.o and dwm/slstatus/components/battery.o differ
diff -crNb dwm-6.2/slstatus/components/cpu.c dwm/slstatus/components/cpu.c
*** dwm-6.2/slstatus/components/cpu.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/cpu.c	2021-10-31 17:28:42.497188503 -0300
***************
*** 0 ****
--- 1,164 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdint.h>
+ #include <stdio.h>
+ #include <string.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(__linux__)
+ 	const char *
+ 	cpu_freq(void)
+ 	{
+ 		uintmax_t freq;
+ 
+ 		/* in kHz */
+ 		if (pscanf("/sys/devices/system/cpu/cpu0/cpufreq/"
+ 		           "scaling_cur_freq", "%ju", &freq) != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(freq * 1000, 1000);
+ 	}
+ 
+ 	const char *
+ 	cpu_perc(void)
+ 	{
+ 		static long double a[7];
+ 		long double b[7], sum;
+ 
+ 		memcpy(b, a, sizeof(b));
+ 		/* cpu user nice system idle iowait irq softirq */
+ 		if (pscanf("/proc/stat", "%*s %Lf %Lf %Lf %Lf %Lf %Lf %Lf",
+ 		           &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])
+ 		    != 7) {
+ 			return NULL;
+ 		}
+ 		if (b[0] == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		sum = (b[0] + b[1] + b[2] + b[3] + b[4] + b[5] + b[6]) -
+ 		      (a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6]);
+ 
+ 		if (sum == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", (int)(100 *
+ 		               ((b[0] + b[1] + b[2] + b[5] + b[6]) -
+ 		                (a[0] + a[1] + a[2] + a[5] + a[6])) / sum));
+ 	}
+ #elif defined(__OpenBSD__)
+ 	#include <sys/param.h>
+ 	#include <sys/sched.h>
+ 	#include <sys/sysctl.h>
+ 
+ 	const char *
+ 	cpu_freq(void)
+ 	{
+ 		int freq, mib[2];
+ 		size_t size;
+ 
+ 		mib[0] = CTL_HW;
+ 		mib[1] = HW_CPUSPEED;
+ 
+ 		size = sizeof(freq);
+ 
+ 		/* in MHz */
+ 		if (sysctl(mib, 2, &freq, &size, NULL, 0) < 0) {
+ 			warn("sysctl 'HW_CPUSPEED':");
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(freq * 1E6, 1000);
+ 	}
+ 
+ 	const char *
+ 	cpu_perc(void)
+ 	{
+ 		int mib[2];
+ 		static uintmax_t a[CPUSTATES];
+ 		uintmax_t b[CPUSTATES], sum;
+ 		size_t size;
+ 
+ 		mib[0] = CTL_KERN;
+ 		mib[1] = KERN_CPTIME;
+ 
+ 		size = sizeof(a);
+ 
+ 		memcpy(b, a, sizeof(b));
+ 		if (sysctl(mib, 2, &a, &size, NULL, 0) < 0) {
+ 			warn("sysctl 'KERN_CPTIME':");
+ 			return NULL;
+ 		}
+ 		if (b[0] == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		sum = (a[CP_USER] + a[CP_NICE] + a[CP_SYS] + a[CP_INTR] + a[CP_IDLE]) -
+ 		      (b[CP_USER] + b[CP_NICE] + b[CP_SYS] + b[CP_INTR] + b[CP_IDLE]);
+ 
+ 		if (sum == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", 100 *
+ 		               ((a[CP_USER] + a[CP_NICE] + a[CP_SYS] +
+ 		                 a[CP_INTR]) -
+ 		                (b[CP_USER] + b[CP_NICE] + b[CP_SYS] +
+ 		                 b[CP_INTR])) / sum);
+ 	}
+ #elif defined(__FreeBSD__)
+ 	#include <sys/param.h>
+ 	#include <sys/sysctl.h>
+ 	#include <devstat.h>
+ 
+ 	const char *
+ 	cpu_freq(void)
+ 	{
+ 		int freq;
+ 		size_t size;
+ 
+ 		size = sizeof(freq);
+ 		/* in MHz */
+ 		if (sysctlbyname("hw.clockrate", &freq, &size, NULL, 0) == -1
+ 				|| !size) {
+ 			warn("sysctlbyname 'hw.clockrate':");
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(freq * 1E6, 1000);
+ 	}
+ 
+ 	const char *
+ 	cpu_perc(void)
+ 	{
+ 		size_t size;
+ 		static long a[CPUSTATES];
+ 		long b[CPUSTATES], sum;
+ 
+ 		size = sizeof(a);
+ 		memcpy(b, a, sizeof(b));
+ 		if (sysctlbyname("kern.cp_time", &a, &size, NULL, 0) == -1
+ 				|| !size) {
+ 			warn("sysctlbyname 'kern.cp_time':");
+ 			return NULL;
+ 		}
+ 		if (b[0] == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		sum = (a[CP_USER] + a[CP_NICE] + a[CP_SYS] + a[CP_INTR] + a[CP_IDLE]) -
+ 		      (b[CP_USER] + b[CP_NICE] + b[CP_SYS] + b[CP_INTR] + b[CP_IDLE]);
+ 
+ 		if (sum == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", 100 *
+ 		               ((a[CP_USER] + a[CP_NICE] + a[CP_SYS] +
+ 		                 a[CP_INTR]) -
+ 		                (b[CP_USER] + b[CP_NICE] + b[CP_SYS] +
+ 		                 b[CP_INTR])) / sum);
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/cpu.o and dwm/slstatus/components/cpu.o differ
diff -crNb dwm-6.2/slstatus/components/datetime.c dwm/slstatus/components/datetime.c
*** dwm-6.2/slstatus/components/datetime.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/datetime.c	2021-10-31 17:28:42.502188540 -0300
***************
*** 0 ****
--- 1,19 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <time.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ datetime(const char *fmt)
+ {
+ 	time_t t;
+ 
+ 	t = time(NULL);
+ 	if (!strftime(buf, sizeof(buf), fmt, localtime(&t))) {
+ 		warn("strftime: Result string exceeds buffer size");
+ 		return NULL;
+ 	}
+ 
+ 	return buf;
+ }
Binary files dwm-6.2/slstatus/components/datetime.o and dwm/slstatus/components/datetime.o differ
diff -crNb dwm-6.2/slstatus/components/disk.c dwm/slstatus/components/disk.c
*** dwm-6.2/slstatus/components/disk.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/disk.c	2021-10-31 17:28:42.512188615 -0300
***************
*** 0 ****
--- 1,58 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <sys/statvfs.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ disk_free(const char *path)
+ {
+ 	struct statvfs fs;
+ 
+ 	if (statvfs(path, &fs) < 0) {
+ 		warn("statvfs '%s':", path);
+ 		return NULL;
+ 	}
+ 
+ 	return fmt_human(fs.f_frsize * fs.f_bavail, 1024);
+ }
+ 
+ const char *
+ disk_perc(const char *path)
+ {
+ 	struct statvfs fs;
+ 
+ 	if (statvfs(path, &fs) < 0) {
+ 		warn("statvfs '%s':", path);
+ 		return NULL;
+ 	}
+ 
+ 	return bprintf("%d", (int)(100 *
+ 	               (1.0f - ((float)fs.f_bavail / (float)fs.f_blocks))));
+ }
+ 
+ const char *
+ disk_total(const char *path)
+ {
+ 	struct statvfs fs;
+ 
+ 	if (statvfs(path, &fs) < 0) {
+ 		warn("statvfs '%s':", path);
+ 		return NULL;
+ 	}
+ 
+ 	return fmt_human(fs.f_frsize * fs.f_blocks, 1024);
+ }
+ 
+ const char *
+ disk_used(const char *path)
+ {
+ 	struct statvfs fs;
+ 
+ 	if (statvfs(path, &fs) < 0) {
+ 		warn("statvfs '%s':", path);
+ 		return NULL;
+ 	}
+ 
+ 	return fmt_human(fs.f_frsize * (fs.f_blocks - fs.f_bfree), 1024);
+ }
Binary files dwm-6.2/slstatus/components/disk.o and dwm/slstatus/components/disk.o differ
diff -crNb dwm-6.2/slstatus/components/entropy.c dwm/slstatus/components/entropy.c
*** dwm-6.2/slstatus/components/entropy.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/entropy.c	2021-10-31 17:28:42.533188773 -0300
***************
*** 0 ****
--- 1,27 ----
+ /* See LICENSE file for copyright and license details. */
+ #if defined(__linux__)
+ 	#include <stdint.h>
+ 	#include <stdio.h>
+ 
+ 	#include "../util.h"
+ 
+ 	const char *
+ 	entropy(void)
+ 	{
+ 		uintmax_t num;
+ 
+ 		if (pscanf("/proc/sys/kernel/random/entropy_avail", "%ju", &num)
+ 		    != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%ju", num);
+ 	}
+ #elif defined(__OpenBSD__) | defined(__FreeBSD__)
+ 	const char *
+ 	entropy(void)
+ 	{
+ 		/* Unicode Character 'INFINITY' (U+221E) */
+ 		return "\xe2\x88\x9e";
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/entropy.o and dwm/slstatus/components/entropy.o differ
diff -crNb dwm-6.2/slstatus/components/hostname.c dwm/slstatus/components/hostname.c
*** dwm-6.2/slstatus/components/hostname.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/hostname.c	2021-10-31 17:28:42.534188780 -0300
***************
*** 0 ****
--- 1,16 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <unistd.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ hostname(void)
+ {
+ 	if (gethostname(buf, sizeof(buf)) < 0) {
+ 		warn("gethostbyname:");
+ 		return NULL;
+ 	}
+ 
+ 	return buf;
+ }
Binary files dwm-6.2/slstatus/components/hostname.o and dwm/slstatus/components/hostname.o differ
diff -crNb dwm-6.2/slstatus/components/ip.c dwm/slstatus/components/ip.c
*** dwm-6.2/slstatus/components/ip.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/ip.c	2021-10-31 17:28:42.535188788 -0300
***************
*** 0 ****
--- 1,60 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <ifaddrs.h>
+ #include <netdb.h>
+ #include <stdio.h>
+ #include <string.h>
+ #if defined(__OpenBSD__)
+ 	#include <sys/types.h>
+ 	#include <sys/socket.h>
+ #elif defined(__FreeBSD__)
+ 	#include <netinet/in.h>
+ 	#include <sys/socket.h>
+ #endif
+ 
+ #include "../util.h"
+ 
+ static const char *
+ ip(const char *interface, unsigned short sa_family)
+ {
+ 	struct ifaddrs *ifaddr, *ifa;
+ 	int s;
+ 	char host[NI_MAXHOST];
+ 
+ 	if (getifaddrs(&ifaddr) < 0) {
+ 		warn("getifaddrs:");
+ 		return NULL;
+ 	}
+ 
+ 	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+ 		if (!ifa->ifa_addr) {
+ 			continue;
+ 		}
+ 		s = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in6),
+ 		                host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
+ 		if (!strcmp(ifa->ifa_name, interface) &&
+ 		    (ifa->ifa_addr->sa_family == sa_family)) {
+ 			freeifaddrs(ifaddr);
+ 			if (s != 0) {
+ 				warn("getnameinfo: %s", gai_strerror(s));
+ 				return NULL;
+ 			}
+ 			return bprintf("%s", host);
+ 		}
+ 	}
+ 
+ 	freeifaddrs(ifaddr);
+ 
+ 	return NULL;
+ }
+ 
+ const char *
+ ipv4(const char *interface)
+ {
+ 	return ip(interface, AF_INET);
+ }
+ 
+ const char *
+ ipv6(const char *interface)
+ {
+ 	return ip(interface, AF_INET6);
+ }
Binary files dwm-6.2/slstatus/components/ip.o and dwm/slstatus/components/ip.o differ
diff -crNb dwm-6.2/slstatus/components/kernel_release.c dwm/slstatus/components/kernel_release.c
*** dwm-6.2/slstatus/components/kernel_release.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/kernel_release.c	2021-10-31 17:28:42.535188788 -0300
***************
*** 0 ****
--- 1,18 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <sys/utsname.h>
+ #include <stdio.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ kernel_release(void)
+ {
+ 	struct utsname udata;
+ 
+ 	if (uname(&udata) < 0) {
+ 		warn("uname:");
+ 		return NULL;
+ 	}
+ 
+ 	return bprintf("%s", udata.release);
+ }
Binary files dwm-6.2/slstatus/components/kernel_release.o and dwm/slstatus/components/kernel_release.o differ
diff -crNb dwm-6.2/slstatus/components/keyboard_indicators.c dwm/slstatus/components/keyboard_indicators.c
*** dwm-6.2/slstatus/components/keyboard_indicators.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/keyboard_indicators.c	2021-10-31 17:28:42.536188795 -0300
***************
*** 0 ****
--- 1,48 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <ctype.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <X11/Xlib.h>
+ 
+ #include "../util.h"
+ 
+ /*
+  * fmt consists of uppercase or lowercase 'c' for caps lock and/or 'n' for num
+  * lock, each optionally followed by '?', in the order of indicators desired.
+  * If followed by '?', the letter with case preserved is included in the output
+  * if the corresponding indicator is on.  Otherwise, the letter is always
+  * included, lowercase when off and uppercase when on.
+  */
+ const char *
+ keyboard_indicators(const char *fmt)
+ {
+ 	Display *dpy;
+ 	XKeyboardState state;
+ 	size_t fmtlen, i, n;
+ 	int togglecase, isset;
+ 	char key;
+ 
+ 	if (!(dpy = XOpenDisplay(NULL))) {
+ 		warn("XOpenDisplay: Failed to open display");
+ 		return NULL;
+ 	}
+ 	XGetKeyboardControl(dpy, &state);
+ 	XCloseDisplay(dpy);
+ 
+ 	fmtlen = strnlen(fmt, 4);
+ 	for (i = n = 0; i < fmtlen; i++) {
+ 		key = tolower(fmt[i]);
+ 		if (key != 'c' && key != 'n') {
+ 			continue;
+ 		}
+ 		togglecase = (i + 1 >= fmtlen || fmt[i + 1] != '?');
+ 		isset = (state.led_mask & (1 << (key == 'n')));
+ 		if (togglecase) {
+ 			buf[n++] = isset ? toupper(key) : key;
+ 		} else if (isset) {
+ 			buf[n++] = fmt[i];
+ 		}
+ 	}
+ 	buf[n] = 0;
+ 	return buf;
+ }
Binary files dwm-6.2/slstatus/components/keyboard_indicators.o and dwm/slstatus/components/keyboard_indicators.o differ
diff -crNb dwm-6.2/slstatus/components/keymap.c dwm/slstatus/components/keymap.c
*** dwm-6.2/slstatus/components/keymap.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/keymap.c	2021-10-31 17:28:42.536188795 -0300
***************
*** 0 ****
--- 1,87 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <ctype.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <X11/XKBlib.h>
+ #include <X11/Xlib.h>
+ 
+ #include "../util.h"
+ 
+ static int
+ valid_layout_or_variant(char *sym)
+ {
+ 	size_t i;
+ 	/* invalid symbols from xkb rules config */
+ 	static const char *invalid[] = { "evdev", "inet", "pc", "base" };
+ 
+ 	for (i = 0; i < LEN(invalid); i++) {
+ 		if (!strncmp(sym, invalid[i], strlen(invalid[i]))) {
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static char *
+ get_layout(char *syms, int grp_num)
+ {
+ 	char *tok, *layout;
+ 	int grp;
+ 
+ 	layout = NULL;
+ 	tok = strtok(syms, "+:");
+ 	for (grp = 0; tok && grp <= grp_num; tok = strtok(NULL, "+:")) {
+ 		if (!valid_layout_or_variant(tok)) {
+ 			continue;
+ 		} else if (strlen(tok) == 1 && isdigit(tok[0])) {
+ 			/* ignore :2, :3, :4 (additional layout groups) */
+ 			continue;
+ 		}
+ 		layout = tok;
+ 		grp++;
+ 	}
+ 
+ 	return layout;
+ }
+ 
+ const char *
+ keymap(void)
+ {
+ 	Display *dpy;
+ 	XkbDescRec *desc;
+ 	XkbStateRec state;
+ 	char *symbols, *layout;
+ 
+ 	layout = NULL;
+ 
+ 	if (!(dpy = XOpenDisplay(NULL))) {
+ 		warn("XOpenDisplay: Failed to open display");
+ 		return NULL;
+ 	}
+ 	if (!(desc = XkbAllocKeyboard())) {
+ 		warn("XkbAllocKeyboard: Failed to allocate keyboard");
+ 		goto end;
+ 	}
+ 	if (XkbGetNames(dpy, XkbSymbolsNameMask, desc)) {
+ 		warn("XkbGetNames: Failed to retrieve key symbols");
+ 		goto end;
+ 	}
+ 	if (XkbGetState(dpy, XkbUseCoreKbd, &state)) {
+ 		warn("XkbGetState: Failed to retrieve keyboard state");
+ 		goto end;
+ 	}
+ 	if (!(symbols = XGetAtomName(dpy, desc->names->symbols))) {
+ 		warn("XGetAtomName: Failed to get atom name");
+ 		goto end;
+ 	}
+ 	layout = (char *)bprintf("%s", get_layout(symbols, state.group));
+ 	XFree(symbols);
+ end:
+ 	XkbFreeKeyboard(desc, XkbSymbolsNameMask, 1);
+ 	if (XCloseDisplay(dpy)) {
+ 		warn("XCloseDisplay: Failed to close display");
+ 	}
+ 
+ 	return layout;
+ }
Binary files dwm-6.2/slstatus/components/keymap.o and dwm/slstatus/components/keymap.o differ
diff -crNb dwm-6.2/slstatus/components/load_avg.c dwm/slstatus/components/load_avg.c
*** dwm-6.2/slstatus/components/load_avg.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/load_avg.c	2021-10-31 17:28:42.554188931 -0300
***************
*** 0 ****
--- 1,18 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <stdlib.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ load_avg(void)
+ {
+ 	double avgs[3];
+ 
+ 	if (getloadavg(avgs, 3) < 0) {
+ 		warn("getloadavg: Failed to obtain load average");
+ 		return NULL;
+ 	}
+ 
+ 	return bprintf("%.2f %.2f %.2f", avgs[0], avgs[1], avgs[2]);
+ }
Binary files dwm-6.2/slstatus/components/load_avg.o and dwm/slstatus/components/load_avg.o differ
diff -crNb dwm-6.2/slstatus/components/netspeeds.c dwm/slstatus/components/netspeeds.c
*** dwm-6.2/slstatus/components/netspeeds.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/netspeeds.c	2021-10-31 17:28:42.554188931 -0300
***************
*** 0 ****
--- 1,139 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <limits.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(__linux__)
+ 	#include <stdint.h>
+ 
+ 	const char *
+ 	netspeed_rx(const char *interface)
+ 	{
+ 		uintmax_t oldrxbytes;
+ 		static uintmax_t rxbytes;
+ 		extern const unsigned int interval;
+ 		char path[PATH_MAX];
+ 
+ 		oldrxbytes = rxbytes;
+ 
+ 		if (esnprintf(path, sizeof(path),
+ 		              "/sys/class/net/%s/statistics/rx_bytes",
+ 		              interface) < 0) {
+ 			return NULL;
+ 		}
+ 		if (pscanf(path, "%ju", &rxbytes) != 1) {
+ 			return NULL;
+ 		}
+ 		if (oldrxbytes == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((rxbytes - oldrxbytes) * 1000 / interval,
+ 		                 1024);
+ 	}
+ 
+ 	const char *
+ 	netspeed_tx(const char *interface)
+ 	{
+ 		uintmax_t oldtxbytes;
+ 		static uintmax_t txbytes;
+ 		extern const unsigned int interval;
+ 		char path[PATH_MAX];
+ 
+ 		oldtxbytes = txbytes;
+ 
+ 		if (esnprintf(path, sizeof(path),
+ 		              "/sys/class/net/%s/statistics/tx_bytes",
+ 		              interface) < 0) {
+ 			return NULL;
+ 		}
+ 		if (pscanf(path, "%ju", &txbytes) != 1) {
+ 			return NULL;
+ 		}
+ 		if (oldtxbytes == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((txbytes - oldtxbytes) * 1000 / interval,
+ 		                 1024);
+ 	}
+ #elif defined(__OpenBSD__) | defined(__FreeBSD__)
+ 	#include <string.h>
+ 	#include <ifaddrs.h>
+ 	#include <sys/types.h>
+ 	#include <sys/socket.h>
+ 	#include <net/if.h>
+ 
+ 	const char *
+ 	netspeed_rx(const char *interface)
+ 	{
+ 		struct ifaddrs *ifal, *ifa;
+ 		struct if_data *ifd;
+ 		uintmax_t oldrxbytes;
+ 		static uintmax_t rxbytes;
+ 		extern const unsigned int interval;
+ 		int if_ok = 0;
+ 
+ 		oldrxbytes = rxbytes;
+ 
+ 		if (getifaddrs(&ifal) == -1) {
+ 			warn("getifaddrs failed");
+ 			return NULL;
+ 		}
+ 		rxbytes = 0;
+ 		for (ifa = ifal; ifa; ifa = ifa->ifa_next) {
+ 			if (!strcmp(ifa->ifa_name, interface) &&
+ 			   (ifd = (struct if_data *)ifa->ifa_data)) {
+ 				rxbytes += ifd->ifi_ibytes, if_ok = 1;
+ 			}
+ 		}
+ 		freeifaddrs(ifal);
+ 		if (!if_ok) {
+ 			warn("reading 'if_data' failed");
+ 			return NULL;
+ 		}
+ 		if (oldrxbytes == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((rxbytes - oldrxbytes) * 1000 / interval,
+ 		                 1024);
+ 	}
+ 
+ 	const char *
+ 	netspeed_tx(const char *interface)
+ 	{
+ 		struct ifaddrs *ifal, *ifa;
+ 		struct if_data *ifd;
+ 		uintmax_t oldtxbytes;
+ 		static uintmax_t txbytes;
+ 		extern const unsigned int interval;
+ 		int if_ok = 0;
+ 
+ 		oldtxbytes = txbytes;
+ 
+ 		if (getifaddrs(&ifal) == -1) {
+ 			warn("getifaddrs failed");
+ 			return NULL;
+ 		}
+ 		txbytes = 0;
+ 		for (ifa = ifal; ifa; ifa = ifa->ifa_next) {
+ 			if (!strcmp(ifa->ifa_name, interface) &&
+ 			   (ifd = (struct if_data *)ifa->ifa_data)) {
+ 				txbytes += ifd->ifi_obytes, if_ok = 1;
+ 			}
+ 		}
+ 		freeifaddrs(ifal);
+ 		if (!if_ok) {
+ 			warn("reading 'if_data' failed");
+ 			return NULL;
+ 		}
+ 		if (oldtxbytes == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((txbytes - oldtxbytes) * 1000 / interval,
+ 		                 1024);
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/netspeeds.o and dwm/slstatus/components/netspeeds.o differ
diff -crNb dwm-6.2/slstatus/components/num_files.c dwm/slstatus/components/num_files.c
*** dwm-6.2/slstatus/components/num_files.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/num_files.c	2021-10-31 17:28:42.561188983 -0300
***************
*** 0 ****
--- 1,31 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <dirent.h>
+ #include <stdio.h>
+ #include <string.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ num_files(const char *path)
+ {
+ 	struct dirent *dp;
+ 	DIR *fd;
+ 	int num;
+ 
+ 	if (!(fd = opendir(path))) {
+ 		warn("opendir '%s':", path);
+ 		return NULL;
+ 	}
+ 
+ 	num = 0;
+ 	while ((dp = readdir(fd))) {
+ 		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, "..")) {
+ 			continue; /* skip self and parent */
+ 		}
+ 		num++;
+ 	}
+ 
+ 	closedir(fd);
+ 
+ 	return bprintf("%d", num);
+ }
Binary files dwm-6.2/slstatus/components/num_files.o and dwm/slstatus/components/num_files.o differ
diff -crNb dwm-6.2/slstatus/components/ram.c dwm/slstatus/components/ram.c
*** dwm-6.2/slstatus/components/ram.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/ram.c	2021-10-31 17:28:42.561188983 -0300
***************
*** 0 ****
--- 1,222 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(__linux__)
+ 	#include <stdint.h>
+ 
+ 	const char *
+ 	ram_free(void)
+ 	{
+ 		uintmax_t free;
+ 
+ 		if (pscanf("/proc/meminfo",
+ 		           "MemTotal: %ju kB\n"
+ 		           "MemFree: %ju kB\n"
+ 		           "MemAvailable: %ju kB\n",
+ 		           &free, &free, &free) != 3) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(free * 1024, 1024);
+ 	}
+ 
+ 	const char *
+ 	ram_perc(void)
+ 	{
+ 		uintmax_t total, free, buffers, cached;
+ 
+ 		if (pscanf("/proc/meminfo",
+ 		           "MemTotal: %ju kB\n"
+ 		           "MemFree: %ju kB\n"
+ 		           "MemAvailable: %ju kB\n"
+ 		           "Buffers: %ju kB\n"
+ 		           "Cached: %ju kB\n",
+ 		           &total, &free, &buffers, &buffers, &cached) != 5) {
+ 			return NULL;
+ 		}
+ 
+ 		if (total == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", 100 * ((total - free) - (buffers + cached))
+                                / total);
+ 	}
+ 
+ 	const char *
+ 	ram_total(void)
+ 	{
+ 		uintmax_t total;
+ 
+ 		if (pscanf("/proc/meminfo", "MemTotal: %ju kB\n", &total)
+ 		    != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(total * 1024, 1024);
+ 	}
+ 
+ 	const char *
+ 	ram_used(void)
+ 	{
+ 		uintmax_t total, free, buffers, cached;
+ 
+ 		if (pscanf("/proc/meminfo",
+ 		           "MemTotal: %ju kB\n"
+ 		           "MemFree: %ju kB\n"
+ 		           "MemAvailable: %ju kB\n"
+ 		           "Buffers: %ju kB\n"
+ 		           "Cached: %ju kB\n",
+ 		           &total, &free, &buffers, &buffers, &cached) != 5) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((total - free - buffers - cached) * 1024,
+ 		                 1024);
+ 	}
+ #elif defined(__OpenBSD__)
+ 	#include <stdlib.h>
+ 	#include <sys/sysctl.h>
+ 	#include <sys/types.h>
+ 	#include <unistd.h>
+ 
+ 	#define LOG1024 10
+ 	#define pagetok(size, pageshift) (size_t)(size << (pageshift - LOG1024))
+ 
+ 	inline int
+ 	load_uvmexp(struct uvmexp *uvmexp)
+ 	{
+ 		int uvmexp_mib[] = {CTL_VM, VM_UVMEXP};
+ 		size_t size;
+ 
+ 		size = sizeof(*uvmexp);
+ 
+ 		if (sysctl(uvmexp_mib, 2, uvmexp, &size, NULL, 0) >= 0) {
+ 			return 1;
+ 		}
+ 
+ 		return 0;
+ 	}
+ 
+ 	const char *
+ 	ram_free(void)
+ 	{
+ 		struct uvmexp uvmexp;
+ 		int free_pages;
+ 
+ 		if (load_uvmexp(&uvmexp)) {
+ 			free_pages = uvmexp.npages - uvmexp.active;
+ 			return fmt_human(pagetok(free_pages, uvmexp.pageshift) *
+ 			                 1024, 1024);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	ram_perc(void)
+ 	{
+ 		struct uvmexp uvmexp;
+ 		int percent;
+ 
+ 		if (load_uvmexp(&uvmexp)) {
+ 			percent = uvmexp.active * 100 / uvmexp.npages;
+ 			return bprintf("%d", percent);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	ram_total(void)
+ 	{
+ 		struct uvmexp uvmexp;
+ 
+ 		if (load_uvmexp(&uvmexp)) {
+ 			return fmt_human(pagetok(uvmexp.npages,
+ 			                         uvmexp.pageshift) * 1024,
+ 			                 1024);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	ram_used(void)
+ 	{
+ 		struct uvmexp uvmexp;
+ 
+ 		if (load_uvmexp(&uvmexp)) {
+ 			return fmt_human(pagetok(uvmexp.active,
+ 			                         uvmexp.pageshift) * 1024,
+ 			                 1024);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ #elif defined(__FreeBSD__)
+ 	#include <sys/sysctl.h>
+ 	#include <sys/vmmeter.h>
+ 	#include <unistd.h>
+ 	#include <vm/vm_param.h>
+ 
+ 	const char *
+ 	ram_free(void) {
+ 		struct vmtotal vm_stats;
+ 		int mib[] = {CTL_VM, VM_TOTAL};
+ 		size_t len;
+ 
+ 		len = sizeof(struct vmtotal);
+ 		if (sysctl(mib, 2, &vm_stats, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		return fmt_human(vm_stats.t_free * getpagesize(), 1024);
+ 	}
+ 
+ 	const char *
+ 	ram_total(void) {
+ 		long npages;
+ 		size_t len;
+ 
+ 		len = sizeof(npages);
+ 		if (sysctlbyname("vm.stats.vm.v_page_count", &npages, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		return fmt_human(npages * getpagesize(), 1024);
+ 	}
+ 
+ 	const char *
+ 	ram_perc(void) {
+ 		long npages;
+ 		long active;
+ 		size_t len;
+ 
+ 		len = sizeof(npages);
+ 		if (sysctlbyname("vm.stats.vm.v_page_count", &npages, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		if (sysctlbyname("vm.stats.vm.v_active_count", &active, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		return bprintf("%d", active * 100 / npages);
+ 	}
+ 
+ 	const char *
+ 	ram_used(void) {
+ 		long active;
+ 		size_t len;
+ 
+ 		len = sizeof(active);
+ 		if (sysctlbyname("vm.stats.vm.v_active_count", &active, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		return fmt_human(active * getpagesize(), 1024);
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/ram.o and dwm/slstatus/components/ram.o differ
diff -crNb dwm-6.2/slstatus/components/run_command.c dwm/slstatus/components/run_command.c
*** dwm-6.2/slstatus/components/run_command.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/run_command.c	2021-10-31 17:28:42.562188991 -0300
***************
*** 0 ****
--- 1,30 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ #include <string.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ run_command(const char *cmd)
+ {
+ 	char *p;
+ 	FILE *fp;
+ 
+ 	if (!(fp = popen(cmd, "r"))) {
+ 		warn("popen '%s':", cmd);
+ 		return NULL;
+ 	}
+ 	p = fgets(buf, sizeof(buf) - 1, fp);
+ 	if (pclose(fp) < 0) {
+ 		warn("pclose '%s':", cmd);
+ 		return NULL;
+ 	}
+ 	if (!p) {
+ 		return NULL;
+ 	}
+ 	if ((p = strrchr(buf, '\n'))) {
+ 		p[0] = '\0';
+ 	}
+ 
+ 	return buf[0] ? buf : NULL;
+ }
Binary files dwm-6.2/slstatus/components/run_command.o and dwm/slstatus/components/run_command.o differ
diff -crNb dwm-6.2/slstatus/components/separator.c dwm/slstatus/components/separator.c
*** dwm-6.2/slstatus/components/separator.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/separator.c	2021-10-31 17:28:42.562188991 -0300
***************
*** 0 ****
--- 1,10 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdio.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ separator(const char *separator)
+ {
+     return separator;
+ }
Binary files dwm-6.2/slstatus/components/separator.o and dwm/slstatus/components/separator.o differ
diff -crNb dwm-6.2/slstatus/components/swap.c dwm/slstatus/components/swap.c
*** dwm-6.2/slstatus/components/swap.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/swap.c	2021-10-31 17:28:42.565189013 -0300
***************
*** 0 ****
--- 1,284 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdint.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(__linux__)
+ 	static int
+ 	get_swap_info(long *s_total, long *s_free, long *s_cached)
+ 	{
+ 		FILE *fp;
+ 		struct {
+ 			const char *name;
+ 			const size_t len;
+ 			long *var;
+ 		} ent[] = {
+ 			{ "SwapTotal",  sizeof("SwapTotal") - 1,  s_total  },
+ 			{ "SwapFree",   sizeof("SwapFree") - 1,   s_free   },
+ 			{ "SwapCached", sizeof("SwapCached") - 1, s_cached },
+ 		};
+ 		size_t line_len = 0, i, left;
+ 		char *line = NULL;
+ 
+ 		/* get number of fields we want to extract */
+ 		for (i = 0, left = 0; i < LEN(ent); i++) {
+ 			if (ent[i].var) {
+ 				left++;
+ 			}
+ 		}
+ 
+ 		if (!(fp = fopen("/proc/meminfo", "r"))) {
+ 			warn("fopen '/proc/meminfo':");
+ 			return 1;
+ 		}
+ 
+ 		/* read file line by line and extract field information */
+ 		while (left > 0 && getline(&line, &line_len, fp) >= 0) {
+ 			for (i = 0; i < LEN(ent); i++) {
+ 				if (ent[i].var &&
+ 				    !strncmp(line, ent[i].name, ent[i].len)) {
+ 					sscanf(line + ent[i].len + 1,
+ 					       "%ld kB\n", ent[i].var);
+ 					left--;
+ 					break;
+ 				}
+ 			}
+ 		}
+ 		free(line);
+ 		if (ferror(fp)) {
+ 			warn("getline '/proc/meminfo':");
+ 			return 1;
+ 		}
+ 
+ 		fclose(fp);
+ 		return 0;
+ 	}
+ 
+ 	const char *
+ 	swap_free(void)
+ 	{
+ 		long free;
+ 
+ 		if (get_swap_info(NULL, &free, NULL)) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(free * 1024, 1024);
+ 	}
+ 
+ 	const char *
+ 	swap_perc(void)
+ 	{
+ 		long total, free, cached;
+ 
+ 		if (get_swap_info(&total, &free, &cached) || total == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", 100 * (total - free - cached) / total);
+ 	}
+ 
+ 	const char *
+ 	swap_total(void)
+ 	{
+ 		long total;
+ 
+ 		if (get_swap_info(&total, NULL, NULL)) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(total * 1024, 1024);
+ 	}
+ 
+ 	const char *
+ 	swap_used(void)
+ 	{
+ 		long total, free, cached;
+ 
+ 		if (get_swap_info(&total, &free, &cached)) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((total - free - cached) * 1024, 1024);
+ 	}
+ #elif defined(__OpenBSD__)
+ 	#include <stdlib.h>
+ 	#include <sys/swap.h>
+ 	#include <sys/types.h>
+ 	#include <unistd.h>
+ 
+ 	static int
+ 	getstats(int *total, int *used)
+ 	{
+ 		struct swapent *sep, *fsep;
+ 		int rnswap, nswap, i;
+ 
+ 		if ((nswap = swapctl(SWAP_NSWAP, 0, 0)) < 1) {
+ 			warn("swaptctl 'SWAP_NSWAP':");
+ 			return 1;
+ 		}
+ 		if (!(fsep = sep = calloc(nswap, sizeof(*sep)))) {
+ 			warn("calloc 'nswap':");
+ 			return 1;
+ 		}
+ 		if ((rnswap = swapctl(SWAP_STATS, (void *)sep, nswap)) < 0) {
+ 			warn("swapctl 'SWAP_STATA':");
+ 			return 1;
+ 		}
+ 		if (nswap != rnswap) {
+ 			warn("getstats: SWAP_STATS != SWAP_NSWAP");
+ 			return 1;
+ 		}
+ 
+ 		*total = 0;
+ 		*used = 0;
+ 
+ 		for (i = 0; i < rnswap; i++) {
+ 			*total += sep->se_nblks >> 1;
+ 			*used += sep->se_inuse >> 1;
+ 		}
+ 
+ 		free(fsep);
+ 
+ 		return 0;
+ 	}
+ 
+ 	const char *
+ 	swap_free(void)
+ 	{
+ 		int total, used;
+ 
+ 		if (getstats(&total, &used)) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human((total - used) * 1024, 1024);
+ 	}
+ 
+ 	const char *
+ 	swap_perc(void)
+ 	{
+ 		int total, used;
+ 
+ 		if (getstats(&total, &used)) {
+ 			return NULL;
+ 		}
+ 
+ 		if (total == 0) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%d", 100 * used / total);
+ 	}
+ 
+ 	const char *
+ 	swap_total(void)
+ 	{
+ 		int total, used;
+ 
+ 		if (getstats(&total, &used)) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(total * 1024, 1024);
+ 	}
+ 
+ 	const char *
+ 	swap_used(void)
+ 	{
+ 		int total, used;
+ 
+ 		if (getstats(&total, &used)) {
+ 			return NULL;
+ 		}
+ 
+ 		return fmt_human(used * 1024, 1024);
+ 	}
+ #elif defined(__FreeBSD__)
+ 	#include <stdlib.h>
+ 	#include <sys/types.h>
+ 	#include <fcntl.h>
+ 	#include <unistd.h>
+ 	#include <kvm.h>
+ 
+ 	static int getswapinfo(struct kvm_swap *swap_info, size_t size)
+ 	{
+ 		kvm_t *kd;
+ 
+ 		kd = kvm_openfiles(NULL, "/dev/null", NULL, 0, NULL);
+ 		if(kd == NULL) {
+ 			warn("kvm_openfiles '/dev/null':");
+ 			return 0;
+ 		}
+ 
+ 		if(kvm_getswapinfo(kd, swap_info, size, 0 /* Unused flags */) == -1) {
+ 			warn("kvm_getswapinfo:");
+ 			kvm_close(kd);
+ 			return 0;
+ 		}
+ 
+ 		kvm_close(kd);
+ 		return 1;
+ 	}
+ 
+ 	const char *
+ 	swap_free(void)
+ 	{
+ 		struct kvm_swap swap_info[1];
+ 		long used, total;
+ 
+ 		if(!getswapinfo(swap_info, 1))
+ 			return NULL;
+ 
+ 		total = swap_info[0].ksw_total;
+ 		used = swap_info[0].ksw_used;
+ 
+ 		return fmt_human((total - used) * getpagesize(), 1024);
+ 	}
+ 
+ 	const char *
+ 	swap_perc(void)
+ 	{
+ 		struct kvm_swap swap_info[1];
+ 		long used, total;
+ 
+ 		if(!getswapinfo(swap_info, 1))
+ 			return NULL;
+ 
+ 		total = swap_info[0].ksw_total;
+ 		used = swap_info[0].ksw_used;
+ 
+ 		return bprintf("%d", used * 100 / total);
+ 	}
+ 
+ 	const char *
+ 	swap_total(void)
+ 	{
+ 		struct kvm_swap swap_info[1];
+ 		long total;
+ 
+ 		if(!getswapinfo(swap_info, 1))
+ 			return NULL;
+ 
+ 		total = swap_info[0].ksw_total;
+ 
+ 		return fmt_human(total * getpagesize(), 1024);
+ 	}
+ 
+ 	const char *
+ 	swap_used(void)
+ 	{
+ 		struct kvm_swap swap_info[1];
+ 		long used;
+ 
+ 		if(!getswapinfo(swap_info, 1))
+ 			return NULL;
+ 
+ 		used = swap_info[0].ksw_used;
+ 
+ 		return fmt_human(used * getpagesize(), 1024);
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/swap.o and dwm/slstatus/components/swap.o differ
diff -crNb dwm-6.2/slstatus/components/temperature.c dwm/slstatus/components/temperature.c
*** dwm-6.2/slstatus/components/temperature.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/temperature.c	2021-10-31 17:28:42.572189066 -0300
***************
*** 0 ****
--- 1,71 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stddef.h>
+ 
+ #include "../util.h"
+ 
+ 
+ #if defined(__linux__)
+ 	#include <stdint.h>
+ 
+ 	const char *
+ 	temp(const char *file)
+ 	{
+ 		uintmax_t temp;
+ 
+ 		if (pscanf(file, "%ju", &temp) != 1) {
+ 			return NULL;
+ 		}
+ 
+ 		return bprintf("%ju", temp / 1000);
+ 	}
+ #elif defined(__OpenBSD__)
+ 	#include <stdio.h>
+ 	#include <sys/time.h> /* before <sys/sensors.h> for struct timeval */
+ 	#include <sys/sensors.h>
+ 	#include <sys/sysctl.h>
+ 
+ 	const char *
+ 	temp(const char *unused)
+ 	{
+ 		int mib[5];
+ 		size_t size;
+ 		struct sensor temp;
+ 
+ 		mib[0] = CTL_HW;
+ 		mib[1] = HW_SENSORS;
+ 		mib[2] = 0; /* cpu0 */
+ 		mib[3] = SENSOR_TEMP;
+ 		mib[4] = 0; /* temp0 */
+ 
+ 		size = sizeof(temp);
+ 
+ 		if (sysctl(mib, 5, &temp, &size, NULL, 0) < 0) {
+ 			warn("sysctl 'SENSOR_TEMP':");
+ 			return NULL;
+ 		}
+ 
+ 		/* kelvin to celsius */
+ 		return bprintf("%d", (int)((float)(temp.value-273150000) / 1E6));
+ 	}
+ #elif defined(__FreeBSD__)
+ 	#include <stdio.h>
+ 	#include <stdlib.h>
+ 	#include <sys/sysctl.h>
+ 
+ 	const char *
+ 	temp(const char *zone)
+ 	{
+ 		char buf[256];
+ 		int temp;
+ 		size_t len;
+ 
+ 		len = sizeof(temp);
+ 		snprintf(buf, sizeof(buf), "hw.acpi.thermal.%s.temperature", zone);
+ 		if (sysctlbyname(buf, &temp, &len, NULL, 0) == -1
+ 				|| !len)
+ 			return NULL;
+ 
+ 		/* kelvin to decimal celcius */
+ 		return bprintf("%d.%d", (temp - 2731) / 10, abs((temp - 2731) % 10));
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/temperature.o and dwm/slstatus/components/temperature.o differ
diff -crNb dwm-6.2/slstatus/components/uptime.c dwm/slstatus/components/uptime.c
*** dwm-6.2/slstatus/components/uptime.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/uptime.c	2021-10-31 17:28:42.572189066 -0300
***************
*** 0 ****
--- 1,33 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdint.h>
+ #include <stdio.h>
+ #include <time.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(CLOCK_BOOTTIME)
+ 	#define UPTIME_FLAG CLOCK_BOOTTIME
+ #elif defined(CLOCK_UPTIME)
+ 	#define UPTIME_FLAG CLOCK_UPTIME
+ #else
+ 	#define UPTIME_FLAG CLOCK_MONOTONIC
+ #endif
+ 
+ const char *
+ uptime(void)
+ {
+ 	char warn_buf[256];
+ 	uintmax_t h, m;
+ 	struct timespec uptime;
+ 
+ 	if (clock_gettime(UPTIME_FLAG, &uptime) < 0) {
+ 		snprintf(warn_buf, 256, "clock_gettime %d", UPTIME_FLAG);
+ 		warn(warn_buf);
+ 		return NULL;
+ 	}
+ 
+ 	h = uptime.tv_sec / 3600;
+ 	m = uptime.tv_sec % 3600 / 60;
+ 
+ 	return bprintf("%juh %jum", h, m);
+ }
Binary files dwm-6.2/slstatus/components/uptime.o and dwm/slstatus/components/uptime.o differ
diff -crNb dwm-6.2/slstatus/components/user.c dwm/slstatus/components/user.c
*** dwm-6.2/slstatus/components/user.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/user.c	2021-10-31 17:28:42.573189073 -0300
***************
*** 0 ****
--- 1,32 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <pwd.h>
+ #include <stdio.h>
+ #include <sys/types.h>
+ #include <unistd.h>
+ 
+ #include "../util.h"
+ 
+ const char *
+ gid(void)
+ {
+ 	return bprintf("%d", getgid());
+ }
+ 
+ const char *
+ username(void)
+ {
+ 	struct passwd *pw;
+ 
+ 	if (!(pw = getpwuid(geteuid()))) {
+ 		warn("getpwuid '%d':", geteuid());
+ 		return NULL;
+ 	}
+ 
+ 	return bprintf("%s", pw->pw_name);
+ }
+ 
+ const char *
+ uid(void)
+ {
+ 	return bprintf("%d", geteuid());
+ }
Binary files dwm-6.2/slstatus/components/user.o and dwm/slstatus/components/user.o differ
diff -crNb dwm-6.2/slstatus/components/volume.c dwm/slstatus/components/volume.c
*** dwm-6.2/slstatus/components/volume.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/volume.c	2021-10-31 17:28:42.573189073 -0300
***************
*** 0 ****
--- 1,217 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <fcntl.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <sys/ioctl.h>
+ #include <unistd.h>
+ 
+ #include "../util.h"
+ 
+ #if defined(__OpenBSD__)
+ 	#include <sys/queue.h>
+ 	#include <poll.h>
+ 	#include <sndio.h>
+ 	#include <stdlib.h>
+ 
+ 	struct control {
+ 		LIST_ENTRY(control)	next;
+ 		unsigned int		addr;
+ 	#define CTRL_NONE	0
+ 	#define CTRL_LEVEL	1
+ 	#define CTRL_MUTE	2
+ 		unsigned int		type;
+ 		unsigned int		maxval;
+ 		unsigned int		val;
+ 	};
+ 
+ 	static LIST_HEAD(, control) controls = LIST_HEAD_INITIALIZER(controls);
+ 	static struct pollfd *pfds;
+ 	static struct sioctl_hdl *hdl;
+ 	static int initialized;
+ 
+ 	/*
+ 	 * Call-back to obtain the description of all audio controls.
+ 	 */
+ 	static void
+ 	ondesc(void *unused, struct sioctl_desc *desc, int val)
+ 	{
+ 		struct control *c, *ctmp;
+ 		unsigned int type = CTRL_NONE;
+ 
+ 		if (desc == NULL)
+ 			return;
+ 
+ 		/* Delete existing audio control with the same address. */
+ 		LIST_FOREACH_SAFE(c, &controls, next, ctmp) {
+ 			if (desc->addr == c->addr) {
+ 				LIST_REMOVE(c, next);
+ 				free(c);
+ 				break;
+ 			}
+ 		}
+ 
+ 		/* Only match output.level and output.mute audio controls. */
+ 		if (desc->group[0] != 0 ||
+ 		    strcmp(desc->node0.name, "output") != 0)
+ 			return;
+ 		if (desc->type == SIOCTL_NUM &&
+ 		    strcmp(desc->func, "level") == 0)
+ 			type = CTRL_LEVEL;
+ 		else if (desc->type == SIOCTL_SW &&
+ 			 strcmp(desc->func, "mute") == 0)
+ 			type = CTRL_MUTE;
+ 		else
+ 			return;
+ 
+ 		c = malloc(sizeof(struct control));
+ 		if (c == NULL) {
+ 			warn("sndio: failed to allocate audio control\n");
+ 			return;
+ 		}
+ 
+ 		c->addr = desc->addr;
+ 		c->type = type;
+ 		c->maxval = desc->maxval;
+ 		c->val = val;
+ 		LIST_INSERT_HEAD(&controls, c, next);
+ 	}
+ 
+ 	/*
+ 	 * Call-back invoked whenever an audio control changes.
+ 	 */
+ 	static void
+ 	onval(void *unused, unsigned int addr, unsigned int val)
+ 	{
+ 		struct control *c;
+ 
+ 		LIST_FOREACH(c, &controls, next) {
+ 			if (c->addr == addr)
+ 				break;
+ 		}
+ 		c->val = val;
+ 	}
+ 
+ 	static void
+ 	cleanup(void)
+ 	{
+ 		struct control *c;
+ 
+ 		if (hdl) {
+ 			sioctl_close(hdl);
+ 			hdl = NULL;
+ 		}
+ 
+ 		free(pfds);
+ 		pfds = NULL;
+ 
+ 		while (!LIST_EMPTY(&controls)) {
+ 			c = LIST_FIRST(&controls);
+ 			LIST_REMOVE(c, next);
+ 			free(c);
+ 		}
+ 	}
+ 
+ 	static int
+ 	init(void)
+ 	{
+ 		hdl = sioctl_open(SIO_DEVANY, SIOCTL_READ, 0);
+ 		if (hdl == NULL) {
+ 			warn("sndio: cannot open device");
+ 			goto failed;
+ 		}
+ 
+ 		if (!sioctl_ondesc(hdl, ondesc, NULL)) {
+ 			warn("sndio: cannot set control description call-back");
+ 			goto failed;
+ 		}
+ 
+ 		if (!sioctl_onval(hdl, onval, NULL)) {
+ 			warn("sndio: cannot set control values call-back");
+ 			goto failed;
+ 		}
+ 
+ 		pfds = calloc(sioctl_nfds(hdl), sizeof(struct pollfd));
+ 		if (pfds == NULL) {
+ 			warn("sndio: cannot allocate pollfd structures");
+ 			goto failed;
+ 		}
+ 
+ 		return 1;
+ 	failed:
+ 		cleanup();
+ 		return 0;
+ 	}
+ 
+ 	const char *
+ 	vol_perc(const char *unused)
+ 	{
+ 		struct control *c;
+ 		int n, v, value;
+ 
+ 		if (!initialized)
+ 			initialized = init();
+ 
+ 		if (hdl == NULL)
+ 			return NULL;
+ 
+ 		n = sioctl_pollfd(hdl, pfds, POLLIN);
+ 		if (n > 0) {
+ 			n = poll(pfds, n, 0);
+ 			if (n > 0) {
+ 				if (sioctl_revents(hdl, pfds) & POLLHUP) {
+ 					warn("sndio: disconnected");
+ 					cleanup();
+ 					return NULL;
+ 				}
+ 			}
+ 		}
+ 
+ 		value = 100;
+ 		LIST_FOREACH(c, &controls, next) {
+ 			if (c->type == CTRL_MUTE && c->val == 1)
+ 				value = 0;
+ 			else if (c->type == CTRL_LEVEL) {
+ 				v = (c->val * 100 + c->maxval / 2) / c->maxval;
+ 				/* For multiple channels return the minimum. */
+ 				if (v < value)
+ 					value = v;
+ 			}
+ 		}
+ 
+ 		return bprintf("%d", value);
+ 	}
+ #else
+ 	#include <sys/soundcard.h>
+ 
+ 	const char *
+ 	vol_perc(const char *card)
+ 	{
+ 		size_t i;
+ 		int v, afd, devmask;
+ 		char *vnames[] = SOUND_DEVICE_NAMES;
+ 
+ 		if ((afd = open(card, O_RDONLY | O_NONBLOCK)) < 0) {
+ 			warn("open '%s':", card);
+ 			return NULL;
+ 		}
+ 
+ 		if (ioctl(afd, (int)SOUND_MIXER_READ_DEVMASK, &devmask) < 0) {
+ 			warn("ioctl 'SOUND_MIXER_READ_DEVMASK':");
+ 			close(afd);
+ 			return NULL;
+ 		}
+ 		for (i = 0; i < LEN(vnames); i++) {
+ 			if (devmask & (1 << i) && !strcmp("vol", vnames[i])) {
+ 				if (ioctl(afd, MIXER_READ(i), &v) < 0) {
+ 					warn("ioctl 'MIXER_READ(%ld)':", i);
+ 					close(afd);
+ 					return NULL;
+ 				}
+ 			}
+ 		}
+ 
+ 		close(afd);
+ 
+ 		return bprintf("%d", v & 0xff);
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/volume.o and dwm/slstatus/components/volume.o differ
diff -crNb dwm-6.2/slstatus/components/wifi.c dwm/slstatus/components/wifi.c
*** dwm-6.2/slstatus/components/wifi.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/components/wifi.c	2021-10-31 17:28:42.574189081 -0300
***************
*** 0 ****
--- 1,272 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <ifaddrs.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <sys/ioctl.h>
+ #include <sys/socket.h>
+ #include <unistd.h>
+ 
+ #include "../util.h"
+ 
+ #define RSSI_TO_PERC(rssi) \
+ 			rssi >= -50 ? 100 : \
+ 			(rssi <= -100 ? 0 : \
+ 			(2 * (rssi + 100)))
+ 
+ #if defined(__linux__)
+ 	#include <limits.h>
+ 	#include <linux/wireless.h>
+ 
+ 	const char *
+ 	wifi_perc(const char *interface)
+ 	{
+ 		int cur;
+ 		size_t i;
+ 		char *p, *datastart;
+ 		char path[PATH_MAX];
+ 		char status[5];
+ 		FILE *fp;
+ 
+ 		if (esnprintf(path, sizeof(path), "/sys/class/net/%s/operstate",
+ 		              interface) < 0) {
+ 			return NULL;
+ 		}
+ 		if (!(fp = fopen(path, "r"))) {
+ 			warn("fopen '%s':", path);
+ 			return NULL;
+ 		}
+ 		p = fgets(status, 5, fp);
+ 		fclose(fp);
+ 		if (!p || strcmp(status, "up\n") != 0) {
+ 			return NULL;
+ 		}
+ 
+ 		if (!(fp = fopen("/proc/net/wireless", "r"))) {
+ 			warn("fopen '/proc/net/wireless':");
+ 			return NULL;
+ 		}
+ 
+ 		for (i = 0; i < 3; i++) {
+ 			if (!(p = fgets(buf, sizeof(buf) - 1, fp)))
+ 				break;
+ 		}
+ 		fclose(fp);
+ 		if (i < 2 || !p) {
+ 			return NULL;
+ 		}
+ 
+ 		if (!(datastart = strstr(buf, interface))) {
+ 			return NULL;
+ 		}
+ 
+ 		datastart = (datastart+(strlen(interface)+1));
+ 		sscanf(datastart + 1, " %*d   %d  %*d  %*d\t\t  %*d\t   "
+ 		       "%*d\t\t%*d\t\t %*d\t  %*d\t\t %*d", &cur);
+ 
+ 		/* 70 is the max of /proc/net/wireless */
+ 		return bprintf("%d", (int)((float)cur / 70 * 100));
+ 	}
+ 
+ 	const char *
+ 	wifi_essid(const char *interface)
+ 	{
+ 		static char id[IW_ESSID_MAX_SIZE+1];
+ 		int sockfd;
+ 		struct iwreq wreq;
+ 
+ 		memset(&wreq, 0, sizeof(struct iwreq));
+ 		wreq.u.essid.length = IW_ESSID_MAX_SIZE+1;
+ 		if (esnprintf(wreq.ifr_name, sizeof(wreq.ifr_name), "%s",
+ 		              interface) < 0) {
+ 			return NULL;
+ 		}
+ 
+ 		if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+ 			warn("socket 'AF_INET':");
+ 			return NULL;
+ 		}
+ 		wreq.u.essid.pointer = id;
+ 		if (ioctl(sockfd,SIOCGIWESSID, &wreq) < 0) {
+ 			warn("ioctl 'SIOCGIWESSID':");
+ 			close(sockfd);
+ 			return NULL;
+ 		}
+ 
+ 		close(sockfd);
+ 
+ 		if (!strcmp(id, "")) {
+ 			return NULL;
+ 		}
+ 
+ 		return id;
+ 	}
+ #elif defined(__OpenBSD__)
+ 	#include <net/if.h>
+ 	#include <net/if_media.h>
+ 	#include <net80211/ieee80211.h>
+ 	#include <sys/select.h> /* before <sys/ieee80211_ioctl.h> for NBBY */
+ 	#include <net80211/ieee80211_ioctl.h>
+ 	#include <stdlib.h>
+ 	#include <sys/types.h>
+ 
+ 	static int
+ 	load_ieee80211_nodereq(const char *interface, struct ieee80211_nodereq *nr)
+ 	{
+ 		struct ieee80211_bssid bssid;
+ 		int sockfd;
+ 		uint8_t zero_bssid[IEEE80211_ADDR_LEN];
+ 
+ 		memset(&bssid, 0, sizeof(bssid));
+ 		memset(nr, 0, sizeof(struct ieee80211_nodereq));
+ 		if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+ 			warn("socket 'AF_INET':");
+ 			return 0;
+ 		}
+ 		strlcpy(bssid.i_name, interface, sizeof(bssid.i_name));
+ 		if ((ioctl(sockfd, SIOCG80211BSSID, &bssid)) < 0) {
+ 			warn("ioctl 'SIOCG80211BSSID':");
+ 			close(sockfd);
+ 			return 0;
+ 		}
+ 		memset(&zero_bssid, 0, sizeof(zero_bssid));
+ 		if (memcmp(bssid.i_bssid, zero_bssid,
+ 		    IEEE80211_ADDR_LEN) == 0) {
+ 			close(sockfd);
+ 			return 0;
+ 		}
+ 		strlcpy(nr->nr_ifname, interface, sizeof(nr->nr_ifname));
+ 		memcpy(&nr->nr_macaddr, bssid.i_bssid, sizeof(nr->nr_macaddr));
+ 		if ((ioctl(sockfd, SIOCG80211NODE, nr)) < 0 && nr->nr_rssi) {
+ 			warn("ioctl 'SIOCG80211NODE':");
+ 			close(sockfd);
+ 			return 0;
+ 		}
+ 
+ 		return close(sockfd), 1;
+ 	}
+ 
+ 	const char *
+ 	wifi_perc(const char *interface)
+ 	{
+ 		struct ieee80211_nodereq nr;
+ 		int q;
+ 
+ 		if (load_ieee80211_nodereq(interface, &nr)) {
+ 			if (nr.nr_max_rssi) {
+ 				q = IEEE80211_NODEREQ_RSSI(&nr);
+ 			} else {
+ 				q = RSSI_TO_PERC(nr.nr_rssi);
+ 			}
+ 			return bprintf("%d", q);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ 
+ 	const char *
+ 	wifi_essid(const char *interface)
+ 	{
+ 		struct ieee80211_nodereq nr;
+ 
+ 		if (load_ieee80211_nodereq(interface, &nr)) {
+ 			return bprintf("%s", nr.nr_nwid);
+ 		}
+ 
+ 		return NULL;
+ 	}
+ #elif defined(__FreeBSD__)
+ 	#include <net/if.h>
+ 	#include <net80211/ieee80211_ioctl.h>
+ 
+ 	int
+ 	load_ieee80211req(int sock, const char *interface, void *data, int type, size_t *len)
+ 	{
+ 		char warn_buf[256];
+ 		struct ieee80211req ireq;
+ 		memset(&ireq, 0, sizeof(ireq));
+ 		ireq.i_type = type;
+ 		ireq.i_data = (caddr_t) data;
+ 		ireq.i_len = *len;
+ 
+ 		strlcpy(ireq.i_name, interface, sizeof(ireq.i_name));
+ 		if (ioctl(sock, SIOCG80211, &ireq) < 0) {
+ 			snprintf(warn_buf,  sizeof(warn_buf),
+ 					"ioctl: 'SIOCG80211': %d", type);
+ 			warn(warn_buf);
+ 			return 0;
+ 		}
+ 
+ 		*len = ireq.i_len;
+ 		return 1;
+ 	}
+ 
+ 	const char *
+ 	wifi_perc(const char *interface)
+ 	{
+ 		union {
+ 			struct ieee80211req_sta_req sta;
+ 			uint8_t buf[24 * 1024];
+ 		} info;
+ 		uint8_t bssid[IEEE80211_ADDR_LEN];
+ 		int rssi_dbm;
+ 		int sockfd;
+ 		size_t len;
+ 		const char *fmt;
+ 
+ 		if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+ 			warn("socket 'AF_INET':");
+ 			return NULL;
+ 		}
+ 
+ 		/* Retreive MAC address of interface */
+ 		len = IEEE80211_ADDR_LEN;
+ 		fmt = NULL;
+ 		if (load_ieee80211req(sockfd, interface, &bssid, IEEE80211_IOC_BSSID, &len))
+ 		{
+ 			/* Retrieve info on station with above BSSID */
+ 			memset(&info, 0, sizeof(info));
+ 			memcpy(info.sta.is_u.macaddr, bssid, sizeof(bssid));
+ 
+ 			len = sizeof(info);
+ 			if (load_ieee80211req(sockfd, interface, &info, IEEE80211_IOC_STA_INFO, &len)) {
+ 				rssi_dbm = info.sta.info[0].isi_noise +
+  					         info.sta.info[0].isi_rssi / 2;
+ 
+ 				fmt = bprintf("%d", RSSI_TO_PERC(rssi_dbm));
+ 			}
+ 		}
+ 
+ 		close(sockfd);
+ 		return fmt;
+ 	}
+ 
+ 	const char *
+ 	wifi_essid(const char *interface)
+ 	{
+ 		char ssid[IEEE80211_NWID_LEN + 1];
+ 		size_t len;
+ 		int sockfd;
+ 		const char *fmt;
+ 
+ 		if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+ 			warn("socket 'AF_INET':");
+ 			return NULL;
+ 		}
+ 
+ 		fmt = NULL;
+ 		len = sizeof(ssid);
+ 		memset(&ssid, 0, len);
+ 		if (load_ieee80211req(sockfd, interface, &ssid, IEEE80211_IOC_SSID, &len )) {
+ 			if (len < sizeof(ssid))
+ 				len += 1;
+ 			else
+ 				len = sizeof(ssid);
+ 
+ 			ssid[len - 1] = '\0';
+ 			fmt = bprintf("%s", ssid);
+ 		}
+ 
+ 		close(sockfd);
+ 		return fmt;
+ 	}
+ #endif
Binary files dwm-6.2/slstatus/components/wifi.o and dwm/slstatus/components/wifi.o differ
diff -crNb dwm-6.2/slstatus/config.def.h dwm/slstatus/config.def.h
*** dwm-6.2/slstatus/config.def.h	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/config.def.h	2021-10-31 17:28:42.435188037 -0300
***************
*** 0 ****
--- 1,69 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* interval between updates (in ms) */
+ const unsigned int interval = 1000;
+ 
+ /* text to show if no value can be retrieved */
+ static const char unknown_str[] = "n/a";
+ 
+ /* maximum output string length */
+ #define MAXLEN 2048
+ 
+ /*
+  * function            description                     argument (example)
+  *
+  * battery_perc        battery percentage              battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_state       battery charging state          battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_remaining   battery remaining HH:MM         battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * cpu_perc            cpu usage in percent            NULL
+  * cpu_freq            cpu frequency in MHz            NULL
+  * datetime            date and time                   format string (%F %T)
+  * disk_free           free disk space in GB           mountpoint path (/)
+  * disk_perc           disk usage in percent           mountpoint path (/)
+  * disk_total          total disk space in GB          mountpoint path (/")
+  * disk_used           used disk space in GB           mountpoint path (/)
+  * entropy             available entropy               NULL
+  * gid                 GID of current user             NULL
+  * hostname            hostname                        NULL
+  * ipv4                IPv4 address                    interface name (eth0)
+  * ipv6                IPv6 address                    interface name (eth0)
+  * kernel_release      `uname -r`                      NULL
+  * keyboard_indicators caps/num lock indicators        format string (c?n?)
+  *                                                     see keyboard_indicators.c
+  * keymap              layout (variant) of current     NULL
+  *                     keymap
+  * load_avg            load average                    NULL
+  * netspeed_rx         receive network speed           interface name (wlan0)
+  * netspeed_tx         transfer network speed          interface name (wlan0)
+  * num_files           number of files in a directory  path
+  *                                                     (/home/foo/Inbox/cur)
+  * ram_free            free memory in GB               NULL
+  * ram_perc            memory usage in percent         NULL
+  * ram_total           total memory size in GB         NULL
+  * ram_used            used memory in GB               NULL
+  * run_command         custom shell command            command (echo foo)
+  * separator           string to echo                  NULL
+  * swap_free           free swap in GB                 NULL
+  * swap_perc           swap usage in percent           NULL
+  * swap_total          total swap size in GB           NULL
+  * swap_used           used swap in GB                 NULL
+  * temp                temperature in degree celsius   sensor file
+  *                                                     (/sys/class/thermal/...)
+  *                                                     NULL on OpenBSD
+  *                                                     thermal zone on FreeBSD
+  *                                                     (tz0, tz1, etc.)
+  * uid                 UID of current user             NULL
+  * uptime              system uptime                   NULL
+  * username            username of current user        NULL
+  * vol_perc            OSS/ALSA volume in percent      mixer file (/dev/mixer)
+  *                                                     NULL on OpenBSD
+  * wifi_perc           WiFi signal in percent          interface name (wlan0)
+  * wifi_essid          WiFi ESSID                      interface name (wlan0)
+  */
+ static const struct arg args[] = {
+ 	/* function format          argument */
+ 	{ datetime, "%s",           "%F %T" },
+ };
diff -crNb dwm-6.2/slstatus/config.h dwm/slstatus/config.h
*** dwm-6.2/slstatus/config.h	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/config.h	2021-10-31 17:28:42.436188045 -0300
***************
*** 0 ****
--- 1,75 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* interval between updates (in ms) */
+ const unsigned int interval = 1000;
+ 
+ /* text to show if no value can be retrieved */
+ static const char unknown_str[] = "n/a";
+ 
+ /* maximum output string length */
+ #define MAXLEN 2048
+ 
+ /*
+  * function            description                     argument (example)
+  *
+  * battery_perc        battery percentage              battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_state       battery charging state          battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_remaining   battery remaining HH:MM         battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * cpu_perc            cpu usage in percent            NULL
+  * cpu_freq            cpu frequency in MHz            NULL
+  * datetime            date and time                   format string (%F %T)
+  * disk_free           free disk space in GB           mountpoint path (/)
+  * disk_perc           disk usage in percent           mountpoint path (/)
+  * disk_total          total disk space in GB          mountpoint path (/")
+  * disk_used           used disk space in GB           mountpoint path (/)
+  * entropy             available entropy               NULL
+  * gid                 GID of current user             NULL
+  * hostname            hostname                        NULL
+  * ipv4                IPv4 address                    interface name (eth0)
+  * ipv6                IPv6 address                    interface name (eth0)
+  * kernel_release      `uname -r`                      NULL
+  * keyboard_indicators caps/num lock indicators        format string (c?n?)
+  *                                                     see keyboard_indicators.c
+  * keymap              layout (variant) of current     NULL
+  *                     keymap
+  * load_avg            load average                    NULL
+  * netspeed_rx         receive network speed           interface name (wlan0)
+  * netspeed_tx         transfer network speed          interface name (wlan0)
+  * num_files           number of files in a directory  path
+  *                                                     (/home/foo/Inbox/cur)
+  * ram_free            free memory in GB               NULL
+  * ram_perc            memory usage in percent         NULL
+  * ram_total           total memory size in GB         NULL
+  * ram_used            used memory in GB               NULL
+  * run_command         custom shell command            command (echo foo)
+  * separator           string to echo                  NULL
+  * swap_free           free swap in GB                 NULL
+  * swap_perc           swap usage in percent           NULL
+  * swap_total          total swap size in GB           NULL
+  * swap_used           used swap in GB                 NULL
+  * temp                temperature in degree celsius   sensor file
+  *                                                     (/sys/class/thermal/...)
+  *                                                     NULL on OpenBSD
+  *                                                     thermal zone on FreeBSD
+  *                                                     (tz0, tz1, etc.)
+  * uid                 UID of current user             NULL
+  * uptime              system uptime                   NULL
+  * username            username of current user        NULL
+  * vol_perc            OSS/ALSA volume in percent      mixer file (/dev/mixer)
+  *                                                     NULL on OpenBSD
+  * wifi_perc           WiFi signal in percent          interface name (wlan0)
+  * wifi_essid          WiFi ESSID                      interface name (wlan0)
+  */
+ static const struct arg args[] = {
+ 	/* function format          argument */
+   { run_command, "^c#323d43^ ^b#89beba^ ï€¨^c#89beba^ ^b#323d43^ %s ",           "pamixer --get-volume-human" },
+   { separator, "^b#323d43^",           "" },
+   { battery_state, "^c#323d43^ ^b#e68183^ %s",           "BAT0" },
+   { battery_perc, "^c#e68183^ ^b#323d43^ %s%% ",           "BAT0" },
+   { separator, "^b#323d43^",           "" },
+   { datetime, "^c#323d43^ ^b#a7c080^ ï³^c#a7c080^ ^b#323d43^ %s",           "%a %b %d - %R" },
+ };
+ 
diff -crNb dwm-6.2/slstatus/config.h-bak dwm/slstatus/config.h-bak
*** dwm-6.2/slstatus/config.h-bak	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/config.h-bak	2021-10-31 17:28:42.450188150 -0300
***************
*** 0 ****
--- 1,77 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* interval between updates (in ms) */
+ const unsigned int interval = 1000;
+ 
+ /* text to show if no value can be retrieved */
+ static const char unknown_str[] = "n/a";
+ 
+ /* maximum output string length */
+ #define MAXLEN 2048
+ 
+ /*
+  * function            description                     argument (example)
+  *
+  * battery_perc        battery percentage              battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_state       battery charging state          battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_remaining   battery remaining HH:MM         battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * cpu_perc            cpu usage in percent            NULL
+  * cpu_freq            cpu frequency in MHz            NULL
+  * datetime            date and time                   format string (%F %T)
+  * disk_free           free disk space in GB           mountpoint path (/)
+  * disk_perc           disk usage in percent           mountpoint path (/)
+  * disk_total          total disk space in GB          mountpoint path (/")
+  * disk_used           used disk space in GB           mountpoint path (/)
+  * entropy             available entropy               NULL
+  * gid                 GID of current user             NULL
+  * hostname            hostname                        NULL
+  * ipv4                IPv4 address                    interface name (eth0)
+  * ipv6                IPv6 address                    interface name (eth0)
+  * kernel_release      `uname -r`                      NULL
+  * keyboard_indicators caps/num lock indicators        format string (c?n?)
+  *                                                     see keyboard_indicators.c
+  * keymap              layout (variant) of current     NULL
+  *                     keymap
+  * load_avg            load average                    NULL
+  * netspeed_rx         receive network speed           interface name (wlan0)
+  * netspeed_tx         transfer network speed          interface name (wlan0)
+  * num_files           number of files in a directory  path
+  *                                                     (/home/foo/Inbox/cur)
+  * ram_free            free memory in GB               NULL
+  * ram_perc            memory usage in percent         NULL
+  * ram_total           total memory size in GB         NULL
+  * ram_used            used memory in GB               NULL
+  * run_command         custom shell command            command (echo foo)
+  * separator           string to echo                  NULL
+  * swap_free           free swap in GB                 NULL
+  * swap_perc           swap usage in percent           NULL
+  * swap_total          total swap size in GB           NULL
+  * swap_used           used swap in GB                 NULL
+  * temp                temperature in degree celsius   sensor file
+  *                                                     (/sys/class/thermal/...)
+  *                                                     NULL on OpenBSD
+  *                                                     thermal zone on FreeBSD
+  *                                                     (tz0, tz1, etc.)
+  * uid                 UID of current user             NULL
+  * uptime              system uptime                   NULL
+  * username            username of current user        NULL
+  * vol_perc            OSS/ALSA volume in percent      mixer file (/dev/mixer)
+  *                                                     NULL on OpenBSD
+  * wifi_perc           WiFi signal in percent          interface name (wlan0)
+  * wifi_essid          WiFi ESSID                      interface name (wlan0)
+  */
+ static const struct arg args[] = {
+ 	/* function format          argument */
+   { battery_state, "^c#868d80^ %s",           "BAT0" },
+   { battery_perc, "^c#868d80^ %s%% ",           "BAT0" },
+ //  { separator, "^c#868d80^â€¢",           "" },
+   { run_command, "^c#868d80^ ï€¨ %s ",           "pamixer --get-volume-human" },
+ //  { separator, "^c#868d80^â€¢",           "" },
+   { run_command, "^c#323d43^ ^b#e68183^ ï¢†^c#e68183^ ^b#323d43^ %s ",           "playerctl --player=spotifyd,cmus metadata --format '{{ title }} - {{artist}}'" },
+ //  { separator, "^c#868d80^â€¢",           "" },
+   { datetime, "^c#323d43^ ^b#a7c080^ ï³^c#a7c080^ ^b#323d43^ %s",           "%a %b %d - %R" },
+ };
+ 
diff -crNb dwm-6.2/slstatus/config.h-nord dwm/slstatus/config.h-nord
*** dwm-6.2/slstatus/config.h-nord	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/config.h-nord	2021-10-31 17:28:42.450188150 -0300
***************
*** 0 ****
--- 1,79 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* interval between updates (in ms) */
+ const unsigned int interval = 1000;
+ 
+ /* text to show if no value can be retrieved */
+ static const char unknown_str[] = "n/a";
+ 
+ /* maximum output string length */
+ #define MAXLEN 2048
+ 
+ /*
+  * function            description                     argument (example)
+  *
+  * battery_perc        battery percentage              battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_state       battery charging state          battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * battery_remaining   battery remaining HH:MM         battery name (BAT0)
+  *                                                     NULL on OpenBSD/FreeBSD
+  * cpu_perc            cpu usage in percent            NULL
+  * cpu_freq            cpu frequency in MHz            NULL
+  * datetime            date and time                   format string (%F %T)
+  * disk_free           free disk space in GB           mountpoint path (/)
+  * disk_perc           disk usage in percent           mountpoint path (/)
+  * disk_total          total disk space in GB          mountpoint path (/")
+  * disk_used           used disk space in GB           mountpoint path (/)
+  * entropy             available entropy               NULL
+  * gid                 GID of current user             NULL
+  * hostname            hostname                        NULL
+  * ipv4                IPv4 address                    interface name (eth0)
+  * ipv6                IPv6 address                    interface name (eth0)
+  * kernel_release      `uname -r`                      NULL
+  * keyboard_indicators caps/num lock indicators        format string (c?n?)
+  *                                                     see keyboard_indicators.c
+  * keymap              layout (variant) of current     NULL
+  *                     keymap
+  * load_avg            load average                    NULL
+  * netspeed_rx         receive network speed           interface name (wlan0)
+  * netspeed_tx         transfer network speed          interface name (wlan0)
+  * num_files           number of files in a directory  path
+  *                                                     (/home/foo/Inbox/cur)
+  * ram_free            free memory in GB               NULL
+  * ram_perc            memory usage in percent         NULL
+  * ram_total           total memory size in GB         NULL
+  * ram_used            used memory in GB               NULL
+  * run_command         custom shell command            command (echo foo)
+  * separator           string to echo                  NULL
+  * swap_free           free swap in GB                 NULL
+  * swap_perc           swap usage in percent           NULL
+  * swap_total          total swap size in GB           NULL
+  * swap_used           used swap in GB                 NULL
+  * temp                temperature in degree celsius   sensor file
+  *                                                     (/sys/class/thermal/...)
+  *                                                     NULL on OpenBSD
+  *                                                     thermal zone on FreeBSD
+  *                                                     (tz0, tz1, etc.)
+  * uid                 UID of current user             NULL
+  * uptime              system uptime                   NULL
+  * username            username of current user        NULL
+  * vol_perc            OSS/ALSA volume in percent      mixer file (/dev/mixer)
+  *                                                     NULL on OpenBSD
+  * wifi_perc           WiFi signal in percent          interface name (wlan0)
+  * wifi_essid          WiFi ESSID                      interface name (wlan0)
+  */
+ static const struct arg args[] = {
+ 	/* function format          argument */
+   { run_command, "^c#ebcb8b^ %s ",           "playerctl metadata --format '{{ artist }} - {{ title }}'" },
+   { separator, "^c#d8dee9^ |",           "" },
+   { disk_free, "^c#5e81ac^ %s ïƒ‡ ",           "/" },
+   { separator, "^c#d8dee9^ |",           "" },
+   { run_command, "^c#b48ead^ %s ï€¨ ",           "pamixer --get-volume-human" },
+   { separator, "^c#d8dee9^ |",           "" },
+   { battery_perc, "^c#8fbcbb^ %s%% ",           "BAT0" },
+   { battery_state, "^c#8fbcbb^ %s ",           "BAT0" },
+   { separator, "^c#d8dee9^ |",           "" },
+   { datetime, "^c#eceff4^ ï€— %s",           "%a %b %d - %R" },
+ };
+ 
diff -crNb dwm-6.2/slstatus/config.mk dwm/slstatus/config.mk
*** dwm-6.2/slstatus/config.mk	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/config.mk	2021-10-31 17:28:42.450188150 -0300
***************
*** 0 ****
--- 1,22 ----
+ # slstatus version
+ VERSION = 0
+ 
+ # customize below to fit your system
+ 
+ # paths
+ PREFIX = /usr/local
+ MANPREFIX = $(PREFIX)/share/man
+ 
+ X11INC = /usr/X11R6/include
+ X11LIB = /usr/X11R6/lib
+ 
+ # flags
+ CPPFLAGS = -I$(X11INC) -D_DEFAULT_SOURCE
+ CFLAGS   = -std=c99 -pedantic -Wall -Wextra -Os
+ LDFLAGS  = -L$(X11LIB) -s
+ # OpenBSD: add -lsndio
+ # FreeBSD: add -lkvm
+ LDLIBS   = -lX11
+ 
+ # compiler and linker
+ CC = cc
Binary files dwm-6.2/slstatus/slstatus and dwm/slstatus/slstatus differ
diff -crNb dwm-6.2/slstatus/slstatus.1 dwm/slstatus/slstatus.1
*** dwm-6.2/slstatus/slstatus.1	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/slstatus.1	2021-10-31 17:28:42.472188315 -0300
***************
*** 0 ****
--- 1,28 ----
+ .Dd 2020-06-23
+ .Dt SLSTATUS 1
+ .Os
+ .Sh NAME
+ .Nm slstatus
+ .Nd suckless status monitor
+ .Sh SYNOPSIS
+ .Nm
+ .Op Fl s
+ .Op Fl 1
+ .Sh DESCRIPTION
+ .Nm
+ is a suckless status monitor for window managers that use WM_NAME (e.g. dwm) or
+ stdin to fill the status bar.
+ By default,
+ .Nm
+ outputs to WM_NAME.
+ .Sh OPTIONS
+ .Bl -tag -width Ds
+ .It Fl s
+ Write to stdout instead of WM_NAME.
+ .It Fl 1
+ Write once to stdout and quit.
+ .El
+ .Sh CUSTOMIZATION
+ .Nm
+ can be customized by creating a custom config.h and (re)compiling the source
+ code. This keeps it fast, secure and simple.
diff -crNb dwm-6.2/slstatus/slstatus.c dwm/slstatus/slstatus.c
*** dwm-6.2/slstatus/slstatus.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/slstatus.c	2021-10-31 17:28:42.482188390 -0300
***************
*** 0 ****
--- 1,141 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <errno.h>
+ #include <signal.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <time.h>
+ #include <X11/Xlib.h>
+ 
+ #include "arg.h"
+ #include "slstatus.h"
+ #include "util.h"
+ 
+ struct arg {
+ 	const char *(*func)();
+ 	const char *fmt;
+ 	const char *args;
+ };
+ 
+ char buf[1024];
+ static volatile sig_atomic_t done;
+ static Display *dpy;
+ 
+ #include "config.h"
+ 
+ static void
+ terminate(const int signo)
+ {
+ 	if (signo != SIGUSR1)
+ 		done = 1;
+ }
+ 
+ static void
+ difftimespec(struct timespec *res, struct timespec *a, struct timespec *b)
+ {
+ 	res->tv_sec = a->tv_sec - b->tv_sec - (a->tv_nsec < b->tv_nsec);
+ 	res->tv_nsec = a->tv_nsec - b->tv_nsec +
+ 	               (a->tv_nsec < b->tv_nsec) * 1E9;
+ }
+ 
+ static void
+ usage(void)
+ {
+ 	die("usage: %s [-s] [-1]", argv0);
+ }
+ 
+ int
+ main(int argc, char *argv[])
+ {
+ 	struct sigaction act;
+ 	struct timespec start, current, diff, intspec, wait;
+ 	size_t i, len;
+ 	int sflag, ret;
+ 	char status[MAXLEN];
+ 	const char *res;
+ 
+ 	sflag = 0;
+ 	ARGBEGIN {
+ 		case '1':
+ 			done = 1;
+ 			/* fallthrough */
+ 		case 's':
+ 			sflag = 1;
+ 			break;
+ 		default:
+ 			usage();
+ 	} ARGEND
+ 
+ 	if (argc) {
+ 		usage();
+ 	}
+ 
+ 	memset(&act, 0, sizeof(act));
+ 	act.sa_handler = terminate;
+ 	sigaction(SIGINT,  &act, NULL);
+ 	sigaction(SIGTERM, &act, NULL);
+ 	act.sa_flags |= SA_RESTART;
+ 	sigaction(SIGUSR1, &act, NULL);
+ 
+ 	if (!sflag && !(dpy = XOpenDisplay(NULL))) {
+ 		die("XOpenDisplay: Failed to open display");
+ 	}
+ 
+ 	do {
+ 		if (clock_gettime(CLOCK_MONOTONIC, &start) < 0) {
+ 			die("clock_gettime:");
+ 		}
+ 
+ 		status[0] = '\0';
+ 		for (i = len = 0; i < LEN(args); i++) {
+ 			if (!(res = args[i].func(args[i].args))) {
+ 				res = unknown_str;
+ 			}
+ 			if ((ret = esnprintf(status + len, sizeof(status) - len,
+ 			                    args[i].fmt, res)) < 0) {
+ 				break;
+ 			}
+ 			len += ret;
+ 		}
+ 
+ 		if (sflag) {
+ 			puts(status);
+ 			fflush(stdout);
+ 			if (ferror(stdout))
+ 				die("puts:");
+ 		} else {
+ 			if (XStoreName(dpy, DefaultRootWindow(dpy), status)
+                             < 0) {
+ 				die("XStoreName: Allocation failed");
+ 			}
+ 			XFlush(dpy);
+ 		}
+ 
+ 		if (!done) {
+ 			if (clock_gettime(CLOCK_MONOTONIC, &current) < 0) {
+ 				die("clock_gettime:");
+ 			}
+ 			difftimespec(&diff, &current, &start);
+ 
+ 			intspec.tv_sec = interval / 1000;
+ 			intspec.tv_nsec = (interval % 1000) * 1E6;
+ 			difftimespec(&wait, &intspec, &diff);
+ 
+ 			if (wait.tv_sec >= 0) {
+ 				if (nanosleep(&wait, NULL) < 0 &&
+ 				    errno != EINTR) {
+ 					die("nanosleep:");
+ 				}
+ 			}
+ 		}
+ 	} while (!done);
+ 
+ 	if (!sflag) {
+ 		XStoreName(dpy, DefaultRootWindow(dpy), NULL);
+ 		if (XCloseDisplay(dpy) < 0) {
+ 			die("XCloseDisplay: Failed to close display");
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
diff -crNb dwm-6.2/slstatus/slstatus.h dwm/slstatus/slstatus.h
*** dwm-6.2/slstatus/slstatus.h	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/slstatus.h	2021-10-31 17:28:42.482188390 -0300
***************
*** 0 ****
--- 1,84 ----
+ /* See LICENSE file for copyright and license details. */
+ 
+ /* battery */
+ const char *battery_perc(const char *);
+ const char *battery_state(const char *);
+ const char *battery_remaining(const char *);
+ 
+ /* cpu */
+ const char *cpu_freq(void);
+ const char *cpu_perc(void);
+ 
+ /* datetime */
+ const char *datetime(const char *fmt);
+ 
+ /* disk */
+ const char *disk_free(const char *path);
+ const char *disk_perc(const char *path);
+ const char *disk_total(const char *path);
+ const char *disk_used(const char *path);
+ 
+ /* entropy */
+ const char *entropy(void);
+ 
+ /* hostname */
+ const char *hostname(void);
+ 
+ /* ip */
+ const char *ipv4(const char *interface);
+ const char *ipv6(const char *interface);
+ 
+ /* kernel_release */
+ const char *kernel_release(void);
+ 
+ /* keyboard_indicators */
+ const char *keyboard_indicators(void);
+ 
+ /* keymap */
+ const char *keymap(void);
+ 
+ /* load_avg */
+ const char *load_avg(void);
+ 
+ /* netspeeds */
+ const char *netspeed_rx(const char *interface);
+ const char *netspeed_tx(const char *interface);
+ 
+ /* num_files */
+ const char *num_files(const char *path);
+ 
+ /* ram */
+ const char *ram_free(void);
+ const char *ram_perc(void);
+ const char *ram_total(void);
+ const char *ram_used(void);
+ 
+ /* run_command */
+ const char *run_command(const char *cmd);
+ 
+ /* separator */
+ const char *separator(const char *separator);
+ 
+ /* swap */
+ const char *swap_free(void);
+ const char *swap_perc(void);
+ const char *swap_total(void);
+ const char *swap_used(void);
+ 
+ /* temperature */
+ const char *temp(const char *);
+ 
+ /* uptime */
+ const char *uptime(void);
+ 
+ /* user */
+ const char *gid(void);
+ const char *username(void);
+ const char *uid(void);
+ 
+ /* volume */
+ const char *vol_perc(const char *card);
+ 
+ /* wifi */
+ const char *wifi_perc(const char *interface);
+ const char *wifi_essid(const char *interface);
Binary files dwm-6.2/slstatus/slstatus.o and dwm/slstatus/slstatus.o differ
diff -crNb dwm-6.2/slstatus/util.c dwm/slstatus/util.c
*** dwm-6.2/slstatus/util.c	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/util.c	2021-10-31 17:28:42.483188398 -0300
***************
*** 0 ****
--- 1,146 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <errno.h>
+ #include <stdarg.h>
+ #include <stdint.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ 
+ #include "util.h"
+ 
+ char *argv0;
+ 
+ static void
+ verr(const char *fmt, va_list ap)
+ {
+ 	if (argv0 && strncmp(fmt, "usage", sizeof("usage") - 1)) {
+ 		fprintf(stderr, "%s: ", argv0);
+ 	}
+ 
+ 	vfprintf(stderr, fmt, ap);
+ 
+ 	if (fmt[0] && fmt[strlen(fmt) - 1] == ':') {
+ 		fputc(' ', stderr);
+ 		perror(NULL);
+ 	} else {
+ 		fputc('\n', stderr);
+ 	}
+ }
+ 
+ void
+ warn(const char *fmt, ...)
+ {
+ 	va_list ap;
+ 
+ 	va_start(ap, fmt);
+ 	verr(fmt, ap);
+ 	va_end(ap);
+ }
+ 
+ void
+ die(const char *fmt, ...)
+ {
+ 	va_list ap;
+ 
+ 	va_start(ap, fmt);
+ 	verr(fmt, ap);
+ 	va_end(ap);
+ 
+ 	exit(1);
+ }
+ 
+ static int
+ evsnprintf(char *str, size_t size, const char *fmt, va_list ap)
+ {
+ 	int ret;
+ 
+ 	ret = vsnprintf(str, size, fmt, ap);
+ 
+ 	if (ret < 0) {
+ 		warn("vsnprintf:");
+ 		return -1;
+ 	} else if ((size_t)ret >= size) {
+ 		warn("vsnprintf: Output truncated");
+ 		return -1;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ int
+ esnprintf(char *str, size_t size, const char *fmt, ...)
+ {
+ 	va_list ap;
+ 	int ret;
+ 
+ 	va_start(ap, fmt);
+ 	ret = evsnprintf(str, size, fmt, ap);
+ 	va_end(ap);
+ 
+ 	return ret;
+ }
+ 
+ const char *
+ bprintf(const char *fmt, ...)
+ {
+ 	va_list ap;
+ 	int ret;
+ 
+ 	va_start(ap, fmt);
+ 	ret = evsnprintf(buf, sizeof(buf), fmt, ap);
+ 	va_end(ap);
+ 
+ 	return (ret < 0) ? NULL : buf;
+ }
+ 
+ const char *
+ fmt_human(uintmax_t num, int base)
+ {
+ 	double scaled;
+ 	size_t i, prefixlen;
+ 	const char **prefix;
+ 	const char *prefix_1000[] = { "", "k", "M", "G", "T", "P", "E", "Z",
+ 	                              "Y" };
+ 	const char *prefix_1024[] = { "", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei",
+ 	                              "Zi", "Yi" };
+ 
+ 	switch (base) {
+ 	case 1000:
+ 		prefix = prefix_1000;
+ 		prefixlen = LEN(prefix_1000);
+ 		break;
+ 	case 1024:
+ 		prefix = prefix_1024;
+ 		prefixlen = LEN(prefix_1024);
+ 		break;
+ 	default:
+ 		warn("fmt_human: Invalid base");
+ 		return NULL;
+ 	}
+ 
+ 	scaled = num;
+ 	for (i = 0; i < prefixlen && scaled >= base; i++) {
+ 		scaled /= base;
+ 	}
+ 
+ 	return bprintf("%.1f %s", scaled, prefix[i]);
+ }
+ 
+ int
+ pscanf(const char *path, const char *fmt, ...)
+ {
+ 	FILE *fp;
+ 	va_list ap;
+ 	int n;
+ 
+ 	if (!(fp = fopen(path, "r"))) {
+ 		warn("fopen '%s':", path);
+ 		return -1;
+ 	}
+ 	va_start(ap, fmt);
+ 	n = vfscanf(fp, fmt, ap);
+ 	va_end(ap);
+ 	fclose(fp);
+ 
+ 	return (n == EOF) ? -1 : n;
+ }
diff -crNb dwm-6.2/slstatus/util.h dwm/slstatus/util.h
*** dwm-6.2/slstatus/util.h	1969-12-31 21:00:00.000000000 -0300
--- dwm/slstatus/util.h	2021-10-31 17:28:42.483188398 -0300
***************
*** 0 ****
--- 1,16 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <stdint.h>
+ 
+ extern char buf[1024];
+ 
+ #define LEN(x) (sizeof (x) / sizeof *(x))
+ 
+ extern char *argv0;
+ 
+ void warn(const char *, ...);
+ void die(const char *, ...);
+ 
+ int esnprintf(char *str, size_t size, const char *fmt, ...);
+ const char *bprintf(const char *fmt, ...);
+ const char *fmt_human(uintmax_t num, int base);
+ int pscanf(const char *path, const char *fmt, ...);
Binary files dwm-6.2/slstatus/util.o and dwm/slstatus/util.o differ
Binary files dwm-6.2/util.o and dwm/util.o differ
